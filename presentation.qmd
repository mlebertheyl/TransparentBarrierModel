---
title: ""
title-slide-attributes:
  data-background-size: contain
  data-background-opacity: "1"
format: revealjs
smaller: true
scrollable: true
logo: icons/dugong.png
editor: visual
---

```{r, include=FALSE}
library(citr)
library(magick)
```

```{r ba, echo=FALSE}
image_read("4copy/1.png")
```

```{r}
big_dugong <- image_read("icons/dugong.png")
image_write(big_dugong, path = "final.png", format = "png")
```

## Motivation

### The Saudi Arabian Red Sea coast

```{r, include = FALSE}
# https://www.flaticon.com/
dng_icon <- "icons/dugong.png"
```

```{r, include = FALSE}
library(leaflet)
library(leafpop)
library(leaflet.extras)
library(htmltools)
library(sf)
library(tidyverse)
library(rnaturalearth)
library(lattice)
library(htmlwidgets)
library(widgetframe)
library(shiny)
library(sp)
library(mapdata)
library(maptools)
library(rgeos)
library(raster)
library(terra)
require(devtools)
library(fields)
library(terra)
library(ggplot2)
library(scales)
```

```{r, include = FALSE}
# from chunk 1 and 2 in "mybath_explore"
# from chunk 1:
# load data w/ raster lib
dng_icon <- "dng.data/dugong.png"

bathym_ <- raster("dng.data/RSPbathym100m.tif")
crs_longlat <- CRS("+proj=longlat +datum=WGS84")
crs_km <- CRS("+proj=utm +zone=39 ellps=WGS84 +units=km")
bathym_longlat <- projectRaster(bathym_, crs = crs_longlat)
bathym_km <- projectRaster(bathym_, crs = crs_km)

# Data for all species from helicopter surveys.
Data_allspp <- readRDS("dng.data/RSP_survey_sightings.rds")
# Data Incidental Sightings Dugongs

Data_ISD <- readRDS("dng.data/incidental_sightings_dugongs.rds")

# Data for the 10 different species. 
# The list number corresponds to sppID, e.g. species 7 is spp[[7]]
spp_ <- 10
spp <- list()
for (s in 1:spp_) {
  data <- Data_allspp %>% filter(sp_grp_nam == paste0("spp", as.character(s)))
  spp[[s]] <- data
}
# e.g. species 7 is spp[[7]]
spp[[7]]

# RUN myData, and generic functions FIRST
# Data for all species from helicopter surveys.
# Data_allspp <- readRDS("RSP_survey_sightings.rds")
# Data for DUGONG
# Data Incidental Sightings Dugongs
# Data_ISD <- readRDS("incidental_sightings_dugongs.rds")

Data_7spp <- spp[[7]]

# bind ISD with Survey helicopter data
# Dugong is the only one that has data coming from 2 sources.
Data_ISD_ <-dplyr::select(Data_ISD, c(Lat, Long, geometry)) %>% 
  rename(lat = Lat, long = Long) %>% 
  mutate(method = "ISD")
```

```{r, include = FALSE}
spp7 <- dplyr::select(Data_7spp, c(lat, long, geometry)) %>% 
  mutate(method = "Survey")
all_dugong <- rbind(Data_ISD_, spp7)
st_crs(Data_ISD_)
Data_ISD <- st_transform(Data_ISD_, crs_km)
cords_Dng.xy <- st_coordinates(Data_ISD)
cords_Dng.sp <- SpatialPoints(cords_Dng.xy, proj4string = crs_km)
```

```{r, echo=FALSE}
#plot1
leaflet() %>% 
  setView(lng = median(Data_ISD$long), lat = median(Data_ISD$lat), zoom = 8) %>%
  addProviderTiles(providers$OpenStreetMap, group = "Open Street Map") %>% 
  # Add additional basemap layers
  addProviderTiles(providers$Esri.WorldImagery, group = "ESRI World Imagery") %>% 
  addProviderTiles(providers$Esri.OceanBasemap, group = "ESRI Ocean Basemap") %>% 
  # Add a User-Interface (UI) control to switch layers
  addLayersControl(
    baseGroups = c("Open Street Map","ESRI World Imagery","ESRI Ocean Basemap"),
    options = layersControlOptions(collapsed = FALSE))
```

## Motivation

Consider fish in shallow waters. An *impermeable* barrier would be a set of islands that fish cannot cross. However, sand patches with little water coverage are not fully *impermeable*; fish can cross them, but less frequently than non-barrier areas.

### Abstract

In the presence of physical barriers, the assumption of stationarity for Spatial Gaussian fields (SGFs) no longer holds. However, the models proposed for non-stationary cases assume all barriers are *impermeable*, which is quite restrictive when barriers are of different natures. For applications requiring a model that includes barriers with different *permeability*, the Transparent Barrier model is proposed.

## Objectives

### Project 1:

-   Develop a model explicitly considering "obstacles" in space to model species distribution.
-   Retain computational efficiency inherent to stationary models.
-   Interpretation that relies on intuition for the parameters.

### Project 2:

-   Implement the model in R-INLA.
-   Study Marine Megafauna on the Red Sea Coast

### Project 3:

-   Applying our model in different sampling schemes like line transect surveys.

-   Consider distance sampling framework where detection depends on the distance from the observer or transect line.

# Project 1: Transparent Barrier model

## Introduction

### Background

In spatial statistics, the Matérn model with Matérn covariance is frequently employed for representing SGFs (Whittle, 1954; Stein, 1999; Diggle, 2010)). Contributing to its interest is the INLA-SPDE framework (Rue et al., 2009; Lindgren et al., 2011) which reduces the burden of dealing with large covariance matrices by relying on sparse precision matrices. This has led to extensive use of the Matérn covariance not only in Gaussian likelihood settings, but also in more complex contexts such as marked point pattern models (Illian et al., 2012; Simpson).

## 

The Matérn covariance for the random process $\mu(s)$ built as a function of the distance $||s_i-s_j||$ between points $s_i$ and $s_j$ is given by

$$Cov\left(\mu(s_i), \mu(s_j)\right)=\sigma_{\mu}^2 \frac{2^{1-\nu}}{\Gamma(\nu)}\left( \kappa\left\|s_i-s_j\right\| \right)^{\nu}K_\nu\left(\kappa\left\|s_i-s_j\right\| \right)$$

where $\sigma_{\mu}^2$ is the marginal standard deviation for the random process $\mu$, $K_\nu$ the modified Bessel function of second order, and $\nu>0$, and $\kappa>0$, the smoothness and scaling parameters.

By setting $\nu=1$ and $\kappa$ to its empirically derived definition $\kappa = \sqrt{8 \nu}/r$ we get

$$Cov\left(\mu(s_i), \mu(s_j)\right)=\sigma_{\mu}^2 \left (\frac{\sqrt{8}}{r}\left\|s_i-s_j\right\|\right ) K_1 \left (\frac{\sqrt{8}}{r}\left\|s_i-s_j\right\|\right )$$

where $r=\sqrt{8 \nu}/\kappa$ the range parameter. $r$ is constant and interpretable since it is the number of units such that the correlation between two points is approximately $0.1$.

Because the Matérn covariance is a function of the Euclidean distance the SGF is assumed to be stationary and isotropic (from here on both qualities are referred to as stationarity), implying that the random process remains unchanged when the underlying map is moved or rotated.

### The (re-parametrized) SPDE

The SPDE approach constructs a continuously indexed approximation of the Gaussian random field by using an SPDE model instead of a discrete model on a set on a grid. The Matérn field $\mu(s)$ is the stationary solution of an SPDE. For the Barrier model a different Matérn field was introduced on normal area and barrier area, then $\mu(s)$ is the solution to

$$
x(s) - \nabla \cdot \frac{r^2}{8} \nabla x(s) = r \sqrt{\frac{\pi}{2}} \sigma_x \mathcal{W}(s)
$$

where $\Omega_n$ is the normal area, $\Omega_b$ the barrier area, and the disjoint union of both $\Omega_n$ and $\Omega_b$ gives the whole study area $\Omega$. $r_n$ is the range parameter for the normal area, and $r_b$ is the range parameter for the barrier. $r_b$ is close to $0$ to remove the correlation in this area, and it is a fixed fraction of $r_n$ so that $r_b=r_n/h$, where $h$ is a constant (e.g. $10$). $\nabla=\left(\frac{\partial}{\partial x}, \frac{\partial}{\partial y}\right)$, $\sigma_{\mu}$ is the same constant as *eq1*, and $\mathcal{W}(s)$ is white noise.

## The Transparent Barrier Model

The Transparent Barrier model approach comes directly from the barrier model. The difference is in thinking of the study area $\Omega$ not only as $\Omega_n$ and $\Omega_b$, but $\Omega_n$ and $\Omega_{b_{i}}$ with $i=1,...,l$ and $l$ the number of barriers with different permeability. Then the SPDE representation for the Matérn field for the normal area and the Matérn field for the different types of barriers is

where $x(s)$ is the Gaussian field for $s \in \Omega \subseteq \mathbb{R}^2$, $\nabla = \left( \frac{\partial}{\partial x}, \frac{\partial}{\partial y} \right)$, and $\mathcal{W}(s)$ is white noise.

### SPDE for Normal and Barrier Areas

$$
\begin{aligned}
& x(s) - \nabla \cdot \frac{r_n^2}{8} \nabla x(s) = r_n \sqrt{\frac{\pi}{2}} \sigma_x \mathcal{W}(s), \text{ for } s \in \Omega_n \\
& x(s) - \nabla \cdot \frac{r_{b_1}^2}{8} \nabla x(s) = r_{b_1} \sqrt{\frac{\pi}{2}} \sigma_x \mathcal{W}(s), \text{ for } s \in \Omega_{b_1} \\
& x(s) - \nabla \cdot \frac{r_{b_2}^2}{8} \nabla x(s) = r_{b_2} \sqrt{\frac{\pi}{2}} \sigma_x \mathcal{W}(s), \text{ for } s \in \Omega_{b_2} \\
& \vdots \\
& x(s) - \nabla \cdot \frac{r_{b_l}^2}{8} \nabla x(s) = r_{b_l} \sqrt{\frac{\pi}{2}} \sigma_x \mathcal{W}(s), \text{ for } s \in \Omega_{b_l}
\end{aligned}
$$

where $r_n$ is the range parameter for the normal area, and $r_{b_1}$ to $r_{b_l}$ are the range parameters for the barrier areas with different \textit{permeability} or \textit{transparency}. The disjoint union of $\Omega_n$ and all $\Omega_{b_i}$ give the study area $\Omega$.

## Mesh

### Delaunay triangulation for two different geometries.

```{r, echo=FALSE, out.width="50%", fig.cap= "Delaunay triangulation for two different geometries."}
r <- magick::image_read("plots/mesh/mesh1.png")
t <- magick::image_read("plots/mesh/mesh1.1.png")
t <- magick::image_scale(t, "350")

y <- magick::image_read("plots/mesh/mesh2.png")
u <- magick::image_read("plots/mesh/mesh2.2.png")
u <- magick::image_scale(u, "350")


a <- c(r,t); a <- image_append(a, stack = F)
b <- c(y,u); b <- image_append(b, stack = F)
image_append(c(a,b), stack = TRUE)
```

## 

### Correlation plots for scenario with two barriers separated by a canal. Range fractions 0.01, 0.2, 0.3, 0.5, 0.7, 0.8, and 1 in rows from top to bottom.

```{r, echo=FALSE, out.width="100%", fig.cap= "Correlation plots for scenario with two barriers separated by a canal. Range fractions 0.01, 0.2, 0.3, 0.5, 0.7, 0.8, and 1 in rows from top to bottom."}

###0.01
r <- magick::image_read("plots/corr2points_m1point1/0.01.png")
r <- magick::image_crop(r, geometry = "480x480-0+000")

t <- magick::image_read("plots/corr2points_m1point2/0.01.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m1point3/0.01.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m1point4/0.01.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

i <- magick::image_read("plots/corr2points_m1point5/0.01.png")
i <- magick::image_crop(i, geometry = "480x480-90+000")

a <- image_append(c(i,u,y,t,r), stack = F)


## 0.2
r <- magick::image_read("plots/corr2points_m1point1/0.2.png")
r <- magick::image_crop(r, geometry = "480x480-00+000")

t <- magick::image_read("plots/corr2points_m1point2/0.2.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m1point3/0.2.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m1point4/0.2.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

i <- magick::image_read("plots/corr2points_m1point5/0.2.png")
i <- magick::image_crop(i, geometry = "480x480-90+000")

s <- image_append(c(i,u,y,t,r), stack = F)

## 0.3
r <- magick::image_read("plots/corr2points_m1point1/0.3.png")
r <- magick::image_crop(r, geometry = "480x480-0+000")

t <- magick::image_read("plots/corr2points_m1point2/0.3.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m1point3/0.3.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m1point4/0.3.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

i <- magick::image_read("plots/corr2points_m1point5/0.3.png")
i <- magick::image_crop(i, geometry = "480x480-90+000")

d <- image_append(c(i,u,y,t,r), stack = F)

## 0.5
r <- magick::image_read("plots/corr2points_m1point1/0.5.png")
r <- magick::image_crop(r, geometry = "480x480-0+000")

t <- magick::image_read("plots/corr2points_m1point2/0.5.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m1point3/0.5.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m1point4/0.5.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

i <- magick::image_read("plots/corr2points_m1point5/0.5.png")
i <- magick::image_crop(i, geometry = "480x480-90+000")

f <- image_append(c(i,u,y,t,r), stack = F)

## 0.7
r <- magick::image_read("plots/corr2points_m1point1/0.7.png")
r <- magick::image_crop(r, geometry = "480x480-0+000")

t <- magick::image_read("plots/corr2points_m1point2/0.7.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m1point3/0.7.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m1point4/0.7.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

i <- magick::image_read("plots/corr2points_m1point5/0.7.png")
i <- magick::image_crop(i, geometry = "480x480-90+000")

g <- image_append(c(i,u,y,t,r), stack = F)

### 0.8

r <- magick::image_read("plots/corr2points_m1point1/0.8.png")
r <- magick::image_crop(r, geometry = "480x480-0+000")

t <- magick::image_read("plots/corr2points_m1point2/0.8.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m1point3/0.8.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m1point4/0.8.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

i <- magick::image_read("plots/corr2points_m1point5/0.8.png")
i <- magick::image_crop(i, geometry = "480x480-90+000")

h <- image_append(c(i,u,y,t,r), stack = F)

### 1

r <- magick::image_read("plots/corr2points_m1point1/1.png")
r <- magick::image_crop(r, geometry = "480x480-0+000")

t <- magick::image_read("plots/corr2points_m1point2/1.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m1point3/1.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m1point4/1.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

i <- magick::image_read("plots/corr2points_m1point5/1.png")
i <- magick::image_crop(i, geometry = "480x480-90+000")

j <- image_append(c(i,u,y,t,r), stack = F)


#aa <- image_append(c(j,h,g,f,d,s,a), stack = TRUE)
aa <- image_append(c(a,s,d,f,g,h,j), stack = TRUE)


###########
r <- magick::image_read("plots/corr2points_m2point1/0.01.png")
r <- magick::image_crop(r, geometry = "480x480-0+000")

t <- magick::image_read("plots/corr2points_m2point2/0.01.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m2point3/0.01.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m2point4/0.01.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

a <- image_append(c(u,y,t,r), stack = F)


## 0.2
r <- magick::image_read("plots/corr2points_m2point1/0.2.png")
r <- magick::image_crop(r, geometry = "480x480-00+000")

t <- magick::image_read("plots/corr2points_m2point2/0.2.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m2point3/0.2.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m2point4/0.2.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

s <- image_append(c(u,y,t,r), stack = F)

## 0.3
r <- magick::image_read("plots/corr2points_m2point1/0.3.png")
r <- magick::image_crop(r, geometry = "480x480-0+000")

t <- magick::image_read("plots/corr2points_m2point2/0.3.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m2point3/0.3.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m2point4/0.3.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

d <- image_append(c(u,y,t,r), stack = F)

## 0.5
r <- magick::image_read("plots/corr2points_m2point1/0.5.png")
r <- magick::image_crop(r, geometry = "480x480-0+000")

t <- magick::image_read("plots/corr2points_m2point2/0.5.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m2point3/0.5.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m2point4/0.5.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

f <- image_append(c(u,y,t,r), stack = F)

## 0.7
r <- magick::image_read("plots/corr2points_m2point1/0.7.png")
r <- magick::image_crop(r, geometry = "480x480-0+000")

t <- magick::image_read("plots/corr2points_m2point2/0.7.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m2point3/0.7.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m2point4/0.7.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

g <- image_append(c(u,y,t,r), stack = F)

### 0.8

r <- magick::image_read("plots/corr2points_m2point1/0.8.png")
r <- magick::image_crop(r, geometry = "480x480-0+000")

t <- magick::image_read("plots/corr2points_m2point2/0.8.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m2point3/0.8.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m2point4/0.8.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")

h <- image_append(c(u,y,t,r), stack = F)

### 1

r <- magick::image_read("plots/corr2points_m2point1/1.png")
r <- magick::image_crop(r, geometry = "480x480-0+000")

t <- magick::image_read("plots/corr2points_m2point2/1.png")
t <- magick::image_crop(t, geometry = "480x480-90+000")

y <- magick::image_read("plots/corr2points_m2point3/1.png")
y <- magick::image_crop(y, geometry = "480x480-90+000")

u <- magick::image_read("plots/corr2points_m2point4/1.png")
u <- magick::image_crop(u, geometry = "480x480-90+000")


j <- image_append(c(u,y,t,r), stack = F)


ss <- image_append(c(j,h,g,f,d,s,a), stack = TRUE)

dd <- image_append(c(a,s,d,f,g,h,j), stack = TRUE)
aa
```

### Correlation plots for scenario with normal area split by a barrier. Range fractions 0.01, 0.2, 0.3, 0.5, 0.7, 0.8, and 1 in rows from top to bottom.

```{r, echo=FALSE, out.width="100%", fig.cap= "Correlation plots for scenario with normal area split by a barrier. Range fractions 0.01, 0.2, 0.3, 0.5, 0.7, 0.8, and 1 in rows from top to bottom."}
dd
```

## Transparency

*Was* the ratio between the correlation of two adjacent points considering a barrier and the correlation of the same two points as if there were no barrier, $$
\frac{Corr_{b}}{Corr_{nb}} \sim \frac{Corr_{b}}{1} = c
$$ where $c$ corresponds to the transparency, which is a fixed ratio between 0 and 1. Transparency is introduced as a way to numerically characterize *permeability*.

```{r bathym05,  out.width="100%", echo=FALSE, fig.cap="Example of points used to calculate transparency, c."}
image_read("4copy/points.png")
```

## 

```{r, echo=FALSE,  out.width="100%", fig.cap="Posterior range using different aimed range fractions for two barriers separated by a canal."}
image_read("plots/pp_posterior.range.png")
```

## Transparency

### The Barrier model:

$$\frac{r_{n}}{h}  = r_{b}$$

$r_n$ is the range parameter for the normal area, and $r_b$ is the range parameter for the barrier, and it is a fixed fraction of $r_n$ so that $r_b=r_n/h$, where $h$ is a constant (e.g. $10$).

### The Transparent Barrier model

$$\frac{r_{n_{0.8}}}{h_{0.8}}  = r_{b_{0.8}}$$

## Simulation

### 1. The spatial geometry includes the normal area, and two barriers separated by a canal.

Range fractions 0.01, 0.2, 0.3, 0.4, 0.5, 0.7, and 0.8 in rows from top to bottom. Transparent Barrier model on the first two columns, Barrier model (up), and stationary model (bottom) on columns three and four.

```{r, echo=FALSE, fig.cap= "The spatial geometry includes the normal area, and two barriers separated by a canal."}
#r <- magick::image_read("plots/mesh/geom1.2.mesh.png")
#r <- magick::image_scale(r, "190")
a <- magick::image_read("plots/geom1.2_2/all.png")
image_scale(a, "1200x3164")
```

### 2. The spatial geometry includes the normal area, and one barrier separating this area in two

Range fractions 0.01, 0.2, 0.3, 0.4, 0.5, 0.7, and 0.8 in rows from top to bottom. Transparent Barrier model on the first two columns, Barrier model (up), and stationary model (bottom) on columns three and four.

```{r, echo=FALSE, fig.cap= "The spatial geometry includes the normal area, and one barrier separating this area in two"}
#r <- magick::image_read("plots/mesh/geom1.2.mesh.png")
#r <- magick::image_scale(r, "190")
a <- magick::image_read("plots/geom2/all.png")
image_scale(a, "1200x3164")

```

## Application

```{r}
#plot_dng1
leaflet() %>% 
  setView(lng = mean(Data_ISD$long), lat = mean(Data_ISD$lat), zoom = 8) %>%
  addProviderTiles(providers$OpenStreetMap, group = "Open Street Map") %>% 
  # Add additional basemap layers
  addProviderTiles(providers$Esri.WorldImagery, group = "ESRI World Imagery") %>% 
  addProviderTiles(providers$Esri.OceanBasemap, group = "ESRI Ocean Basemap") %>% 
  # Add a User-Interface (UI) control to switch layers
  addLayersControl(
    baseGroups = c("Open Street Map","ESRI World Imagery","ESRI Ocean Basemap"),
    options = layersControlOptions(collapsed = FALSE)) %>%
  addMarkers(lng = Data_ISD$long, lat = Data_ISD$lat, group = "Dugong",
             icon = 
               list(iconUrl = dng_icon,
                    iconSize = c(20,20)))

```

## with available map data

```{r, include = FALSE}
#Red sea geometry
map <- map("world", c("Saudi Arabia","Egypt", "Jordan","Eritrea", "Sudan", "Yemen"), 
           fill = TRUE,
           col = "transparent", plot = FALSE)
IDs <- sapply(strsplit(map$names, ":"), function(x) x[1])
map.sp <- map2SpatialPolygons(
  map, IDs = IDs,
  proj4string = CRS("+proj=longlat +datum=WGS84"))


pl.sel <- SpatialPolygons(list(Polygons(list(Polygon(
  cbind(c(43, 38, 30, 35), 
        c(17, 16, 30, 30)),
  FALSE)), '0')), proj4string = CRS(proj4string(map.sp)))

poly.RS <- gDifference(pl.sel, map.sp)
```

```{r}
leaflet() %>% 
  setView(lng = mean(Data_ISD$long), lat = mean(Data_ISD$lat), zoom = 8) %>%
  addProviderTiles(providers$OpenStreetMap, group = "Open Street Map") %>% 
  # Add additional basemap layers
  addProviderTiles(providers$Esri.WorldImagery, group = "ESRI World Imagery") %>% 
  addProviderTiles(providers$Esri.OceanBasemap, group = "ESRI Ocean Basemap") %>% 
  # Add a User-Interface (UI) control to switch layers
  addLayersControl(
    baseGroups = c("Open Street Map","ESRI World Imagery","ESRI Ocean Basemap"),
    options = layersControlOptions(collapsed = FALSE)) %>%
  addMarkers(lng = Data_ISD$long, lat = Data_ISD$lat, group = "Dugong",
             icon = 
               list(iconUrl = dng_icon,
                    iconSize = c(20,20))) %>% 
  addPolygons(data = poly.RS,
            group = "Red Sea",
            color = "blue",
            weight = 3)
```

## The Study Area

```{r, echo=FALSE, fig.cap="Bathymetry map for the the entire study area (top left); the normal area (top right); the islands (bottom left); and deep sea (bottom right)."}
q <- magick::image_read("plots/area1.png")
w <- magick::image_read("plots/area2.png")
a <- image_append(c(q,w), stack = F)
e <- magick::image_read("plots/area3.png")
r <- magick::image_read("plots/area4.png")
s <- image_append(c(e,r), stack = F)
image_append(c(a,s), stack = T)
```

## The Mesh

```{r, echo=FALSE, fig.cap= "Delaunay triangulation for the study area. The entire mesh is on the left, and the zoomed in area on the middle and right."}

q <- magick::image_read("plots/mesh.dng50.png")
w <- magick::image_read("plots/mesh.dng50zoom1.png")
e <- magick::image_read("plots/mesh.dng50zoom4.png")


image_append(c(q,w,e), stack = F)
```

## Visualizing the Different Models

```{r, echo=FALSE, fig.cap="Mesh with points used for evaluating correlation with different range fractions."}
a <- magick::image_read("plots/mesh.points.png")
image_scale(a, "1000")
```

```{r, echo=FALSE, fig.cap="Correlation plots for group of red points. Range fractions 0.01, 0.3, 0.7, and 1 in rows from top to bottom."}
###0 = fr1
q <- magick::image_read("plots/points_dng/point1/fr0.png")
q <- magick::image_crop(q, geometry = "480x390+00+50")

w <- magick::image_read("plots/points_dng/point2/fr0.png")
w <- magick::image_crop(w, geometry = "410x390+00+50")

e <- magick::image_read("plots/points_dng/point3/fr0.png")
e <- magick::image_crop(e, geometry = "410x390+00+50")

r <- magick::image_read("plots/points_dng/point4/fr0.png")
r <- magick::image_crop(r, geometry = "410x390+00+50")

t <- magick::image_read("plots/points_dng/point5/fr0.png")
t <- magick::image_crop(t, geometry = "410x390+00+50")

y <- magick::image_read("plots/points_dng/point6/fr0.png")
y <- magick::image_crop(y, geometry = "410x390+00+50")

u <- magick::image_read("plots/points_dng/point7/fr0.png")
u <- magick::image_crop(u, geometry = "480x390+00+50")

i <- magick::image_read("plots/points_dng/point8/fr0.png")
i <- magick::image_crop(i, geometry = "410x390+00+50")

o <- magick::image_read("plots/points_dng/point9/fr0.png")
o <- magick::image_crop(o, geometry = "480x390+00+50")

p <- magick::image_read("plots/points_dng/point10/fr0.png")
p <- magick::image_crop(p, geometry = "410x390+00+50")

a <- image_append(c(w,e,q), stack = F)
aa <- image_append(c(t,y,u), stack = F)
aaa <- image_append(c(i,p,o), stack = F)

###fr 0.8
q <- magick::image_read("plots/points_dng/point1/fr0.8.png")
q <- magick::image_crop(q, geometry = "480x390+00+50")

w <- magick::image_read("plots/points_dng/point2/fr0.8.png")
w <- magick::image_crop(w, geometry = "410x390+00+50")

e <- magick::image_read("plots/points_dng/point3/fr0.8.png")
e <- magick::image_crop(e, geometry = "410x390+00+50")

r <- magick::image_read("plots/points_dng/point4/fr0.8.png")
r <- magick::image_crop(r, geometry = "410x390+00+50")

t <- magick::image_read("plots/points_dng/point5/fr0.8.png")
t <- magick::image_crop(t, geometry = "410x390+00+50")

y <- magick::image_read("plots/points_dng/point6/fr0.8.png")
y <- magick::image_crop(y, geometry = "410x390+00+50")

u <- magick::image_read("plots/points_dng/point7/fr0.8.png")
u <- magick::image_crop(u, geometry = "480x390+00+50")

i <- magick::image_read("plots/points_dng/point8/fr0.8.png")
i <- magick::image_crop(i, geometry = "410x390+00+50")

o <- magick::image_read("plots/points_dng/point9/fr0.8.png")
o <- magick::image_crop(o, geometry = "480x390+00+50")

p <- magick::image_read("plots/points_dng/point10/fr0.8.png")
p <- magick::image_crop(p, geometry = "410x390+00+50")

s <- image_append(c(w,e,q), stack = F)
ss <- image_append(c(t,y,u), stack = F)
sss <- image_append(c(i,p,o), stack = F)


###fr 0.7
q <- magick::image_read("plots/points_dng/point1/fr0.7.png")
q <- magick::image_crop(q, geometry = "480x390+00+50")

w <- magick::image_read("plots/points_dng/point2/fr0.7.png")
w <- magick::image_crop(w, geometry = "410x390+00+50")

e <- magick::image_read("plots/points_dng/point3/fr0.7.png")
e <- magick::image_crop(e, geometry = "410x390+00+50")

r <- magick::image_read("plots/points_dng/point4/fr0.7.png")
r <- magick::image_crop(r, geometry = "410x390+00+50")

t <- magick::image_read("plots/points_dng/point5/fr0.7.png")
t <- magick::image_crop(t, geometry = "410x390+00+50")

y <- magick::image_read("plots/points_dng/point6/fr0.7.png")
y <- magick::image_crop(y, geometry = "410x390+00+50")

u <- magick::image_read("plots/points_dng/point7/fr0.7.png")
u <- magick::image_crop(u, geometry = "480x390+00+50")

i <- magick::image_read("plots/points_dng/point8/fr0.7.png")
i <- magick::image_crop(i, geometry = "410x390+00+50")

o <- magick::image_read("plots/points_dng/point9/fr0.7.png")
o <- magick::image_crop(o, geometry = "480x390+00+50")

p <- magick::image_read("plots/points_dng/point10/fr0.7.png")
p <- magick::image_crop(p, geometry = "410x390+00+50")

d <- image_append(c(w,e,q), stack = F)
dd <- image_append(c(t,y,u), stack = F)
ddd <- image_append(c(i,p,o), stack = F)


###fr 0.5
q <- magick::image_read("plots/points_dng/point1/fr0.5.png")
q <- magick::image_crop(q, geometry = "480x390+00+50")

w <- magick::image_read("plots/points_dng/point2/fr0.5.png")
w <- magick::image_crop(w, geometry = "410x390+00+50")

e <- magick::image_read("plots/points_dng/point3/fr0.5.png")
e <- magick::image_crop(e, geometry = "410x390+00+50")

r <- magick::image_read("plots/points_dng/point4/fr0.5.png")
r <- magick::image_crop(r, geometry = "410x390+00+50")

t <- magick::image_read("plots/points_dng/point5/fr0.5.png")
t <- magick::image_crop(t, geometry = "410x390+00+50")

y <- magick::image_read("plots/points_dng/point6/fr0.5.png")
y <- magick::image_crop(y, geometry = "410x390+00+50")

u <- magick::image_read("plots/points_dng/point7/fr0.5.png")
u <- magick::image_crop(u, geometry = "480x390+00+50")

i <- magick::image_read("plots/points_dng/point8/fr0.5.png")
i <- magick::image_crop(i, geometry = "410x390+00+50")

o <- magick::image_read("plots/points_dng/point9/fr0.5.png")
o <- magick::image_crop(o, geometry = "480x390+00+50")

p <- magick::image_read("plots/points_dng/point10/fr0.5.png")
p <- magick::image_crop(p, geometry = "410x390+00+50")

f <- image_append(c(w,e,q), stack = F)
ff <- image_append(c(t,y,u), stack = F)
fff <- image_append(c(i,p,o), stack = F)

###fr 0.3
q <- magick::image_read("plots/points_dng/point1/fr0.3.png")
q <- magick::image_crop(q, geometry = "480x390+00+50")

w <- magick::image_read("plots/points_dng/point2/fr0.3.png")
w <- magick::image_crop(w, geometry = "410x390+00+50")

e <- magick::image_read("plots/points_dng/point3/fr0.3.png")
e <- magick::image_crop(e, geometry = "410x390+00+50")

r <- magick::image_read("plots/points_dng/point4/fr0.3.png")
r <- magick::image_crop(r, geometry = "410x390+00+50")

t <- magick::image_read("plots/points_dng/point5/fr0.3.png")
t <- magick::image_crop(t, geometry = "410x390+00+50")

y <- magick::image_read("plots/points_dng/point6/fr0.3.png")
y <- magick::image_crop(y, geometry = "410x390+00+50")

u <- magick::image_read("plots/points_dng/point7/fr0.3.png")
u <- magick::image_crop(u, geometry = "480x390+00+50")

i <- magick::image_read("plots/points_dng/point8/fr0.3.png")
i <- magick::image_crop(i, geometry = "410x390+00+50")

o <- magick::image_read("plots/points_dng/point9/fr0.3.png")
o <- magick::image_crop(o, geometry = "480x390+00+50")

p <- magick::image_read("plots/points_dng/point10/fr0.3.png")
p <- magick::image_crop(p, geometry = "410x390+00+50")

g <- image_append(c(w,e,q), stack = F)
gg <- image_append(c(t,y,u), stack = F)
ggg <- image_append(c(i,p,o), stack = F)

###fr 0.2
q <- magick::image_read("plots/points_dng/point1/fr0.2.png")
q <- magick::image_crop(q, geometry = "480x390+00+50")

w <- magick::image_read("plots/points_dng/point2/fr0.2.png")
w <- magick::image_crop(w, geometry = "410x390+00+50")

e <- magick::image_read("plots/points_dng/point3/fr0.2.png")
e <- magick::image_crop(e, geometry = "410x390+00+50")

r <- magick::image_read("plots/points_dng/point4/fr0.2.png")
r <- magick::image_crop(r, geometry = "410x390+00+50")

t <- magick::image_read("plots/points_dng/point5/fr0.2.png")
t <- magick::image_crop(t, geometry = "410x390+00+50")

y <- magick::image_read("plots/points_dng/point6/fr0.2.png")
y <- magick::image_crop(y, geometry = "410x390+00+50")

u <- magick::image_read("plots/points_dng/point7/fr0.2.png")
u <- magick::image_crop(u, geometry = "480x390+00+50")

i <- magick::image_read("plots/points_dng/point8/fr0.2.png")
i <- magick::image_crop(i, geometry = "410x390+00+50")

o <- magick::image_read("plots/points_dng/point9/fr0.2.png")
o <- magick::image_crop(o, geometry = "480x390+00+50")

p <- magick::image_read("plots/points_dng/point10/fr0.2.png")
p <- magick::image_crop(p, geometry = "410x390+00+50")

h <- image_append(c(w,e,q), stack = F)
hh <- image_append(c(t,y,u), stack = F)
hhh <- image_append(c(i,p,o), stack = F)


###fr 0.01
q <- magick::image_read("plots/points_dng/point1/fr0.01.png")
#q <- magick::image_crop(q, geometry = "480x390+00+50")
q <- magick::image_crop(q, geometry = "480x390+00+50")

w <- magick::image_read("plots/points_dng/point2/fr0.01.png")
w <- magick::image_crop(w, geometry = "410x390+00+50")

e <- magick::image_read("plots/points_dng/point3/fr0.01.png")
e <- magick::image_crop(e, geometry = "410x390+00+50")

r <- magick::image_read("plots/points_dng/point4/fr0.01.png")
r <- magick::image_crop(r, geometry = "410x390+00+50")

t <- magick::image_read("plots/points_dng/point5/fr0.01.png")
t <- magick::image_crop(t, geometry = "410x390+00+50")

y <- magick::image_read("plots/points_dng/point6/fr0.01.png")
y <- magick::image_crop(y, geometry = "410x390+00+50")

u <- magick::image_read("plots/points_dng/point7/fr0.01.png")
u <- magick::image_crop(u, geometry = "480x390+00+50")

i <- magick::image_read("plots/points_dng/point8/fr0.01.png")
i <- magick::image_crop(i, geometry = "410x390+00+50")

o <- magick::image_read("plots/points_dng/point9/fr0.01.png")
o <- magick::image_crop(o, geometry = "480x390+00+50")

p <- magick::image_read("plots/points_dng/point10/fr0.01.png")
p <- magick::image_crop(p, geometry = "410x390+00+50")

j <- image_append(c(w,e,q), stack = F)
jj <- image_append(c(t,y,u), stack = F)
jjj <- image_append(c(i,p,o), stack = F)

#image_append(c(a,d,g,j), stack = T)
image_append(c(j,g,d,a), stack = T)
```

```{r, echo=FALSE, fig.cap="Correlation plots for group of green points. Range fractions 0.01, 0.3, 0.7, and 1 in rows from top to bottom."}
#image_append(c(aa,dd,gg,jj), stack = T)
image_append(c(jj,gg,dd,aa), stack = T)
```

```{r, echo=FALSE, fig.cap="Correlation plots for group of blue points. Range fractions 0.01, 0.3, 0.7, and 1 in rows from top to bottom."}
#image_append(c(aaa,ddd,ggg,jjj), stack = T)
image_append(c(jjj,ggg,ddd,aaa), stack = T)
```

## so, what's new? - Conclusions

-   Until now only *permanent physically impermeable* barriers have been considered.
-   This turns out to be quite restrictive since some barriers tend to have some degree of transparency instead of being permanently impermeable.
-   Then, there is the need of counting with a model that can include both barriers and their specific transparency level as some parameter in the model.
-   We introduce a new *transparency* concept.

# Projects 2 and 3.

```{r, echo=FALSE, fig.cap= "Drone survey and coverage in Sindalah area 2024."}
#r <- magick::image_read("plots/mesh/geom1.2.mesh.png")
#r <- magick::image_scale(r, "190")
magick::image_read("plots/map.data.drona.png")
```

```{r, echo=FALSE, fig.cap= "Dugong sightings (30) from drone focal surveys"}
magick::image_read("plots/map.data.drona2.png")
```

```{r, echo=FALSE, out.width="70%", fig.cap= "Aerial survey: transect footprint and data."}
magick::image_read("plots/map.data3.png")
magick::image_read("plots/map.data4.png")
magick::image_read("plots/map.data5.png")
magick::image_read("plots/map.data6.png")
```

```{r, echo=FALSE, out.width="70%", fig.cap= "Different survey transects Sindalah Islands."}
magick::image_read("plots/survey1.png")
magick::image_read("plots/survey2.png")
magick::image_read("plots/survey3.png")

```

```{r, echo=FALSE, out.width="70%", fig.cap= "Overall sightings of dugongs during drone and MMO Surveys showing the bathymetry of the project area and spatial overlap of sightings with the proposed vessel route. Zones of high risk (red line) and medium risk (orange line) where speed restrictions of <10 km/s should be implemented are shown, as well as recommended rerouting into deeper, open water areas"}
#r <- magick::image_read("plots/mesh/geom1.2.mesh.png")
#r <- magick::image_scale(r, "190")
magick::image_read("plots/map.data1.png")

```

```{r, echo=FALSE, out.width="70%", fig.cap= "Overall sightings of dolphins during drone and MMO Surveys showing the bathymetry of the project area and spatial overlap of sightings with the proposed vessel route. Zones of high risk (red line) and medium risk (orange line) where speed restrictions of <10 km/s should be implemented are shown, as well as recommended rerouting into deeper, open water areas"}
#r <- magick::image_read("plots/mesh/geom1.2.mesh.png")
#r <- magick::image_scale(r, "190")
magick::image_read("plots/survey4.png")
```

```{r, echo=FALSE, out.width="70%", fig.cap= "Overall sightings of marine megafauna during drone and MMO Surveys showing the bathymetry of the project area and spatial overlap of sightings with the proposed vessel route. Zones of high risk (red line) and medium risk (orange line) where speed restrictions of <10 km/s should be implemented are shown, as well as recommended rerouting into deeper, open water areas"}

magick::image_read("plots/map.data2.png")
```

## Timeline

```{r, echo=FALSE, fig.cap= "Ph.D. Proposal timeline, and new timeline."}
magick::image_read("plots/timeline/old.timeline.png")
magick::image_read("plots/timeline/timeline2.png")
```
