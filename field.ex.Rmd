

```{r}
smalldist = 1
width = c(3, 3)
range = 2
#width = c(4, 4)
#max.edge.length = 0.2
max.edge.length = 0.4
n = 150
set.inla.seed = 602

x.mid <- 10
xlim.big <- c(0,20)
xlim.small <- c(3,17)
ylim.big <- c(0,20)
ylim.small <- c(3,17)

poly1 <- local.square.polygon(xlim=c(xlim.big[1]-1, x.mid-smalldist/2), 
                          ylim=x.mid+width[1]*c(-.5, .5))

poly2 <- local.square.polygon(xlim=c(x.mid+smalldist/2, xlim.big[2]+1), 
                          ylim=x.mid+width[2]*c(-.5, .5))

poly.original <- SpatialPolygons(c(poly1@polygons, poly2@polygons))
  
loc1 <- matrix(c(xlim.big[1],ylim.big[1], 
                 xlim.big[2],ylim.big[1], 
                 xlim.big[2],ylim.big[2], 
                 xlim.big[1],ylim.big[2]), 4, 2, byrow = T)
  
seg <- inla.sp2segment(poly.original)
# - Transforms a SpatialPolygon to an "inla polygon"
mesh <- inla.mesh.2d(loc=loc1, 
                     interior = seg, 
                     max.e = max.edge.length, 
                     offset=1)

tl <- length(mesh$graph$tv[,1])
# - the number of triangles in the mesh
posTri <- matrix(0, tl, 2)

for (t in 1:tl){
  temp = mesh$loc[mesh$graph$tv[t, ], ]
  posTri[t,] = colMeans(temp)[c(1,2)] 
}

posTri <- SpatialPoints(posTri)
# - the positions of the triangle centers

bar.original <- over(poly.original, SpatialPoints(posTri), returnList=T)
# - checking which mesh triangles are inside the barrier area
bar.original <- unlist(bar.original)
poly.bar.orginal <- inla.barrier.polygon(mesh, barrier.triangles = bar.original)
# - the Barrier model's polygon
# - in most cases this should be the same as poly.original

# BARRIER 1
bar1 <- over(poly1, SpatialPoints(posTri), returnList=T)
# - checking which mesh triangles are inside the barrier area
bar1 <- unlist(bar1)
poly.bar1 <- inla.barrier.polygon(mesh, barrier.triangles = bar1)
# - the Barrier model's polygon
# - in most cases this should be the same as poly.original

# BARRIER 2
bar2 <- over(poly2, SpatialPoints(posTri), returnList=T)
# - checking which mesh triangles are inside the barrier area
bar2 <- unlist(bar2)
poly.bar2 <- inla.barrier.polygon(mesh, barrier.triangles = bar2)

mat <-  inla.barrier.fem.plus(mesh, list(bar1, bar2)) 
fem <- mat 
barrier.triangles <- list(bar1, bar2)

# PLOTS
poly1_h <- local.square.polygon_T(xlim=c(xlim.small[1], x.mid-smalldist/2), 
                          ylim=x.mid+width[1]*c(-.5, .5))

poly2_h <- local.square.polygon_T(xlim=c(x.mid+smalldist/2, xlim.small[2]), 
                          ylim=x.mid+width[2]*c(-.5, .5))

loc2 <- matrix(c(3,3, 17,3, 17,17, 3,17), 4, 2, byrow = T)

locp2 <- Polygon(loc2, hole = FALSE)
    
poly.water <- SpatialPolygons(list(Polygons(list(locp2, poly1_h, poly2_h), '0')))
poly.water_sf <- st_as_sf(poly.water)
    
set.seed(set.inla.seed)
loc.data <- spsample(x = poly.water, n = n, type = "random")
loc.data_sf <- st_as_sf(loc.data)
loc.data <- loc.data@coords

poly.rect <- SpatialPolygons(list(Polygons(list(poly1_h, poly2_h), '0')))
poly.rect_sf <- st_as_sf(poly.rect)
poly.sq <- SpatialPolygons(list(Polygons(list(locp2), '0')))
poly.sq_sf <- st_as_sf(poly.sq)

sq_bbox <- st_bbox(poly.sq_sf) %>% st_as_sfc()
poly1_bbox <- st_bbox(poly1) %>% st_as_sfc()
poly2_bbox <- st_bbox(poly2) %>% st_as_sfc()

gg.mesh <- ggplot() + 
  inlabru::gg(mesh) +
  geom_sf(data =poly.rect_sf,
          col='black', alpha=0) + #alpha color inside rect
  geom_sf(data=poly1_bbox, fill=NA, color="red", linewidth = 0.7, linetype = "dashed") +
  geom_sf(data=poly2_bbox, fill=NA, color="red", linewidth = 0.7, linetype = "dashed") +
  geom_sf(data=sq_bbox, fill=NA, color="black", linewidth = 0.7)

gg.mesh.water <- ggplot() +
  inlabru::gg(mesh) +
  geom_sf(data =poly.rect_sf,
          col='black', alpha=1) + #alpha color inside rect
  geom_sf(data=sq_bbox, fill=NA, color="black", linewidth = 0.7) +
  geom_sf(data=poly1_bbox, color="black", linewidth = 0.7) +
  geom_sf(data=poly2_bbox, color="black", linewidth = 0.7) +
  ylim(c(3, 17)) +
  xlim(c(3, 17))

gg.mesh +
  geom_sf(data =loc.data_sf,
          col='black',size=1.7,alpha=0.5)

gg.mesh.water +
  geom_sf(data =loc.data_sf,
          col='black',size=1.7,alpha=0.5)

gg2b.1 <- gg.mesh +
  ggtitle("Mesh")

gg2b.2 <- gg.mesh.water +
  ggtitle("Barrier layout")

gg2b.3 <- gg.mesh.water +
  geom_sf(data =loc.data_sf,
          col='black',size=1.7,alpha=0.5) +
  ggtitle("Simulated data")

fpp <- file.path("2b_mesh.png")
png(fpp)
gridExtra::grid.arrange(gg2b.1, gg2b.2, gg2b.3, ncol=3, nrow=2, 
               top="Two barriers scenario")
dev.off()

zlim = c(0.1, 1)
xlim = poly.water@bbox[1, ] 
ylim = poly.water@bbox[2, ]
proj = inla.mesh.projector(mesh, xlim = xlim, 
                           ylim = ylim, dims=c(300, 300))


local.plot.field = function(field, pal = plasma(50), ...){
  xlim = c(3, 17); ylim = xlim;
  proj = inla.mesh.projector(mesh, xlim = xlim, 
                             ylim = ylim, dims=c(300, 300))
  # - Can project from the mesh onto a 300x300 grid 
  #   for plots
  field.proj = inla.mesh.project(proj, field)
  # - Do the projection
  image.plot(list(x = proj$x, y=proj$y, z = field.proj), 
             xlim = xlim, ylim = ylim, col = pal, ...)  
  # - Use image.plot to get nice colors and legend
}
# - This is the appropriate length of the field variable


model.tbm <- function(mesh = mesh, 
                      fem = fem, 
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      range.fraction = range.fraction,
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1),
                      return.list = TRUE) {
  
  # field = TRUE has to be true to start
  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction)
  # range fraction has to have the same length as barrier triangles
  Q <- inla.rgeneric.q(barrier.model, "Q", theta = c(log(1), log(range))) #log(1) or log(prior.sigma[1])
  u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))
  u <- u[ ,1]
    
  A.data <- inla.spde.make.A(mesh, loc.data)
  #Q from mydiff.r function
    
  u.data <- A.data %*% u
  
  df <- data.frame(loc.data)
  names(df) <- c('locx', 'locy')
  df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))
  
    
  stk <- inla.stack(data=list(y=df$y), 
                    A=list(A.data, 1),
                    effects=list(s=1:mesh$n, 
                                 intercept=rep(1, nrow(df))), 
                    remove.unused = FALSE, 
                    tag='est')

    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
    
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  if (return.list == TRUE) {
    
    list.field <- list(barrier.model = barrier.model, Q = Q, sample = u)
    pos.bm <- list(df = df, res = res.barrier)
    pos.st <- list(res = res.stationary)
    
    return(list(list.field = list.field, pos.bm = pos.bm, pos.st = pos.st))
  }
                     
}

plot.model.tbm.flex2 <- 
  function(trans, 
           nfrac,
           max.frac = 1,
           min.r = min.r,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1,
           set.inla.seed = set.inla.seed,
                              col=alpha('grey', 0),
                              plot.points = points(loc.data, 
                                              pch = 16, 
                                              cex = 0.8, 
                                              col=alpha('gray', 0)),
                              gif.path = "gif/",
                              pal.field = turbo(50),
                              pal.pos.mean = turbo(50),
                              pal.pos.sd = turbo(50),
                              pal.pos.q25 = turbo(50),
                              pal.pos.q50 = turbo(50),
                              pal.pos.q975 = turbo(50),
                              
                              pal.pos.mean.st = turbo(50),
                              pal.pos.sd.st = turbo(50),
                              pal.pos.q25.st = turbo(50),
                              pal.pos.q50.st = turbo(50),
                              pal.pos.q975.st = turbo(50),
                              ...
    ){
  dir_out_f <- file.path(tempdir(), "truefield_gif")
  dir.create(dir_out_f, recursive = TRUE)
  
  # barrier model
  dir_out_pm <- file.path(tempdir(), "posmean_gif")
  dir.create(dir_out_pm, recursive = TRUE)
  
  dir_out_sd <- file.path(tempdir(), "possd_gif")
  dir.create(dir_out_sd, recursive = TRUE)
  
  dir_out_q25 <- file.path(tempdir(), "posq25_gif")
  dir.create(dir_out_q25, recursive = TRUE)
  
  dir_out_q5 <- file.path(tempdir(), "posq5_gif")
  dir.create(dir_out_q5, recursive = TRUE)
  
  dir_out_q975 <- file.path(tempdir(), "posq975_gif")
  dir.create(dir_out_q975, recursive = TRUE)
  
  # stationary model
  dir_out_s <- file.path(tempdir(), "statmodel_gif")
  dir.create(dir_out_s, recursive = TRUE)
  
  dir_out_st.sd <- file.path(tempdir(), "st.sd_gif")
  dir.create(dir_out_st.sd, recursive = TRUE)
  
  dir_out_st.q25 <- file.path(tempdir(), "pos.st.q25_gif")
  dir.create(dir_out_st.q25, recursive = TRUE)
  
  dir_out_st.q5 <- file.path(tempdir(), "pos.st.q5_gif")
  dir.create(dir_out_st.q5, recursive = TRUE)
  
  dir_out_st.q975 <- file.path(tempdir(), "pos.st.q975_gif")
  dir.create(dir_out_st.q975, recursive = TRUE)
  
  fr <- (seq(from = min.r, to = max.frac, length = nfrac)/max.frac)
  if (fr[1] < min.r) fr[1] <- min.r

  for (r in 1:length(trans)) {
    
    f <- fr[r]
    range.fraction <- c(f, f)
    
    # SPATIAL FIELD, u
    fpp <- file.path(dir_out_f, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$list.field$sample, 
                     main="Spatial (simulated) true field",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.field)
    plot(poly.bar.orginal, add=T, col = col)
    plot.points
    dev.off()
    
    # POSTERIOR MEAN
    fpp <- file.path(dir_out_pm, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s$mean, 
                     main="Spatial estimate for Barrier model",
                     sub = paste("range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD
    fpp <- file.path(dir_out_sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s$sd, 
                     main="Spatial sd estimate for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES
    # 0.025
    fpp <- file.path(dir_out_q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,4], 
                     main="Spatial 0.025 quantile estimate for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5
    fpp <- file.path(dir_out_q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile estimate for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975
    fpp <- file.path(dir_out_q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile estimate for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # SPATIAL ESTIMATE WITH STATIONARY MODEL
    fpp <- file.path(dir_out_s, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s$mean,
                     main="Spatial estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean.st) 
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD st
    fpp <- file.path(dir_out_st.sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s$sd, 
                     main="Spatial sd estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES st
    # 0.025 st
    fpp <- file.path(dir_out_st.q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,4], 
                     main="Spatial 0.025 estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5 st
    fpp <- file.path(dir_out_st.q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975 st
    fpp <- file.path(dir_out_st.q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
  }
  
    ## bm
    # SPATIAL FIELD, u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_f, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "true.field.gif"))
    
    # POSTERIOR MEAN
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_pm, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.mean.gif"))
    
    #POS SD
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.gif"))
    
    #POS QUANTILES
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.gif"))
    
    ## st
    # u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_s, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "stat.rnadom.mean.gif"))
    
    # st sd
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.st.gif"))
    
    #POS QUANTILES st
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.st.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.st.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.st.gif"))
    
    unlink(dir_out_f, recursive = T)
    unlink(dir_out_pm, recursive = T)
    unlink(dir_out_sd, recursive = T)
    unlink(dir_out_q25, recursive = T)
    unlink(dir_out_q5, recursive = T)
    unlink(dir_out_q975, recursive = T)
    unlink(dir_out_s, recursive = T)
    unlink(dir_out_st.sd, recursive = T)
    unlink(dir_out_st.q25, recursive = T)
    unlink(dir_out_st.q5, recursive = T)
    unlink(dir_out_st.q975, recursive = T)
}

nfrac = 5
max.frac = 10
min.r = 0.01
fr <- (seq(from = min.r, 
          to = max.frac, 
          length = nfrac)/max.frac) #*range
tbm.frac <- list()

if (fr[1] < min.r) fr[1] <- min.r
for (r in 1:nfrac) { #
  f <- fr[r]
  range.fraction <- c(f, f)
  tbm.frac[[r]] <- model.tbm(mesh = mesh, fem = fem, 
              barrier.triangles = barrier.triangles,
              prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),  
              range.fraction = range.fraction,
              range = range,
              set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
              loc.data = loc.data, 
              sigma.u = 1, sigma.epsilon = 0.2,
              poly.original = poly.bar.orginal,
              prior.range.st = c(1, 0.5),
              prior.sigma.st = c(1, 0.1),
              return.list = TRUE
    )
}

trans <- tbm.frac
#w3r4seed602.n150 <- tbm.frac

plot.model.tbm.flex2(trans, 
           nfrac,
           max.frac = max.frac,
           min.r = 0.01,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1)
```

```{r}
trans <- w3r4seed602.n150 
trans[[r]]$pos.st$res$summary.random$s[,5]

# PLOTS
# set 1
par(mfrow = c(1, 3), mar = c(3, 3, 1, 0.3), mgp = c(2, 1, 0)) 


fr <- (seq(from = min.r, to = max.frac, length = nfrac)/max.frac)
if (fr[1] < min.r) fr[1] <- min.r

for (r in 1:length(trans)) {
  f <- fr[r]
  range.fraction <- c(f, f)
  fpp <- file.path(paste0(f, ".png"))
  png(fpp)
  par(mfrow = c(2, 1))
  tmp = inla.tmarginal(function(x) exp(x), trans[[r]]$pos.bm$res$marginals.hyperpar[[3]]) 
  plot(tmp, type = "l", xlab = "r", ylab = "Density", xlim = c(2,12))
      xvals = seq(0, 10, length.out=1000)
      
  abline(v=range, col="blue")
  
  tmp = inla.tmarginal(function(x) (x), trans[[r]]$pos.st$res$marginals.hyperpar[[2]]) 
  plot(tmp, type = "l", xlab = "r", ylab = "Density", xlim = c(2,12))
      xvals = seq(0, 10, length.out=1000)
  abline(v=range, col="blue")
  dev.off()
}





```

######
#####
######
after meeting today

```{r}
 # field = TRUE has to be true to start
range.fraction = c(0.5, 0.5)
barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction)
  # range fraction has to have the same length as barrier triangles
  Q <- inla.rgeneric.q(barrier.model, "Q", theta = c(log(1), log(range))) #log(1) or log(prior.sigma[1])
  u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))
  u <- u[ ,1]
    
  A.data <- inla.spde.make.A(mesh, loc.data)
  #Q from mydiff.r function
    
  u.data <- A.data %*% u
  
  df <- data.frame(loc.data)
  names(df) <- c('locx', 'locy')
  df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))
  
    
  stk <- inla.stack(data=list(y=df$y), 
                    A=list(A.data, 1),
                    effects=list(s=1:mesh$n, 
                                 intercept=rep(1, nrow(df))), 
                    remove.unused = FALSE, 
                    tag='est')

model.tbm2 <- function(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      range.fraction = range.fraction,
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1),
                      return.list = TRUE) {
  
    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
    
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  if (return.list == TRUE) {
    
    list.field <- list(barrier.model = barrier.model)
    pos.bm <- list(df = df, res = res.barrier)
    pos.st <- list(res = res.stationary)
    
    return(list(list.field = list.field, pos.bm = pos.bm, pos.st = pos.st))
  }
                     
}

trans.tbm <- model.tbm2(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      range.fraction = range.fraction,
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1),
                      return.list = TRUE)

trans.bm <- model.tbm2(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      range.fraction = c(0.1, 0.1),
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1),
                      return.list = TRUE)
trans <- list()
trans[[1]] <- trans.bm
plot.bm(trans, 
           nfrac = 1,
           max.frac = 1,
           min.r = 0.01,
           poly.bar.orginal = poly.bar.orginal,
           range = c(0.1, 0.1),
           fps = 1)

nfrac = 1
max.frac = 0.1
min.r = 0.01
fr <- (seq(from = min.r, 
          to = max.frac, 
          length = nfrac)/max.frac) #*range
tbm.frac <- list()

if (fr[1] < min.r) fr[1] <- min.r

```


```{r}
nfrac = 5
max.frac = 10
min.r = 0.01
fr <- (seq(from = min.r, 
          to = max.frac, 
          length = nfrac)/max.frac) #*range
tbm.frac <- list()

if (fr[1] < min.r) fr[1] <- min.r
for (r in 1:nfrac) { #
  f <- fr[r]
  range.fraction <- c(f, f)
  tbm.frac[[r]] <- model.tbm(mesh = mesh, fem = fem, 
              barrier.triangles = barrier.triangles,
              prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),  
              range.fraction = range.fraction,
              range = range,
              set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
              loc.data = loc.data, 
              sigma.u = 1, sigma.epsilon = 0.2,
              poly.original = poly.bar.orginal,
              prior.range.st = c(1, 0.5),
              prior.sigma.st = c(1, 0.1),
              return.list = TRUE
    )
}

trans <- tbm.frac

plot.model.tbm.flex(trans, 
           nfrac,
           max.frac = max.frac,
           min.r = 0.01,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1)
```



########
#######
########
Same but i want to use the same loc.data points for all cases instead of simulating new ones for each range barrier

I'll do it kinda like i did it for the poisson example meaning stack and Q will be outside and I'll just do the estimation with the different models to compare them
so the comparison should be stationary, barrier, transparent barrier model.

To do after meeting today

```{r}
range.fraction <- c(.5, .5)
sigma.u = 1
sigma.epsilon = 0.2
tbm.true <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction)
# range fraction has to have the same length as barrier triangles
Q <- inla.rgeneric.q(tbm.true, "Q", theta = c(log(1), log(range))) #log(1) or log(prior.sigma[1])
u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))
u <- u[ ,1]
A.data <- inla.spde.make.A(mesh, loc.data)
#Q from mydiff.r function
u.data <- A.data %*% u
df <- data.frame(loc.data)
names(df) <- c('locx', 'locy')
df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))
  
stk <- inla.stack(data=list(y=df$y), 
                    A=list(A.data, 1),
                    effects=list(s=1:mesh$n, 
                                 intercept=rep(1, nrow(df))), 
                    remove.unused = FALSE, 
                    tag='est')
  
tbm.compare <- function(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      nfrac = nfrac,
                      range.fraction = range.fraction, #it has to be a list here, first one is the true one
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1)) {
  
  ###STATIONARY MODEL  
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  ###(CLASSIC) BM
  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction = c(0.1, 0.1))
  
    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
  
  ###TRANSPARENT BARRIER MODEL
  # in case I want to compare tbm's with different range.fractions, the correct result is the one I'm using to sample Q outside this function
  
  tbm <- list()
  for (f in 1:length(range.fraction)) {
    
    tbm[[f]] <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction = range.fraction[[f]])
  
    formula <- y ~ 0 + intercept + f(s, model = tbm)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    res.tbm[[f]] <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6))) 
    }
  
    
    models <- list(st = model.stat, bm = barrier.model, tbm = tbm)
    res <- list(res.st = res.stationary, res.bm = res.barrier, res.tbm = res.tbm)
    
    return(list(models = models, res = res))
}

range.fraction.list <- list()
range.fraction.list[[1]] <- range.fraction
tbm <- tbm.compare(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      nfrac = nfrac,
                      range.fraction = range.fraction.list, #it has to be a list here, first one is the true one
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1))
```
```{r}
tbm.compare <- function(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      nfrac = nfrac,
                      range.fraction = range.fraction, #it has to be a list here, first one is the true one
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1)) {
  
  ###STATIONARY MODEL  
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  ###(CLASSIC) BM
  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction = c(0.1, 0.1))
  
    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
  
  ###TRANSPARENT BARRIER MODEL
  # in case I want to compare tbm's with different range.fractions, the correct result is the one I'm using to sample Q outside this function
  
  tbm <- list()
  res.tbm <- list()
  for (f in 1:length(range.fraction.list)) {
    
    tbm[[1]] <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction = range.fraction.list[[1]])
  
    formula <- y ~ 0 + intercept + f(s, model = tbm)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    res.tbm[[1]] <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6))) 
    }
  
    
    models <- list(st = model.stat, bm = barrier.model, tbm = tbm)
    res <- list(res.st = res.stationary, res.bm = res.barrier, res.tbm = res.tbm)
    
    return(list(models = models, res = res))
```


```{r}
plot.compare <- 
  function(trans, 
           u,
           nfrac,
           max.frac = 1,
           min.r = min.r,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1,
           set.inla.seed = set.inla.seed,
                              col=alpha('grey', 0),
                              plot.points = points(loc.data, 
                                              pch = 16, 
                                              cex = 0.8, 
                                              col=alpha('gray', 0)),
                              gif.path = "gif/",
                              pal.field = turbo(50),
                              pal.pos.mean = turbo(50),
                              pal.pos.sd = turbo(50),
                              pal.pos.q25 = turbo(50),
                              pal.pos.q50 = turbo(50),
                              pal.pos.q975 = turbo(50),
                              
                              pal.pos.mean.st = turbo(50),
                              pal.pos.sd.st = turbo(50),
                              pal.pos.q25.st = turbo(50),
                              pal.pos.q50.st = turbo(50),
                              pal.pos.q975.st = turbo(50),
                              ...
    ){
  dir_out_f <- file.path(tempdir(), "truefield_gif")
  dir.create(dir_out_f, recursive = TRUE)
  
  # barrier model
  dir_out_pm <- file.path(tempdir(), "posmean_gif")
  dir.create(dir_out_pm, recursive = TRUE)
  
  dir_out_sd <- file.path(tempdir(), "possd_gif")
  dir.create(dir_out_sd, recursive = TRUE)
  
  dir_out_q25 <- file.path(tempdir(), "posq25_gif")
  dir.create(dir_out_q25, recursive = TRUE)
  
  dir_out_q5 <- file.path(tempdir(), "posq5_gif")
  dir.create(dir_out_q5, recursive = TRUE)
  
  dir_out_q975 <- file.path(tempdir(), "posq975_gif")
  dir.create(dir_out_q975, recursive = TRUE)
  
  # stationary model
  dir_out_s <- file.path(tempdir(), "statmodel_gif")
  dir.create(dir_out_s, recursive = TRUE)
  
  dir_out_st.sd <- file.path(tempdir(), "st.sd_gif")
  dir.create(dir_out_st.sd, recursive = TRUE)
  
  dir_out_st.q25 <- file.path(tempdir(), "pos.st.q25_gif")
  dir.create(dir_out_st.q25, recursive = TRUE)
  
  dir_out_st.q5 <- file.path(tempdir(), "pos.st.q5_gif")
  dir.create(dir_out_st.q5, recursive = TRUE)
  
  dir_out_st.q975 <- file.path(tempdir(), "pos.st.q975_gif")
  dir.create(dir_out_st.q975, recursive = TRUE)
    
    # SPATIAL FIELD, u
  
    fpp <- file.path(dir_out_f, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(u, 
                     main="True (simulated) Spatial Field",
                     sub = paste("range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.field)
    plot(poly.bar.orginal, add=T, col = col)
    plot.points
    dev.off()
    
    # POSTERIOR MEAN
    fpp <- file.path(dir_out_pm, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s$mean, 
                     main="Spatial mean posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD
    fpp <- file.path(dir_out_sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s$sd, 
                     main="Spatial sd posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES
    # 0.025
    fpp <- file.path(dir_out_q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,4], 
                     main="Spatial 0.025 quantile posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5
    fpp <- file.path(dir_out_q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975
    fpp <- file.path(dir_out_q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # SPATIAL ESTIMATE WITH STATIONARY MODEL
    fpp <- file.path(dir_out_s, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s$mean,
                     main="Spatial estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean.st) 
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD st
    fpp <- file.path(dir_out_st.sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s$sd, 
                     main="Spatial sd posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES st
    # 0.025 st
    fpp <- file.path(dir_out_st.q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,4], 
                     main="Spatial 0.025 quantile posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5 st
    fpp <- file.path(dir_out_st.q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975 st
    fpp <- file.path(dir_out_st.q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
  }
  
    ## bm
    # SPATIAL FIELD, u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_f, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "true.field.gif"))
    
    # POSTERIOR MEAN
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_pm, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.mean.gif"))
    
    #POS SD
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.gif"))
    
    #POS QUANTILES
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.gif"))
    
    ## st
    # u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_s, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "stat.rnadom.mean.gif"))
    
    # st sd
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.st.gif"))
    
    #POS QUANTILES st
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.st.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.st.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.st.gif"))
    
    unlink(dir_out_f, recursive = T)
    unlink(dir_out_pm, recursive = T)
    unlink(dir_out_sd, recursive = T)
    unlink(dir_out_q25, recursive = T)
    unlink(dir_out_q5, recursive = T)
    unlink(dir_out_q975, recursive = T)
    unlink(dir_out_s, recursive = T)
    unlink(dir_out_st.sd, recursive = T)
    unlink(dir_out_st.q25, recursive = T)
    unlink(dir_out_st.q5, recursive = T)
    unlink(dir_out_st.q975, recursive = T)
  }
```


```{r}
nfrac = 5
max.frac = 10
min.r = 0.01
fr <- (seq(from = min.r, 
          to = max.frac, 
          length = nfrac)/max.frac) #*range
tbm.frac <- list()

if (fr[1] < min.r) fr[1] <- min.r
for (r in 1:nfrac) { #
  f <- fr[r]
  range.fraction <- c(f, f)
  tbm.frac[[r]] <- model.tbm(mesh = mesh, fem = fem, 
              barrier.triangles = barrier.triangles,
              prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),  
              range.fraction = range.fraction,
              range = range,
              set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
              loc.data = loc.data, 
              sigma.u = 1, sigma.epsilon = 0.2,
              poly.original = poly.bar.orginal,
              prior.range.st = c(1, 0.5),
              prior.sigma.st = c(1, 0.1),
              return.list = TRUE
    )
}

trans <- tbm.frac

plot.model.tbm.flex(trans, 
           nfrac,
           max.frac = max.frac,
           min.r = 0.01,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1)
```


```{r}
bm_hp <- list()
st_hp <- list()
frac = 5

bm_hp <- rbind(
data.frame(exp(trans[[1]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])),
data.frame(exp(trans[[2]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])),
data.frame(exp(trans[[3]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])),
data.frame(exp(trans[[4]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])),
data.frame(exp(trans[[5]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])))
st_hp <- rbind(
data.frame((trans[[1]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])),
data.frame((trans[[2]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])),
data.frame((trans[[3]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])),
data.frame((trans[[4]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])),
data.frame((trans[[5]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])))

colnames(bm_hp)[2:3] <- c("0.025quant", "0.975quant")
rownames(bm_hp) <- c("r1", "r2", "r3", "r4","r5")

colnames(st_hp)[2:3] <- c("0.025quant", "0.975quant")
rownames(st_hp) <- c("r1", "r2", "r3", "r4","r5")
#write.csv(rbind(bm_hp,st_hp), "4proposal\\trans2.5.csv")
#bm_hp.25 = bm_hp 
#st_hp.25 = st_hp
```

```{r}
ggplot() + 
  inlabru::gg(mesh.seg) +
  geom_sf(data =poly.rect_sf,
          col='black', alpha=0) + #alpha color inside rect
  geom_sf(data=poly1_bbox, fill=NA, color="red", linewidth = 0.7, linetype = "dashed") +
  geom_sf(data=poly2_bbox, fill=NA, color="red", linewidth = 0.7, linetype = "dashed") +
  geom_sf(data=sq_bbox, fill=NA, color="black", linewidth = 0.7)

ggplot() + 
  inlabru::gg(mesh.seg) +
  geom_sf(data =poly.rect_sf,
          col='black', alpha=1) + #alpha color inside rect
  geom_sf(data=sq_bbox, fill=NA, color="black", linewidth = 0.7) +
  geom_sf(data=poly1_bbox, color="black", linewidth = 0.7) +
  geom_sf(data=poly2_bbox, color="black", linewidth = 0.7) +
  ylim(c(3, 17)) +
  xlim(c(3, 17)) 
```


# MESH wiht almost triangular barriers
mesh.seg_h <- inla.mesh.2d(boundary = poly.water, #? has to have holes=F
                           interior = seg, 
                           max.e = max.edge.length, 
                           offset=1)
ggplot() + 
  inlabru::gg(mesh.seg_h)



########
```{r gifs2b, echo=FALSE, fig.cap="Two barriers scenario: row one shows the true simulated spatial field; and row two and three the spatial estimate for the transparent barrier model and the stationary model"}

#"480x480+000-300")
tf0.4 <- image_read("plots.now/w3r4seed602.flex2.n150/true.field.gif")
img_r1 <- image_append(image_scale(tf0.4, "x400"))
r1 <- image_crop(img_r1, "2000x400+000+00")

ps_bm0.4 <- image_read("plots.now/w3r4seed602.flex2.n150/pos.mean.gif")
ps_st0.4 <- image_read("plots.now/w3r4seed602.flex2.n150/stat.rnadom.mean.gif")


r2 <- image_append(image_scale(ps_bm0.4, "x400"))
r2 <- image_crop(r2, "2000x400+000+00")

r3 <- image_append(image_scale(ps_st0.4, "x400"))
r3 <- image_crop(r3, "2000x400+000+00")


img <- c(r1,r2,r3)

image_append(img, stack = TRUE)
```

```{r gifs1b, echo=FALSE, fig.cap="One barrier scenario: row one shows the true simulated spatial field; and row two and three the spatial estimate for the transparent barrier model and the stationary model"}

#"480x480+000-300")
tf0.4 <- image_read("plots.now/w3r4seed602.flex2.n150_1b/true.field.gif")
img_r1 <- image_append(image_scale(tf0.4, "x400"))
r1 <- image_crop(img_r1, "2000x400+000+00")

ps_bm0.4 <- image_read("plots.now/w3r4seed602.flex2.n150_1b/pos.mean.gif")
ps_st0.4 <- image_read("plots.now/w3r4seed602.flex2.n150_1b/stat.rnadom.mean.gif")


r2 <- image_append(image_scale(ps_bm0.4, "x400"))
r2 <- image_crop(r2, "2000x400+000+00")

r3 <- image_append(image_scale(ps_st0.4, "x400"))
r3 <- image_crop(r3, "2000x400+000+00")


img <- c(r1,r2,r3)
image_append(img, stack = TRUE)
```

```{r}
#choose a ref point

location <- matrix(c(c(6), 
                     c(12)), ncol = 2)
location.sp <- SpatialPoints(location)


## barrier area pair of points
y.up <- location[1,2]
y.low <- location[1,1]
A.tmp <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(y.low,y.up), nrow=1, ncol=2))

id.node = which.max(A.tmp[1, ])
id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])

gg.mesh.water +
  geom_sf(data = st_as_sf(SpatialPoints(
    matrix(c(5.890625, 11.871812), ncol = 2))), col = "red")
```


```{r}
prior.range = c(1,  0.5)
prior.sigma = c(1, 0.01)
range.fraction <- c(0.25, 0.25)

corr.covfx <- function(range.fraction = range.fraction,
                       id.node = id.node,
                       prior.range = prior.range) {
  
  barrier.model <- inla.barrier.pcmatern.plus(
    mesh = mesh,
    fem = fem,
    barrier.triangles = barrier.triangles,
    prior.range = prior.range,
    prior.sigma = prior.sigma,
    range.fraction = range.fraction)
  
  Q <- inla.rgeneric.q(
    barrier.model, 
    "Q",
    theta = c(log(prior.sigma[1]), 
              log(prior.range[1])))

  sd <- sqrt(diag(inla.qinv(Q)))
  Inode <- rep(0, dim(Q)[1])
  Inode[id.node] <- 1

  covar.column <- solve(Q, Inode)
  corr = drop(matrix(covar.column))/(sd*sd[id.node])
  cov = drop(matrix(covar.column))

  return.list <- list(corr = corr, cov = cov)
  return(return.list)
}

df4plot <- function(field, 
                    dims = 300,
                    id.coord = id.coord) {
  
  proj = inla.mesh.projector(mesh, xlim = xlim, 
                             ylim = ylim, dims=c(dims, dims))
  
  # Do the projection 
  field.proj = inla.mesh.project(proj, field)
  
  hilo <- list()
  for(i in 1:dims) {
    hilo[[i]] <- field.proj[,i]
  }
  
  hilo <- unlist(hilo)

  df <- cbind(proj$lattice$loc,
    sqrt((proj$lattice$loc[,1] - id.coord[[1]])^2 + (proj$lattice$loc[,2] - id.coord[[2]])^2),
    hilo)

  colnames(df) <- c("x", "y", "dist", "field")
  df <- as.data.frame(df)
  return(df)
}

corr.plots <- function(field, df,
                       xlim, ylim, zlim,
                       points = NULL,
                       filter = 0.2,
                       show.plot.field = TRUE,
                       plot.order = 1){
  
  if(show.plot.field == TRUE) {
    local.plot.field(field, mesh, 
                     xlim = xlim, 
                     ylim = ylim,
                     zlim = zlim)
    points(points)
  }
  
  df <- df %>% dplyr::filter(field > filter)
  
  if(plot.order == 1){
  gg <- ggplot(data = df, aes(x = field, y = dist)) +
    geom_line()
  }
  
  if(plot.order == 2){ 
  gg <- ggplot(data = df, aes(x = dist, y = field)) +
    geom_line()
  }
  
  return.list <- list(df = summary(df), gg = gg)
  return(return.list)
}
```


```{r}
b1 <- corr.covfx(range.fraction = c(.5,.5),
                id.node = id.node,
                prior.range = prior.range)
field <- b1$corr
b1.df <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

b1.plots <- corr.plots(field, df = b1.df,
                      xlim = c(3,17), 
                      ylim, zlim,
                      points = NULL,
                      filter = 0.2,
                      show.plot.field = F)
corr.plots(field, df = b1.df, xlim, ylim, zlim, filter = -1)

b1 <- corr.covfx(range.fraction = c(1,1),
                id.node = id.node,
                prior.range = prior.range)
field <- b1$corr
b1.df <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

b1.plots <- corr.plots(field, df = b1.df,
                      xlim = c(3,17), 
                      ylim, zlim,
                      points = NULL,
                      filter = 0.2,
                      show.plot.field = F)
corr.plots(field, df = b1.df, xlim, ylim, zlim, filter = -1)

b1 <- corr.covfx(range.fraction = c(.1,.1),
                id.node = id.node,
                prior.range = prior.range)
field <- b1$corr
b1.df <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

b1.plots <- corr.plots(field, df = b1.df,
                      xlim = c(3,17), 
                      ylim, zlim,
                      points = NULL,
                      filter = 0.2,
                      show.plot.field = F)
corr.plots(field, df = b1.df, xlim, ylim, zlim, filter = -1)

```


```{r}
# dims can be change for different resolution
local.plot.field = function(field, mesh, xlim, ylim, ...){
  # Error when using the wrong mesh
  stopifnot(length(field) == mesh$n)
  
  # Choose plotting region to be the same as the study area polygon
  if (missing(xlim)) xlim = poly.water@bbox[1, ] 
  if (missing(ylim)) ylim = poly.water@bbox[2, ]
  
  # Project the mesh onto a 300x300 grid
  proj = inla.mesh.projector(mesh, xlim = xlim, 
                             ylim = ylim, dims=c(300, 300))
  
  # Do the projection 
  field.proj = inla.mesh.project(proj, field)
  
  # Plot it
  image.plot(list(x = proj$x, y=proj$y, z = field.proj), 
             xlim = xlim, ylim = ylim, ...)  
}
local.plot.field(field, mesh, 
                     xlim = c(3,17), 
                     ylim = ylim,
                     zlim = zlim)
    points(points)
  
  
  df <- df %>% dplyr::filter(field > filter)
  
  if(plot.order == 1){
  gg <- ggplot(data = df, aes(x = field, y = dist)) +
    geom_line()
  }
  
  if(plot.order == 2){ 
  gg <- ggplot(data = df, aes(x = dist, y = field)) +
    geom_line()
  }
  

corr.plots(field, df = b1.df, xlim = c(3,17), ylim, zlim, filter = -1)
b1.plots
```


#############
############
##############

field ex b1




```{r}
smalldist = 0
width = c(3, 3)
range = 4
#width = c(4, 4)
#max.edge.length = 0.2
max.edge.length = 0.4
n = 150
set.inla.seed = 602

x.mid <- 10
xlim.big <- c(0,20)
xlim.small <- c(3,17)
ylim.big <- c(0,20)
ylim.small <- c(3,17)

poly1 <- local.square.polygon(xlim=c(xlim.big[1]-1, x.mid-smalldist/2), 
                          ylim=x.mid+width[1]*c(-.5, .5))

poly2 <- local.square.polygon(xlim=c(x.mid+smalldist/2, xlim.big[2]+1), 
                          ylim=x.mid+width[2]*c(-.5, .5))

poly.original <- SpatialPolygons(c(poly1@polygons, poly2@polygons))
  
loc1 <- matrix(c(xlim.big[1],ylim.big[1], 
                 xlim.big[2],ylim.big[1], 
                 xlim.big[2],ylim.big[2], 
                 xlim.big[1],ylim.big[2]), 4, 2, byrow = T)
  
seg <- inla.sp2segment(poly.original)
# - Transforms a SpatialPolygon to an "inla polygon"
mesh <- inla.mesh.2d(loc=loc1, 
                     interior = seg, 
                     max.e = max.edge.length, 
                     offset=1)

tl <- length(mesh$graph$tv[,1])
# - the number of triangles in the mesh
posTri <- matrix(0, tl, 2)

for (t in 1:tl){
  temp = mesh$loc[mesh$graph$tv[t, ], ]
  posTri[t,] = colMeans(temp)[c(1,2)] 
}

posTri <- SpatialPoints(posTri)
# - the positions of the triangle centers

bar.original <- over(poly.original, SpatialPoints(posTri), returnList=T)
# - checking which mesh triangles are inside the barrier area
bar.original <- unlist(bar.original)
poly.bar.orginal <- inla.barrier.polygon(mesh, barrier.triangles = bar.original)
# - the Barrier model's polygon
# - in most cases this should be the same as poly.original

# BARRIER 1
bar1 <- over(poly1, SpatialPoints(posTri), returnList=T)
# - checking which mesh triangles are inside the barrier area
bar1 <- unlist(bar1)
poly.bar1 <- inla.barrier.polygon(mesh, barrier.triangles = bar1)
# - the Barrier model's polygon
# - in most cases this should be the same as poly.original

# BARRIER 2
bar2 <- over(poly2, SpatialPoints(posTri), returnList=T)
# - checking which mesh triangles are inside the barrier area
bar2 <- unlist(bar2)
poly.bar2 <- inla.barrier.polygon(mesh, barrier.triangles = bar2)

mat <-  inla.barrier.fem.plus(mesh, list(bar1, bar2)) 
fem <- mat 
barrier.triangles <- list(bar1, bar2)

# PLOTS
poly1_h <- local.square.polygon_T(xlim=c(xlim.small[1], x.mid-smalldist/2), 
                          ylim=x.mid+width[1]*c(-.5, .5))

poly2_h <- local.square.polygon_T(xlim=c(x.mid+smalldist/2, xlim.small[2]), 
                          ylim=x.mid+width[2]*c(-.5, .5))

loc2 <- matrix(c(3,3, 17,3, 17,17, 3,17), 4, 2, byrow = T)

locp2 <- Polygon(loc2, hole = FALSE)
    
poly.water <- SpatialPolygons(list(Polygons(list(locp2, poly1_h, poly2_h), '0')))
poly.water_sf <- st_as_sf(poly.water)
    
set.seed(set.inla.seed)
loc.data <- spsample(x = poly.water, n = n, type = "random")
loc.data_sf <- st_as_sf(loc.data)
loc.data <- loc.data@coords

poly.rect <- SpatialPolygons(list(Polygons(list(poly1_h, poly2_h), '0')))
poly.rect_sf <- st_as_sf(poly.rect)
poly.sq <- SpatialPolygons(list(Polygons(list(locp2), '0')))
poly.sq_sf <- st_as_sf(poly.sq)

sq_bbox <- st_bbox(poly.sq_sf) %>% st_as_sfc()
poly1_bbox <- st_bbox(poly1) %>% st_as_sfc()
poly2_bbox <- st_bbox(poly2) %>% st_as_sfc()

gg.mesh <- ggplot() + 
  inlabru::gg(mesh) +
  geom_sf(data =poly.rect_sf,
          col='black', alpha=0) + #alpha color inside rect
  geom_sf(data=poly1_bbox, fill=NA, color="red", linewidth = 0.7, linetype = "dashed") +
  geom_sf(data=poly2_bbox, fill=NA, color="red", linewidth = 0.7, linetype = "dashed") +
  geom_sf(data=sq_bbox, fill=NA, color="black", linewidth = 0.7)

gg.mesh.water <- ggplot() +
  inlabru::gg(mesh) +
  geom_sf(data =poly.rect_sf,
          col='black', alpha=1) + #alpha color inside rect
  geom_sf(data=sq_bbox, fill=NA, color="black", linewidth = 0.7) +
  geom_sf(data=poly1_bbox, color="black", linewidth = 0.7) +
  geom_sf(data=poly2_bbox, color="black", linewidth = 0.7) +
  ylim(c(3, 17)) +
  xlim(c(3, 17))

gg1b.1 <- gg.mesh +
  ggtitle("Mesh")

gg1b.2 <- gg.mesh.water +
  ggtitle("Barrier layout")

gg1b.3 <- gg.mesh.water +
  geom_sf(data =loc.data_sf,
          col='black',size=1.7,alpha=0.5) +
  ggtitle("Simulated data")

fpp <- file.path("1b_mesh.png")
png(fpp)
gridExtra::grid.arrange(gg1b.1, gg1b.2, gg1b.3, ncol=3, nrow=2, 
               top="One barrier scenario")
dev.off()
```


```{r}
zlim = c(0.1, 1)
xlim = poly.water@bbox[1, ] 
ylim = poly.water@bbox[2, ]
proj = inla.mesh.projector(mesh, xlim = xlim, 
                           ylim = ylim, dims=c(300, 300))


local.plot.field = function(field, pal = plasma(50), ...){
  xlim = c(3, 17); ylim = xlim;
  proj = inla.mesh.projector(mesh, xlim = xlim, 
                             ylim = ylim, dims=c(300, 300))
  # - Can project from the mesh onto a 300x300 grid 
  #   for plots
  field.proj = inla.mesh.project(proj, field)
  # - Do the projection
  image.plot(list(x = proj$x, y=proj$y, z = field.proj), 
             xlim = xlim, ylim = ylim, col = pal, ...)  
  # - Use image.plot to get nice colors and legend
}
# - This is the appropriate length of the field variable


model.tbm <- function(mesh = mesh, 
                      fem = fem, 
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      range.fraction = range.fraction,
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1),
                      return.list = TRUE) {
  
  # field = TRUE has to be true to start
  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction)
  # range fraction has to have the same length as barrier triangles
  Q <- inla.rgeneric.q(barrier.model, "Q", theta = c(log(1), log(range))) #log(1) or log(prior.sigma[1])
  u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))
  u <- u[ ,1]
    
  A.data <- inla.spde.make.A(mesh, loc.data)
  #Q from mydiff.r function
    
  u.data <- A.data %*% u
  
  df <- data.frame(loc.data)
  names(df) <- c('locx', 'locy')
  df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))
  
    
  stk <- inla.stack(data=list(y=df$y), 
                    A=list(A.data, 1),
                    effects=list(s=1:mesh$n, 
                                 intercept=rep(1, nrow(df))), 
                    remove.unused = FALSE, 
                    tag='est')

    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
    
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  if (return.list == TRUE) {
    
    list.field <- list(barrier.model = barrier.model, Q = Q, sample = u)
    pos.bm <- list(df = df, res = res.barrier)
    pos.st <- list(res = res.stationary)
    
    return(list(list.field = list.field, pos.bm = pos.bm, pos.st = pos.st))
  }
                     
}

plot.model.tbm.flex2 <- 
  function(trans, 
           nfrac,
           max.frac = 1,
           min.r = min.r,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1,
           set.inla.seed = set.inla.seed,
                              col=alpha('grey', 0),
                              plot.points = points(loc.data, 
                                              pch = 16, 
                                              cex = 0.8, 
                                              col=alpha('gray', 0)),
                              gif.path = "gif/",
                              pal.field = turbo(50),
                              pal.pos.mean = turbo(50),
                              pal.pos.sd = turbo(50),
                              pal.pos.q25 = turbo(50),
                              pal.pos.q50 = turbo(50),
                              pal.pos.q975 = turbo(50),
                              
                              pal.pos.mean.st = turbo(50),
                              pal.pos.sd.st = turbo(50),
                              pal.pos.q25.st = turbo(50),
                              pal.pos.q50.st = turbo(50),
                              pal.pos.q975.st = turbo(50),
                              ...
    ){
  dir_out_f <- file.path(tempdir(), "truefield_gif")
  dir.create(dir_out_f, recursive = TRUE)
  
  # barrier model
  dir_out_pm <- file.path(tempdir(), "posmean_gif")
  dir.create(dir_out_pm, recursive = TRUE)
  
  dir_out_sd <- file.path(tempdir(), "possd_gif")
  dir.create(dir_out_sd, recursive = TRUE)
  
  dir_out_q25 <- file.path(tempdir(), "posq25_gif")
  dir.create(dir_out_q25, recursive = TRUE)
  
  dir_out_q5 <- file.path(tempdir(), "posq5_gif")
  dir.create(dir_out_q5, recursive = TRUE)
  
  dir_out_q975 <- file.path(tempdir(), "posq975_gif")
  dir.create(dir_out_q975, recursive = TRUE)
  
  # stationary model
  dir_out_s <- file.path(tempdir(), "statmodel_gif")
  dir.create(dir_out_s, recursive = TRUE)
  
  dir_out_st.sd <- file.path(tempdir(), "st.sd_gif")
  dir.create(dir_out_st.sd, recursive = TRUE)
  
  dir_out_st.q25 <- file.path(tempdir(), "pos.st.q25_gif")
  dir.create(dir_out_st.q25, recursive = TRUE)
  
  dir_out_st.q5 <- file.path(tempdir(), "pos.st.q5_gif")
  dir.create(dir_out_st.q5, recursive = TRUE)
  
  dir_out_st.q975 <- file.path(tempdir(), "pos.st.q975_gif")
  dir.create(dir_out_st.q975, recursive = TRUE)
  
  fr <- (seq(from = min.r, to = max.frac, length = nfrac)/max.frac)
  if (fr[1] < min.r) fr[1] <- min.r

  for (r in 1:length(trans)) {
    
    f <- fr[r]
    range.fraction <- c(f, f)
    
    # SPATIAL FIELD, u
    fpp <- file.path(dir_out_f, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$list.field$sample, 
                     main="Spatial (simulated) true field",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.field)
    plot(poly.bar.orginal, add=T, col = col)
    plot.points
    dev.off()
    
    # POSTERIOR MEAN
    fpp <- file.path(dir_out_pm, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s$mean, 
                     main="Spatial estimate for Barrier model",
                     sub = paste("range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD
    fpp <- file.path(dir_out_sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s$sd, 
                     main="Spatial sd estimate for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES
    # 0.025
    fpp <- file.path(dir_out_q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,4], 
                     main="Spatial 0.025 quantile estimate for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5
    fpp <- file.path(dir_out_q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile estimate for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975
    fpp <- file.path(dir_out_q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile estimate for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # SPATIAL ESTIMATE WITH STATIONARY MODEL
    fpp <- file.path(dir_out_s, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s$mean,
                     main="Spatial estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean.st) 
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD st
    fpp <- file.path(dir_out_st.sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s$sd, 
                     main="Spatial sd estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES st
    # 0.025 st
    fpp <- file.path(dir_out_st.q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,4], 
                     main="Spatial 0.025 estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5 st
    fpp <- file.path(dir_out_st.q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975 st
    fpp <- file.path(dir_out_st.q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
  }
  
    ## bm
    # SPATIAL FIELD, u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_f, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "true.field.gif"))
    
    # POSTERIOR MEAN
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_pm, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.mean.gif"))
    
    #POS SD
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.gif"))
    
    #POS QUANTILES
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.gif"))
    
    ## st
    # u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_s, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "stat.rnadom.mean.gif"))
    
    # st sd
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.st.gif"))
    
    #POS QUANTILES st
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.st.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.st.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.st.gif"))
    
    unlink(dir_out_f, recursive = T)
    unlink(dir_out_pm, recursive = T)
    unlink(dir_out_sd, recursive = T)
    unlink(dir_out_q25, recursive = T)
    unlink(dir_out_q5, recursive = T)
    unlink(dir_out_q975, recursive = T)
    unlink(dir_out_s, recursive = T)
    unlink(dir_out_st.sd, recursive = T)
    unlink(dir_out_st.q25, recursive = T)
    unlink(dir_out_st.q5, recursive = T)
    unlink(dir_out_st.q975, recursive = T)
}

nfrac = 5
max.frac = 10
min.r = 0.01
fr <- (seq(from = min.r, 
          to = max.frac, 
          length = nfrac)/max.frac) #*range
tbm.frac <- list()

if (fr[1] < min.r) fr[1] <- min.r
for (r in 1:nfrac) { #
  f <- fr[r]
  range.fraction <- c(f, f)
  tbm.frac[[r]] <- model.tbm(mesh = mesh, fem = fem, 
              barrier.triangles = barrier.triangles,
              prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),  
              range.fraction = range.fraction,
              range = range,
              set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
              loc.data = loc.data, 
              sigma.u = 1, sigma.epsilon = 0.2,
              poly.original = poly.bar.orginal,
              prior.range.st = c(1, 0.5),
              prior.sigma.st = c(1, 0.1),
              return.list = TRUE
    )
}

trans <- tbm.frac
w3r4seed602.n150_1b <- tbm.frac

plot.model.tbm.flex2(trans, 
           nfrac,
           max.frac = max.frac,
           min.r = 0.01,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1)
```

```{r}
 # field = TRUE has to be true to start
range.fraction = c(0.5, 0.5)
barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction)
  # range fraction has to have the same length as barrier triangles
  Q <- inla.rgeneric.q(barrier.model, "Q", theta = c(log(1), log(range))) #log(1) or log(prior.sigma[1])
  u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))
  u <- u[ ,1]
    
  A.data <- inla.spde.make.A(mesh, loc.data)
  #Q from mydiff.r function
    
  u.data <- A.data %*% u
  
  df <- data.frame(loc.data)
  names(df) <- c('locx', 'locy')
  df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))
  
    
  stk <- inla.stack(data=list(y=df$y), 
                    A=list(A.data, 1),
                    effects=list(s=1:mesh$n, 
                                 intercept=rep(1, nrow(df))), 
                    remove.unused = FALSE, 
                    tag='est')

model.tbm2 <- function(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      range.fraction = range.fraction,
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1),
                      return.list = TRUE) {
  
    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
    
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  if (return.list == TRUE) {
    
    list.field <- list(barrier.model = barrier.model)
    pos.bm <- list(df = df, res = res.barrier)
    pos.st <- list(res = res.stationary)
    
    return(list(list.field = list.field, pos.bm = pos.bm, pos.st = pos.st))
  }
                     
}

trans.tbm <- model.tbm2(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      range.fraction = range.fraction,
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1),
                      return.list = TRUE)

trans.bm <- model.tbm2(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      range.fraction = c(0.1, 0.1),
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1),
                      return.list = TRUE)
trans <- list()
trans[[1]] <- trans.bm
plot.bm(trans, 
           nfrac = 1,
           max.frac = 1,
           min.r = 0.01,
           poly.bar.orginal = poly.bar.orginal,
           range = c(0.1, 0.1),
           fps = 1)

nfrac = 1
max.frac = 0.1
min.r = 0.01
fr <- (seq(from = min.r, 
          to = max.frac, 
          length = nfrac)/max.frac) #*range
tbm.frac <- list()

if (fr[1] < min.r) fr[1] <- min.r

```


```{r}
nfrac = 5
max.frac = 10
min.r = 0.01
fr <- (seq(from = min.r, 
          to = max.frac, 
          length = nfrac)/max.frac) #*range
tbm.frac <- list()

if (fr[1] < min.r) fr[1] <- min.r
for (r in 1:nfrac) { #
  f <- fr[r]
  range.fraction <- c(f, f)
  tbm.frac[[r]] <- model.tbm(mesh = mesh, fem = fem, 
              barrier.triangles = barrier.triangles,
              prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),  
              range.fraction = range.fraction,
              range = range,
              set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
              loc.data = loc.data, 
              sigma.u = 1, sigma.epsilon = 0.2,
              poly.original = poly.bar.orginal,
              prior.range.st = c(1, 0.5),
              prior.sigma.st = c(1, 0.1),
              return.list = TRUE
    )
}

trans <- tbm.frac

plot.model.tbm.flex(trans, 
           nfrac,
           max.frac = max.frac,
           min.r = 0.01,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1)
```

Same but i want to use the same loc.data points for all cases instead of simulating new ones for each range barrier

I'll do it kinda like i did it for the poisson example meaning stack and Q will be outside and I'll just do the estimation with the different models to compare them
so the comparison should be stationary, barrier, transparent barrier model.

To do after meeting today

```{r}
range.fraction <- c(.5, .5)
sigma.u = 1
sigma.epsilon = 0.2
tbm.true <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction)
# range fraction has to have the same length as barrier triangles
Q <- inla.rgeneric.q(tbm.true, "Q", theta = c(log(1), log(range))) #log(1) or log(prior.sigma[1])
u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))
u <- u[ ,1]
A.data <- inla.spde.make.A(mesh, loc.data)
#Q from mydiff.r function
u.data <- A.data %*% u
df <- data.frame(loc.data)
names(df) <- c('locx', 'locy')
df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))
  
stk <- inla.stack(data=list(y=df$y), 
                    A=list(A.data, 1),
                    effects=list(s=1:mesh$n, 
                                 intercept=rep(1, nrow(df))), 
                    remove.unused = FALSE, 
                    tag='est')
  
tbm.compare <- function(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      nfrac = nfrac,
                      range.fraction = range.fraction, #it has to be a list here, first one is the true one
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1)) {
  
  ###STATIONARY MODEL  
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  ###(CLASSIC) BM
  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction = c(0.1, 0.1))
  
    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
  
  ###TRANSPARENT BARRIER MODEL
  # in case I want to compare tbm's with different range.fractions, the correct result is the one I'm using to sample Q outside this function
  
  tbm <- list()
  for (f in 1:length(range.fraction)) {
    
    tbm[[f]] <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction = range.fraction[[f]])
  
    formula <- y ~ 0 + intercept + f(s, model = tbm)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    res.tbm[[f]] <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6))) 
    }
  
    
    models <- list(st = model.stat, bm = barrier.model, tbm = tbm)
    res <- list(res.st = res.stationary, res.bm = res.barrier, res.tbm = res.tbm)
    
    return(list(models = models, res = res))
}

range.fraction.list <- list()
range.fraction.list[[1]] <- range.fraction
tbm <- tbm.compare(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      nfrac = nfrac,
                      range.fraction = range.fraction.list, #it has to be a list here, first one is the true one
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1))
```
```{r}
tbm.compare <- function(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      nfrac = nfrac,
                      range.fraction = range.fraction, #it has to be a list here, first one is the true one
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1)) {
  
  ###STATIONARY MODEL  
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  ###(CLASSIC) BM
  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction = c(0.1, 0.1))
  
    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
  
  ###TRANSPARENT BARRIER MODEL
  # in case I want to compare tbm's with different range.fractions, the correct result is the one I'm using to sample Q outside this function
  
  tbm <- list()
  res.tbm <- list()
  for (f in 1:length(range.fraction.list)) {
    
    tbm[[1]] <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction = range.fraction.list[[1]])
  
    formula <- y ~ 0 + intercept + f(s, model = tbm)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    res.tbm[[1]] <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6))) 
    }
  
    
    models <- list(st = model.stat, bm = barrier.model, tbm = tbm)
    res <- list(res.st = res.stationary, res.bm = res.barrier, res.tbm = res.tbm)
    
    return(list(models = models, res = res))
```


```{r}
plot.compare <- 
  function(trans, 
           u,
           nfrac,
           max.frac = 1,
           min.r = min.r,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1,
           set.inla.seed = set.inla.seed,
                              col=alpha('grey', 0),
                              plot.points = points(loc.data, 
                                              pch = 16, 
                                              cex = 0.8, 
                                              col=alpha('gray', 0)),
                              gif.path = "gif/",
                              pal.field = turbo(50),
                              pal.pos.mean = turbo(50),
                              pal.pos.sd = turbo(50),
                              pal.pos.q25 = turbo(50),
                              pal.pos.q50 = turbo(50),
                              pal.pos.q975 = turbo(50),
                              
                              pal.pos.mean.st = turbo(50),
                              pal.pos.sd.st = turbo(50),
                              pal.pos.q25.st = turbo(50),
                              pal.pos.q50.st = turbo(50),
                              pal.pos.q975.st = turbo(50),
                              ...
    ){
  dir_out_f <- file.path(tempdir(), "truefield_gif")
  dir.create(dir_out_f, recursive = TRUE)
  
  # barrier model
  dir_out_pm <- file.path(tempdir(), "posmean_gif")
  dir.create(dir_out_pm, recursive = TRUE)
  
  dir_out_sd <- file.path(tempdir(), "possd_gif")
  dir.create(dir_out_sd, recursive = TRUE)
  
  dir_out_q25 <- file.path(tempdir(), "posq25_gif")
  dir.create(dir_out_q25, recursive = TRUE)
  
  dir_out_q5 <- file.path(tempdir(), "posq5_gif")
  dir.create(dir_out_q5, recursive = TRUE)
  
  dir_out_q975 <- file.path(tempdir(), "posq975_gif")
  dir.create(dir_out_q975, recursive = TRUE)
  
  # stationary model
  dir_out_s <- file.path(tempdir(), "statmodel_gif")
  dir.create(dir_out_s, recursive = TRUE)
  
  dir_out_st.sd <- file.path(tempdir(), "st.sd_gif")
  dir.create(dir_out_st.sd, recursive = TRUE)
  
  dir_out_st.q25 <- file.path(tempdir(), "pos.st.q25_gif")
  dir.create(dir_out_st.q25, recursive = TRUE)
  
  dir_out_st.q5 <- file.path(tempdir(), "pos.st.q5_gif")
  dir.create(dir_out_st.q5, recursive = TRUE)
  
  dir_out_st.q975 <- file.path(tempdir(), "pos.st.q975_gif")
  dir.create(dir_out_st.q975, recursive = TRUE)
    
    # SPATIAL FIELD, u
  
    fpp <- file.path(dir_out_f, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(u, 
                     main="True (simulated) Spatial Field",
                     sub = paste("range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.field)
    plot(poly.bar.orginal, add=T, col = col)
    plot.points
    dev.off()
    
    # POSTERIOR MEAN
    fpp <- file.path(dir_out_pm, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s$mean, 
                     main="Spatial mean posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD
    fpp <- file.path(dir_out_sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s$sd, 
                     main="Spatial sd posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES
    # 0.025
    fpp <- file.path(dir_out_q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,4], 
                     main="Spatial 0.025 quantile posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5
    fpp <- file.path(dir_out_q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975
    fpp <- file.path(dir_out_q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # SPATIAL ESTIMATE WITH STATIONARY MODEL
    fpp <- file.path(dir_out_s, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s$mean,
                     main="Spatial estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean.st) 
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD st
    fpp <- file.path(dir_out_st.sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s$sd, 
                     main="Spatial sd posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES st
    # 0.025 st
    fpp <- file.path(dir_out_st.q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,4], 
                     main="Spatial 0.025 quantile posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5 st
    fpp <- file.path(dir_out_st.q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975 st
    fpp <- file.path(dir_out_st.q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
  }
  
    ## bm
    # SPATIAL FIELD, u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_f, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "true.field.gif"))
    
    # POSTERIOR MEAN
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_pm, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.mean.gif"))
    
    #POS SD
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.gif"))
    
    #POS QUANTILES
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.gif"))
    
    ## st
    # u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_s, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "stat.rnadom.mean.gif"))
    
    # st sd
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.st.gif"))
    
    #POS QUANTILES st
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.st.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.st.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.st.gif"))
    
    unlink(dir_out_f, recursive = T)
    unlink(dir_out_pm, recursive = T)
    unlink(dir_out_sd, recursive = T)
    unlink(dir_out_q25, recursive = T)
    unlink(dir_out_q5, recursive = T)
    unlink(dir_out_q975, recursive = T)
    unlink(dir_out_s, recursive = T)
    unlink(dir_out_st.sd, recursive = T)
    unlink(dir_out_st.q25, recursive = T)
    unlink(dir_out_st.q5, recursive = T)
    unlink(dir_out_st.q975, recursive = T)
  }
```


```{r}
nfrac = 5
max.frac = 10
min.r = 0.01
fr <- (seq(from = min.r, 
          to = max.frac, 
          length = nfrac)/max.frac) #*range
tbm.frac <- list()

if (fr[1] < min.r) fr[1] <- min.r
for (r in 1:nfrac) { #
  f <- fr[r]
  range.fraction <- c(f, f)
  tbm.frac[[r]] <- model.tbm(mesh = mesh, fem = fem, 
              barrier.triangles = barrier.triangles,
              prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),  
              range.fraction = range.fraction,
              range = range,
              set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
              loc.data = loc.data, 
              sigma.u = 1, sigma.epsilon = 0.2,
              poly.original = poly.bar.orginal,
              prior.range.st = c(1, 0.5),
              prior.sigma.st = c(1, 0.1),
              return.list = TRUE
    )
}

trans <- tbm.frac

plot.model.tbm.flex(trans, 
           nfrac,
           max.frac = max.frac,
           min.r = 0.01,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1)
```


```{r}
bm_hp <- list()
st_hp <- list()
frac = 5

bm_hp <- rbind(
data.frame(exp(trans[[1]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])),
data.frame(exp(trans[[2]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])),
data.frame(exp(trans[[3]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])),
data.frame(exp(trans[[4]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])),
data.frame(exp(trans[[5]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])))
st_hp <- rbind(
data.frame((trans[[1]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])),
data.frame((trans[[2]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])),
data.frame((trans[[3]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])),
data.frame((trans[[4]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])),
data.frame((trans[[5]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])))

colnames(bm_hp)[2:3] <- c("0.025quant", "0.975quant")
rownames(bm_hp) <- c("r1", "r2", "r3", "r4","r5")

colnames(st_hp)[2:3] <- c("0.025quant", "0.975quant")
rownames(st_hp) <- c("r1", "r2", "r3", "r4","r5")
#write.csv(rbind(bm_hp,st_hp), "4proposal\\trans2.5.csv")
#bm_hp.25 = bm_hp 
#st_hp.25 = st_hp
```

```{r}
ggplot() + 
  inlabru::gg(mesh.seg) +
  geom_sf(data =poly.rect_sf,
          col='black', alpha=0) + #alpha color inside rect
  geom_sf(data=poly1_bbox, fill=NA, color="red", linewidth = 0.7, linetype = "dashed") +
  geom_sf(data=poly2_bbox, fill=NA, color="red", linewidth = 0.7, linetype = "dashed") +
  geom_sf(data=sq_bbox, fill=NA, color="black", linewidth = 0.7)

ggplot() + 
  inlabru::gg(mesh.seg) +
  geom_sf(data =poly.rect_sf,
          col='black', alpha=1) + #alpha color inside rect
  geom_sf(data=sq_bbox, fill=NA, color="black", linewidth = 0.7) +
  geom_sf(data=poly1_bbox, color="black", linewidth = 0.7) +
  geom_sf(data=poly2_bbox, color="black", linewidth = 0.7) +
  ylim(c(3, 17)) +
  xlim(c(3, 17)) 
```


# MESH wiht almost triangular barriers
mesh.seg_h <- inla.mesh.2d(boundary = poly.water, #? has to have holes=F
                           interior = seg, 
                           max.e = max.edge.length, 
                           offset=1)
ggplot() + 
  inlabru::gg(mesh.seg_h)

```{r}
trans <- w3r4seed602.n150_1b 
trans[[r]]$pos.st$res$summary.random$s[,5]

# PLOTS
# set 1
par(mfrow = c(1, 3), mar = c(3, 3, 1, 0.3), mgp = c(2, 1, 0)) 


fr <- (seq(from = min.r, to = max.frac, length = nfrac)/max.frac)
if (fr[1] < min.r) fr[1] <- min.r

for (r in 1:length(trans)) {
  f <- fr[r]
  range.fraction <- c(f, f)
  fpp <- file.path(paste0(f, ".png"))
  png(fpp)
  par(mfrow = c(2, 1))
  tmp = inla.tmarginal(function(x) exp(x), trans[[r]]$pos.bm$res$marginals.hyperpar[[3]]) 
  plot(tmp, type = "l", xlab = "r", ylab = "Density", xlim = c(2,12))
      xvals = seq(0, 10, length.out=1000)
      
  abline(v=range, col="blue")
  
  tmp = inla.tmarginal(function(x) (x), trans[[r]]$pos.st$res$marginals.hyperpar[[2]]) 
  plot(tmp, type = "l", xlab = "r", ylab = "Density", xlim = c(2,12))
      xvals = seq(0, 10, length.out=1000)
  abline(v=range, col="blue")
  dev.off()
}
```


########

FIELD EX 2B



```{r}
smalldist = 1
width = c(3, 3)
range = 2
#width = c(4, 4)
#max.edge.length = 0.2
max.edge.length = 0.4
n = 150
set.inla.seed = 602

x.mid <- 10
xlim.big <- c(0,20)
xlim.small <- c(3,17)
ylim.big <- c(0,20)
ylim.small <- c(3,17)

poly1 <- local.square.polygon(xlim=c(xlim.big[1]-1, x.mid-smalldist/2), 
                          ylim=x.mid+width[1]*c(-.5, .5))

poly2 <- local.square.polygon(xlim=c(x.mid+smalldist/2, xlim.big[2]+1), 
                          ylim=x.mid+width[2]*c(-.5, .5))

poly.original <- SpatialPolygons(c(poly1@polygons, poly2@polygons))
  
loc1 <- matrix(c(xlim.big[1],ylim.big[1], 
                 xlim.big[2],ylim.big[1], 
                 xlim.big[2],ylim.big[2], 
                 xlim.big[1],ylim.big[2]), 4, 2, byrow = T)
  
seg <- inla.sp2segment(poly.original)
# - Transforms a SpatialPolygon to an "inla polygon"
mesh <- inla.mesh.2d(loc=loc1, 
                     interior = seg, 
                     max.e = max.edge.length, 
                     offset=1)

tl <- length(mesh$graph$tv[,1])
# - the number of triangles in the mesh
posTri <- matrix(0, tl, 2)

for (t in 1:tl){
  temp = mesh$loc[mesh$graph$tv[t, ], ]
  posTri[t,] = colMeans(temp)[c(1,2)] 
}

posTri <- SpatialPoints(posTri)
# - the positions of the triangle centers

bar.original <- over(poly.original, SpatialPoints(posTri), returnList=T)
# - checking which mesh triangles are inside the barrier area
bar.original <- unlist(bar.original)
poly.bar.orginal <- inla.barrier.polygon(mesh, barrier.triangles = bar.original)
# - the Barrier model's polygon
# - in most cases this should be the same as poly.original

# BARRIER 1
bar1 <- over(poly1, SpatialPoints(posTri), returnList=T)
# - checking which mesh triangles are inside the barrier area
bar1 <- unlist(bar1)
poly.bar1 <- inla.barrier.polygon(mesh, barrier.triangles = bar1)
# - the Barrier model's polygon
# - in most cases this should be the same as poly.original

# BARRIER 2
bar2 <- over(poly2, SpatialPoints(posTri), returnList=T)
# - checking which mesh triangles are inside the barrier area
bar2 <- unlist(bar2)
poly.bar2 <- inla.barrier.polygon(mesh, barrier.triangles = bar2)

mat <-  inla.barrier.fem.plus(mesh, list(bar1, bar2)) 
fem <- mat 
barrier.triangles <- list(bar1, bar2)

# PLOTS
poly1_h <- local.square.polygon_T(xlim=c(xlim.small[1], x.mid-smalldist/2), 
                          ylim=x.mid+width[1]*c(-.5, .5))

poly2_h <- local.square.polygon_T(xlim=c(x.mid+smalldist/2, xlim.small[2]), 
                          ylim=x.mid+width[2]*c(-.5, .5))

loc2 <- matrix(c(3,3, 17,3, 17,17, 3,17), 4, 2, byrow = T)

locp2 <- Polygon(loc2, hole = FALSE)
    
poly.water <- SpatialPolygons(list(Polygons(list(locp2, poly1_h, poly2_h), '0')))
poly.water_sf <- st_as_sf(poly.water)
    
set.seed(set.inla.seed)
loc.data <- spsample(x = poly.water, n = n, type = "random")
loc.data_sf <- st_as_sf(loc.data)
loc.data <- loc.data@coords

poly.rect <- SpatialPolygons(list(Polygons(list(poly1_h, poly2_h), '0')))
poly.rect_sf <- st_as_sf(poly.rect)
poly.sq <- SpatialPolygons(list(Polygons(list(locp2), '0')))
poly.sq_sf <- st_as_sf(poly.sq)

sq_bbox <- st_bbox(poly.sq_sf) %>% st_as_sfc()
poly1_bbox <- st_bbox(poly1) %>% st_as_sfc()
poly2_bbox <- st_bbox(poly2) %>% st_as_sfc()

gg.mesh <- ggplot() + 
  inlabru::gg(mesh) +
  geom_sf(data =poly.rect_sf,
          col='black', alpha=0) + #alpha color inside rect
  geom_sf(data=poly1_bbox, fill=NA, color="red", linewidth = 0.7, linetype = "dashed") +
  geom_sf(data=poly2_bbox, fill=NA, color="red", linewidth = 0.7, linetype = "dashed") +
  geom_sf(data=sq_bbox, fill=NA, color="black", linewidth = 0.7)

gg.mesh.water <- ggplot() +
  inlabru::gg(mesh) +
  geom_sf(data =poly.rect_sf,
          col='black', alpha=1) + #alpha color inside rect
  geom_sf(data=sq_bbox, fill=NA, color="black", linewidth = 0.7) +
  geom_sf(data=poly1_bbox, color="black", linewidth = 0.7) +
  geom_sf(data=poly2_bbox, color="black", linewidth = 0.7) +
  ylim(c(3, 17)) +
  xlim(c(3, 17))

gg.mesh +
  geom_sf(data =loc.data_sf,
          col='black',size=1.7,alpha=0.5)

gg.mesh.water +
  geom_sf(data =loc.data_sf,
          col='black',size=1.7,alpha=0.5)

gg2b.1 <- gg.mesh +
  ggtitle("Mesh")

gg2b.2 <- gg.mesh.water +
  ggtitle("Barrier layout")

gg2b.3 <- gg.mesh.water +
  geom_sf(data =loc.data_sf,
          col='black',size=1.7,alpha=0.5) +
  ggtitle("Simulated data")

fpp <- file.path("2b_mesh.png")
png(fpp)
gridExtra::grid.arrange(gg2b.1, gg2b.2, gg2b.3, ncol=3, nrow=2, 
               top="Two barriers scenario")
dev.off()

zlim = c(0.1, 1)
xlim = poly.water@bbox[1, ] 
ylim = poly.water@bbox[2, ]
proj = inla.mesh.projector(mesh, xlim = xlim, 
                           ylim = ylim, dims=c(300, 300))


local.plot.field = function(field, pal = plasma(50), ...){
  xlim = c(3, 17); ylim = xlim;
  proj = inla.mesh.projector(mesh, xlim = xlim, 
                             ylim = ylim, dims=c(300, 300))
  # - Can project from the mesh onto a 300x300 grid 
  #   for plots
  field.proj = inla.mesh.project(proj, field)
  # - Do the projection
  image.plot(list(x = proj$x, y=proj$y, z = field.proj), 
             xlim = xlim, ylim = ylim, col = pal, ...)  
  # - Use image.plot to get nice colors and legend
}
# - This is the appropriate length of the field variable


model.tbm <- function(mesh = mesh, 
                      fem = fem, 
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      range.fraction = range.fraction,
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1),
                      return.list = TRUE) {
  
  # field = TRUE has to be true to start
  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction)
  # range fraction has to have the same length as barrier triangles
  Q <- inla.rgeneric.q(barrier.model, "Q", theta = c(log(1), log(range))) #log(1) or log(prior.sigma[1])
  u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))
  u <- u[ ,1]
    
  A.data <- inla.spde.make.A(mesh, loc.data)
  #Q from mydiff.r function
    
  u.data <- A.data %*% u
  
  df <- data.frame(loc.data)
  names(df) <- c('locx', 'locy')
  df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))
  
    
  stk <- inla.stack(data=list(y=df$y), 
                    A=list(A.data, 1),
                    effects=list(s=1:mesh$n, 
                                 intercept=rep(1, nrow(df))), 
                    remove.unused = FALSE, 
                    tag='est')

    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
    
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  if (return.list == TRUE) {
    
    list.field <- list(barrier.model = barrier.model, Q = Q, sample = u)
    pos.bm <- list(df = df, res = res.barrier)
    pos.st <- list(res = res.stationary)
    
    return(list(list.field = list.field, pos.bm = pos.bm, pos.st = pos.st))
  }
                     
}

plot.model.tbm.flex2 <- 
  function(trans, 
           nfrac,
           max.frac = 1,
           min.r = min.r,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1,
           set.inla.seed = set.inla.seed,
                              col=alpha('grey', 0),
                              plot.points = points(loc.data, 
                                              pch = 16, 
                                              cex = 0.8, 
                                              col=alpha('gray', 0)),
                              gif.path = "gif/",
                              pal.field = turbo(50),
                              pal.pos.mean = turbo(50),
                              pal.pos.sd = turbo(50),
                              pal.pos.q25 = turbo(50),
                              pal.pos.q50 = turbo(50),
                              pal.pos.q975 = turbo(50),
                              
                              pal.pos.mean.st = turbo(50),
                              pal.pos.sd.st = turbo(50),
                              pal.pos.q25.st = turbo(50),
                              pal.pos.q50.st = turbo(50),
                              pal.pos.q975.st = turbo(50),
                              ...
    ){
  dir_out_f <- file.path(tempdir(), "truefield_gif")
  dir.create(dir_out_f, recursive = TRUE)
  
  # barrier model
  dir_out_pm <- file.path(tempdir(), "posmean_gif")
  dir.create(dir_out_pm, recursive = TRUE)
  
  dir_out_sd <- file.path(tempdir(), "possd_gif")
  dir.create(dir_out_sd, recursive = TRUE)
  
  dir_out_q25 <- file.path(tempdir(), "posq25_gif")
  dir.create(dir_out_q25, recursive = TRUE)
  
  dir_out_q5 <- file.path(tempdir(), "posq5_gif")
  dir.create(dir_out_q5, recursive = TRUE)
  
  dir_out_q975 <- file.path(tempdir(), "posq975_gif")
  dir.create(dir_out_q975, recursive = TRUE)
  
  # stationary model
  dir_out_s <- file.path(tempdir(), "statmodel_gif")
  dir.create(dir_out_s, recursive = TRUE)
  
  dir_out_st.sd <- file.path(tempdir(), "st.sd_gif")
  dir.create(dir_out_st.sd, recursive = TRUE)
  
  dir_out_st.q25 <- file.path(tempdir(), "pos.st.q25_gif")
  dir.create(dir_out_st.q25, recursive = TRUE)
  
  dir_out_st.q5 <- file.path(tempdir(), "pos.st.q5_gif")
  dir.create(dir_out_st.q5, recursive = TRUE)
  
  dir_out_st.q975 <- file.path(tempdir(), "pos.st.q975_gif")
  dir.create(dir_out_st.q975, recursive = TRUE)
  
  fr <- (seq(from = min.r, to = max.frac, length = nfrac)/max.frac)
  if (fr[1] < min.r) fr[1] <- min.r

  for (r in 1:length(trans)) {
    
    f <- fr[r]
    range.fraction <- c(f, f)
    
    # SPATIAL FIELD, u
    fpp <- file.path(dir_out_f, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$list.field$sample, 
                     main="Spatial (simulated) true field",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.field)
    plot(poly.bar.orginal, add=T, col = col)
    plot.points
    dev.off()
    
    # POSTERIOR MEAN
    fpp <- file.path(dir_out_pm, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s$mean, 
                     main="Spatial estimate for Barrier model",
                     sub = paste("range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD
    fpp <- file.path(dir_out_sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s$sd, 
                     main="Spatial sd estimate for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES
    # 0.025
    fpp <- file.path(dir_out_q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,4], 
                     main="Spatial 0.025 quantile estimate for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5
    fpp <- file.path(dir_out_q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile estimate for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975
    fpp <- file.path(dir_out_q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile estimate for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # SPATIAL ESTIMATE WITH STATIONARY MODEL
    fpp <- file.path(dir_out_s, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s$mean,
                     main="Spatial estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean.st) 
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD st
    fpp <- file.path(dir_out_st.sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s$sd, 
                     main="Spatial sd estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES st
    # 0.025 st
    fpp <- file.path(dir_out_st.q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,4], 
                     main="Spatial 0.025 estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5 st
    fpp <- file.path(dir_out_st.q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975 st
    fpp <- file.path(dir_out_st.q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
  }
  
    ## bm
    # SPATIAL FIELD, u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_f, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "true.field.gif"))
    
    # POSTERIOR MEAN
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_pm, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.mean.gif"))
    
    #POS SD
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.gif"))
    
    #POS QUANTILES
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.gif"))
    
    ## st
    # u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_s, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "stat.rnadom.mean.gif"))
    
    # st sd
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.st.gif"))
    
    #POS QUANTILES st
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.st.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.st.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.st.gif"))
    
    unlink(dir_out_f, recursive = T)
    unlink(dir_out_pm, recursive = T)
    unlink(dir_out_sd, recursive = T)
    unlink(dir_out_q25, recursive = T)
    unlink(dir_out_q5, recursive = T)
    unlink(dir_out_q975, recursive = T)
    unlink(dir_out_s, recursive = T)
    unlink(dir_out_st.sd, recursive = T)
    unlink(dir_out_st.q25, recursive = T)
    unlink(dir_out_st.q5, recursive = T)
    unlink(dir_out_st.q975, recursive = T)
}

nfrac = 5
max.frac = 10
min.r = 0.01
fr <- (seq(from = min.r, 
          to = max.frac, 
          length = nfrac)/max.frac) #*range
tbm.frac <- list()

if (fr[1] < min.r) fr[1] <- min.r
for (r in 1:nfrac) { #
  f <- fr[r]
  range.fraction <- c(f, f)
  tbm.frac[[r]] <- model.tbm(mesh = mesh, fem = fem, 
              barrier.triangles = barrier.triangles,
              prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),  
              range.fraction = range.fraction,
              range = range,
              set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
              loc.data = loc.data, 
              sigma.u = 1, sigma.epsilon = 0.2,
              poly.original = poly.bar.orginal,
              prior.range.st = c(1, 0.5),
              prior.sigma.st = c(1, 0.1),
              return.list = TRUE
    )
}

trans <- tbm.frac
#w3r4seed602.n150 <- tbm.frac

plot.model.tbm.flex2(trans, 
           nfrac,
           max.frac = max.frac,
           min.r = 0.01,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1)
```

```{r}
trans <- w3r4seed602.n150 
trans[[r]]$pos.st$res$summary.random$s[,5]

# PLOTS
# set 1
par(mfrow = c(1, 3), mar = c(3, 3, 1, 0.3), mgp = c(2, 1, 0)) 


fr <- (seq(from = min.r, to = max.frac, length = nfrac)/max.frac)
if (fr[1] < min.r) fr[1] <- min.r

for (r in 1:length(trans)) {
  f <- fr[r]
  range.fraction <- c(f, f)
  fpp <- file.path(paste0(f, ".png"))
  png(fpp)
  par(mfrow = c(2, 1))
  tmp = inla.tmarginal(function(x) exp(x), trans[[r]]$pos.bm$res$marginals.hyperpar[[3]]) 
  plot(tmp, type = "l", xlab = "r", ylab = "Density", xlim = c(2,12))
      xvals = seq(0, 10, length.out=1000)
      
  abline(v=range, col="blue")
  
  tmp = inla.tmarginal(function(x) (x), trans[[r]]$pos.st$res$marginals.hyperpar[[2]]) 
  plot(tmp, type = "l", xlab = "r", ylab = "Density", xlim = c(2,12))
      xvals = seq(0, 10, length.out=1000)
  abline(v=range, col="blue")
  dev.off()
}





```


```{r}
main="Spatial 0.975 quantile estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")")
    

plot(res.pp.stP1$marginals.fixed[[1]], type = 'l', xlab = expression(beta[0]),
     ylab = 'Density')
abline(v = beta0, col = 2)

plot(res.pp.stP1$marginals.hyperpar[[2]], type = 'l', xlab = expression(sigma),
     ylab = 'Density', xlim = c(0,2))
abline(v = sqrt(sigma2x), col = 2)

plot(res.pp.stP1$marginals.hyperpar[[1]], type = 'l', xlab = 'Nominal range',
     ylab = 'Density', xlim = c(0, 8))
abline(v = range, col = 2)

# set 2
par(mfrow = c(1, 3), mar = c(3, 3, 1, 0.3), mgp = c(2, 1, 0)) 

plot(res.pp.stP2$marginals.fixed[[1]], type = 'l', xlab = expression(beta[0]),
     ylab = 'Density')
abline(v = beta0, col = 2)

plot(res.pp.stP2$marginals.hyperpar[[2]], type = 'l', xlab = expression(sigma),
     ylab = 'Density', xlim = c(0,2))
abline(v = sqrt(sigma2x), col = 2)

plot(res.pp.stP2$marginals.hyperpar[[1]], type = 'l', xlab = 'Nominal range',
     ylab = 'Density', xlim = c(0, 8))
abline(v = range, col = 2)

# set 3
par(mfrow = c(1, 3), mar = c(3, 3, 1, 0.3), mgp = c(2, 1, 0)) 

plot(res.pp.stP3$marginals.fixed[[1]], type = 'l', xlab = expression(beta[0]),
     ylab = 'Density')
abline(v = beta0, col = 2)

plot(res.pp.stP3$marginals.hyperpar[[2]], type = 'l', xlab = expression(sigma),
     ylab = 'Density', xlim = c(0,2))
abline(v = sqrt(sigma2x), col = 2)

plot(res.pp.stP3$marginals.hyperpar[[1]], type = 'l', xlab = 'Nominal range',
     ylab = 'Density', xlim = c(0, 8))
abline(v = range, col = 2)
```

######
#####
######
after meeting today

```{r}
 # field = TRUE has to be true to start
range.fraction = c(0.5, 0.5)
barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction)
  # range fraction has to have the same length as barrier triangles
  Q <- inla.rgeneric.q(barrier.model, "Q", theta = c(log(1), log(range))) #log(1) or log(prior.sigma[1])
  u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))
  u <- u[ ,1]
    
  A.data <- inla.spde.make.A(mesh, loc.data)
  #Q from mydiff.r function
    
  u.data <- A.data %*% u
  
  df <- data.frame(loc.data)
  names(df) <- c('locx', 'locy')
  df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))
  
    
  stk <- inla.stack(data=list(y=df$y), 
                    A=list(A.data, 1),
                    effects=list(s=1:mesh$n, 
                                 intercept=rep(1, nrow(df))), 
                    remove.unused = FALSE, 
                    tag='est')

model.tbm2 <- function(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      range.fraction = range.fraction,
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1),
                      return.list = TRUE) {
  
    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
    
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  if (return.list == TRUE) {
    
    list.field <- list(barrier.model = barrier.model)
    pos.bm <- list(df = df, res = res.barrier)
    pos.st <- list(res = res.stationary)
    
    return(list(list.field = list.field, pos.bm = pos.bm, pos.st = pos.st))
  }
                     
}

trans.tbm <- model.tbm2(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      range.fraction = range.fraction,
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1),
                      return.list = TRUE)

trans.bm <- model.tbm2(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      range.fraction = c(0.1, 0.1),
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1),
                      return.list = TRUE)
trans <- list()
trans[[1]] <- trans.bm
plot.bm(trans, 
           nfrac = 1,
           max.frac = 1,
           min.r = 0.01,
           poly.bar.orginal = poly.bar.orginal,
           range = c(0.1, 0.1),
           fps = 1)

nfrac = 1
max.frac = 0.1
min.r = 0.01
fr <- (seq(from = min.r, 
          to = max.frac, 
          length = nfrac)/max.frac) #*range
tbm.frac <- list()

if (fr[1] < min.r) fr[1] <- min.r

```


```{r}
nfrac = 5
max.frac = 10
min.r = 0.01
fr <- (seq(from = min.r, 
          to = max.frac, 
          length = nfrac)/max.frac) #*range
tbm.frac <- list()

if (fr[1] < min.r) fr[1] <- min.r
for (r in 1:nfrac) { #
  f <- fr[r]
  range.fraction <- c(f, f)
  tbm.frac[[r]] <- model.tbm(mesh = mesh, fem = fem, 
              barrier.triangles = barrier.triangles,
              prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),  
              range.fraction = range.fraction,
              range = range,
              set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
              loc.data = loc.data, 
              sigma.u = 1, sigma.epsilon = 0.2,
              poly.original = poly.bar.orginal,
              prior.range.st = c(1, 0.5),
              prior.sigma.st = c(1, 0.1),
              return.list = TRUE
    )
}

trans <- tbm.frac

plot.model.tbm.flex(trans, 
           nfrac,
           max.frac = max.frac,
           min.r = 0.01,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1)
```



########
#######
########
Same but i want to use the same loc.data points for all cases instead of simulating new ones for each range barrier

I'll do it kinda like i did it for the poisson example meaning stack and Q will be outside and I'll just do the estimation with the different models to compare them
so the comparison should be stationary, barrier, transparent barrier model.

To do after meeting today

```{r}
range.fraction <- c(.5, .5)
sigma.u = 1
sigma.epsilon = 0.2
tbm.true <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction)
# range fraction has to have the same length as barrier triangles
Q <- inla.rgeneric.q(tbm.true, "Q", theta = c(log(1), log(range))) #log(1) or log(prior.sigma[1])
u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))
u <- u[ ,1]
A.data <- inla.spde.make.A(mesh, loc.data)
#Q from mydiff.r function
u.data <- A.data %*% u
df <- data.frame(loc.data)
names(df) <- c('locx', 'locy')
df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))
  
stk <- inla.stack(data=list(y=df$y), 
                    A=list(A.data, 1),
                    effects=list(s=1:mesh$n, 
                                 intercept=rep(1, nrow(df))), 
                    remove.unused = FALSE, 
                    tag='est')
  
tbm.compare <- function(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      nfrac = nfrac,
                      range.fraction = range.fraction, #it has to be a list here, first one is the true one
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1)) {
  
  ###STATIONARY MODEL  
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  ###(CLASSIC) BM
  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction = c(0.1, 0.1))
  
    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
  
  ###TRANSPARENT BARRIER MODEL
  # in case I want to compare tbm's with different range.fractions, the correct result is the one I'm using to sample Q outside this function
  
  tbm <- list()
  for (f in 1:length(range.fraction)) {
    
    tbm[[f]] <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction = range.fraction[[f]])
  
    formula <- y ~ 0 + intercept + f(s, model = tbm)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    res.tbm[[f]] <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6))) 
    }
  
    
    models <- list(st = model.stat, bm = barrier.model, tbm = tbm)
    res <- list(res.st = res.stationary, res.bm = res.barrier, res.tbm = res.tbm)
    
    return(list(models = models, res = res))
}

range.fraction.list <- list()
range.fraction.list[[1]] <- range.fraction
tbm <- tbm.compare(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      nfrac = nfrac,
                      range.fraction = range.fraction.list, #it has to be a list here, first one is the true one
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1))
```
```{r}
tbm.compare <- function(mesh = mesh, 
                      fem = fem, 
                      stk = stk,
                      barrier.triangles = barrier.triangles, 
                      prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),
                      nfrac = nfrac,
                      range.fraction = range.fraction, #it has to be a list here, first one is the true one
                      range = range,
                      set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                      loc.data = loc.data, 
                      sigma.u = 1, sigma.epsilon = 0.2,
                      poly.original = poly.bar.orginal,
                      prior.range.st = c(1, 0.5),    
                      prior.sigma.st = c(1, 0.1)) {
  
  ###STATIONARY MODEL  
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  ###(CLASSIC) BM
  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction = c(0.1, 0.1))
  
    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
  
  ###TRANSPARENT BARRIER MODEL
  # in case I want to compare tbm's with different range.fractions, the correct result is the one I'm using to sample Q outside this function
  
  tbm <- list()
  res.tbm <- list()
  for (f in 1:length(range.fraction.list)) {
    
    tbm[[1]] <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction = range.fraction.list[[1]])
  
    formula <- y ~ 0 + intercept + f(s, model = tbm)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    res.tbm[[1]] <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6))) 
    }
  
    
    models <- list(st = model.stat, bm = barrier.model, tbm = tbm)
    res <- list(res.st = res.stationary, res.bm = res.barrier, res.tbm = res.tbm)
    
    return(list(models = models, res = res))
```


```{r}
plot.compare <- 
  function(trans, 
           u,
           nfrac,
           max.frac = 1,
           min.r = min.r,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1,
           set.inla.seed = set.inla.seed,
                              col=alpha('grey', 0),
                              plot.points = points(loc.data, 
                                              pch = 16, 
                                              cex = 0.8, 
                                              col=alpha('gray', 0)),
                              gif.path = "gif/",
                              pal.field = turbo(50),
                              pal.pos.mean = turbo(50),
                              pal.pos.sd = turbo(50),
                              pal.pos.q25 = turbo(50),
                              pal.pos.q50 = turbo(50),
                              pal.pos.q975 = turbo(50),
                              
                              pal.pos.mean.st = turbo(50),
                              pal.pos.sd.st = turbo(50),
                              pal.pos.q25.st = turbo(50),
                              pal.pos.q50.st = turbo(50),
                              pal.pos.q975.st = turbo(50),
                              ...
    ){
  dir_out_f <- file.path(tempdir(), "truefield_gif")
  dir.create(dir_out_f, recursive = TRUE)
  
  # barrier model
  dir_out_pm <- file.path(tempdir(), "posmean_gif")
  dir.create(dir_out_pm, recursive = TRUE)
  
  dir_out_sd <- file.path(tempdir(), "possd_gif")
  dir.create(dir_out_sd, recursive = TRUE)
  
  dir_out_q25 <- file.path(tempdir(), "posq25_gif")
  dir.create(dir_out_q25, recursive = TRUE)
  
  dir_out_q5 <- file.path(tempdir(), "posq5_gif")
  dir.create(dir_out_q5, recursive = TRUE)
  
  dir_out_q975 <- file.path(tempdir(), "posq975_gif")
  dir.create(dir_out_q975, recursive = TRUE)
  
  # stationary model
  dir_out_s <- file.path(tempdir(), "statmodel_gif")
  dir.create(dir_out_s, recursive = TRUE)
  
  dir_out_st.sd <- file.path(tempdir(), "st.sd_gif")
  dir.create(dir_out_st.sd, recursive = TRUE)
  
  dir_out_st.q25 <- file.path(tempdir(), "pos.st.q25_gif")
  dir.create(dir_out_st.q25, recursive = TRUE)
  
  dir_out_st.q5 <- file.path(tempdir(), "pos.st.q5_gif")
  dir.create(dir_out_st.q5, recursive = TRUE)
  
  dir_out_st.q975 <- file.path(tempdir(), "pos.st.q975_gif")
  dir.create(dir_out_st.q975, recursive = TRUE)
    
    # SPATIAL FIELD, u
  
    fpp <- file.path(dir_out_f, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(u, 
                     main="True (simulated) Spatial Field",
                     sub = paste("range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.field)
    plot(poly.bar.orginal, add=T, col = col)
    plot.points
    dev.off()
    
    # POSTERIOR MEAN
    fpp <- file.path(dir_out_pm, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s$mean, 
                     main="Spatial mean posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD
    fpp <- file.path(dir_out_sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s$sd, 
                     main="Spatial sd posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES
    # 0.025
    fpp <- file.path(dir_out_q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,4], 
                     main="Spatial 0.025 quantile posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5
    fpp <- file.path(dir_out_q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975
    fpp <- file.path(dir_out_q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.bm$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # SPATIAL ESTIMATE WITH STATIONARY MODEL
    fpp <- file.path(dir_out_s, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s$mean,
                     main="Spatial estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean.st) 
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD st
    fpp <- file.path(dir_out_st.sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s$sd, 
                     main="Spatial sd posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES st
    # 0.025 st
    fpp <- file.path(dir_out_st.q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,4], 
                     main="Spatial 0.025 quantile posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5 st
    fpp <- file.path(dir_out_st.q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975 st
    fpp <- file.path(dir_out_st.q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans[[r]]$pos.st$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
  }
  
    ## bm
    # SPATIAL FIELD, u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_f, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "true.field.gif"))
    
    # POSTERIOR MEAN
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_pm, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.mean.gif"))
    
    #POS SD
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.gif"))
    
    #POS QUANTILES
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.gif"))
    
    ## st
    # u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_s, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "stat.rnadom.mean.gif"))
    
    # st sd
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.st.gif"))
    
    #POS QUANTILES st
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.st.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.st.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.st.gif"))
    
    unlink(dir_out_f, recursive = T)
    unlink(dir_out_pm, recursive = T)
    unlink(dir_out_sd, recursive = T)
    unlink(dir_out_q25, recursive = T)
    unlink(dir_out_q5, recursive = T)
    unlink(dir_out_q975, recursive = T)
    unlink(dir_out_s, recursive = T)
    unlink(dir_out_st.sd, recursive = T)
    unlink(dir_out_st.q25, recursive = T)
    unlink(dir_out_st.q5, recursive = T)
    unlink(dir_out_st.q975, recursive = T)
  }
```


```{r}
nfrac = 5
max.frac = 10
min.r = 0.01
fr <- (seq(from = min.r, 
          to = max.frac, 
          length = nfrac)/max.frac) #*range
tbm.frac <- list()

if (fr[1] < min.r) fr[1] <- min.r
for (r in 1:nfrac) { #
  f <- fr[r]
  range.fraction <- c(f, f)
  tbm.frac[[r]] <- model.tbm(mesh = mesh, fem = fem, 
              barrier.triangles = barrier.triangles,
              prior.range = c(1, 0.5), prior.sigma = c(1, 0.1),  
              range.fraction = range.fraction,
              range = range,
              set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
              loc.data = loc.data, 
              sigma.u = 1, sigma.epsilon = 0.2,
              poly.original = poly.bar.orginal,
              prior.range.st = c(1, 0.5),
              prior.sigma.st = c(1, 0.1),
              return.list = TRUE
    )
}

trans <- tbm.frac

plot.model.tbm.flex(trans, 
           nfrac,
           max.frac = max.frac,
           min.r = 0.01,
           poly.bar.orginal = poly.bar.orginal,
           range = range,
           fps = 1)
```


```{r}
bm_hp <- list()
st_hp <- list()
frac = 5

bm_hp <- rbind(
data.frame(exp(trans[[1]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])),
data.frame(exp(trans[[2]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])),
data.frame(exp(trans[[3]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])),
data.frame(exp(trans[[4]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])),
data.frame(exp(trans[[5]]$pos.bm$res$summary.hyperpar[3,c(1,3,5)])))
st_hp <- rbind(
data.frame((trans[[1]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])),
data.frame((trans[[2]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])),
data.frame((trans[[3]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])),
data.frame((trans[[4]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])),
data.frame((trans[[5]]$pos.st$res$summary.hyperpar[2,c(1,3,5)])))

colnames(bm_hp)[2:3] <- c("0.025quant", "0.975quant")
rownames(bm_hp) <- c("r1", "r2", "r3", "r4","r5")

colnames(st_hp)[2:3] <- c("0.025quant", "0.975quant")
rownames(st_hp) <- c("r1", "r2", "r3", "r4","r5")
#write.csv(rbind(bm_hp,st_hp), "4proposal\\trans2.5.csv")
#bm_hp.25 = bm_hp 
#st_hp.25 = st_hp
```

```{r}
ggplot() + 
  inlabru::gg(mesh.seg) +
  geom_sf(data =poly.rect_sf,
          col='black', alpha=0) + #alpha color inside rect
  geom_sf(data=poly1_bbox, fill=NA, color="red", linewidth = 0.7, linetype = "dashed") +
  geom_sf(data=poly2_bbox, fill=NA, color="red", linewidth = 0.7, linetype = "dashed") +
  geom_sf(data=sq_bbox, fill=NA, color="black", linewidth = 0.7)

ggplot() + 
  inlabru::gg(mesh.seg) +
  geom_sf(data =poly.rect_sf,
          col='black', alpha=1) + #alpha color inside rect
  geom_sf(data=sq_bbox, fill=NA, color="black", linewidth = 0.7) +
  geom_sf(data=poly1_bbox, color="black", linewidth = 0.7) +
  geom_sf(data=poly2_bbox, color="black", linewidth = 0.7) +
  ylim(c(3, 17)) +
  xlim(c(3, 17)) 
```


# MESH wiht almost triangular barriers
mesh.seg_h <- inla.mesh.2d(boundary = poly.water, #? has to have holes=F
                           interior = seg, 
                           max.e = max.edge.length, 
                           offset=1)
ggplot() + 
  inlabru::gg(mesh.seg_h)



########
```{r gifs2b, echo=FALSE, fig.cap="Two barriers scenario: row one shows the true simulated spatial field; and row two and three the spatial estimate for the transparent barrier model and the stationary model"}

#"480x480+000-300")
tf0.4 <- image_read("plots.now/w3r4seed602.flex2.n150/true.field.gif")
img_r1 <- image_append(image_scale(tf0.4, "x400"))
r1 <- image_crop(img_r1, "2000x400+000+00")

ps_bm0.4 <- image_read("plots.now/w3r4seed602.flex2.n150/pos.mean.gif")
ps_st0.4 <- image_read("plots.now/w3r4seed602.flex2.n150/stat.rnadom.mean.gif")


r2 <- image_append(image_scale(ps_bm0.4, "x400"))
r2 <- image_crop(r2, "2000x400+000+00")

r3 <- image_append(image_scale(ps_st0.4, "x400"))
r3 <- image_crop(r3, "2000x400+000+00")


img <- c(r1,r2,r3)

image_append(img, stack = TRUE)
```

```{r gifs1b, echo=FALSE, fig.cap="One barrier scenario: row one shows the true simulated spatial field; and row two and three the spatial estimate for the transparent barrier model and the stationary model"}

#"480x480+000-300")
tf0.4 <- image_read("plots.now/w3r4seed602.flex2.n150_1b/true.field.gif")
img_r1 <- image_append(image_scale(tf0.4, "x400"))
r1 <- image_crop(img_r1, "2000x400+000+00")

ps_bm0.4 <- image_read("plots.now/w3r4seed602.flex2.n150_1b/pos.mean.gif")
ps_st0.4 <- image_read("plots.now/w3r4seed602.flex2.n150_1b/stat.rnadom.mean.gif")


r2 <- image_append(image_scale(ps_bm0.4, "x400"))
r2 <- image_crop(r2, "2000x400+000+00")

r3 <- image_append(image_scale(ps_st0.4, "x400"))
r3 <- image_crop(r3, "2000x400+000+00")


img <- c(r1,r2,r3)
image_append(img, stack = TRUE)
```

```{r}
#choose a ref point

location <- matrix(c(c(6), 
                     c(12)), ncol = 2)
location.sp <- SpatialPoints(location)


## barrier area pair of points
y.up <- location[1,2]
y.low <- location[1,1]
A.tmp <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(y.low,y.up), nrow=1, ncol=2))

id.node = which.max(A.tmp[1, ])
id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])

gg.mesh.water +
  geom_sf(data = st_as_sf(SpatialPoints(
    matrix(c(5.890625, 11.871812), ncol = 2))), col = "red")
```


```{r}
prior.range = c(1,  0.5)
prior.sigma = c(1, 0.01)
range.fraction <- c(0.25, 0.25)

corr.covfx <- function(range.fraction = range.fraction,
                       id.node = id.node,
                       prior.range = prior.range) {
  
  barrier.model <- inla.barrier.pcmatern.plus(
    mesh = mesh,
    fem = fem,
    barrier.triangles = barrier.triangles,
    prior.range = prior.range,
    prior.sigma = prior.sigma,
    range.fraction = range.fraction)
  
  Q <- inla.rgeneric.q(
    barrier.model, 
    "Q",
    theta = c(log(prior.sigma[1]), 
              log(prior.range[1])))

  sd <- sqrt(diag(inla.qinv(Q)))
  Inode <- rep(0, dim(Q)[1])
  Inode[id.node] <- 1

  covar.column <- solve(Q, Inode)
  corr = drop(matrix(covar.column))/(sd*sd[id.node])
  cov = drop(matrix(covar.column))

  return.list <- list(corr = corr, cov = cov)
  return(return.list)
}

df4plot <- function(field, 
                    dims = 300,
                    id.coord = id.coord) {
  
  proj = inla.mesh.projector(mesh, xlim = xlim, 
                             ylim = ylim, dims=c(dims, dims))
  
  # Do the projection 
  field.proj = inla.mesh.project(proj, field)
  
  hilo <- list()
  for(i in 1:dims) {
    hilo[[i]] <- field.proj[,i]
  }
  
  hilo <- unlist(hilo)

  df <- cbind(proj$lattice$loc,
    sqrt((proj$lattice$loc[,1] - id.coord[[1]])^2 + (proj$lattice$loc[,2] - id.coord[[2]])^2),
    hilo)

  colnames(df) <- c("x", "y", "dist", "field")
  df <- as.data.frame(df)
  return(df)
}

corr.plots <- function(field, df,
                       xlim, ylim, zlim,
                       points = NULL,
                       filter = 0.2,
                       show.plot.field = TRUE,
                       plot.order = 1){
  
  if(show.plot.field == TRUE) {
    local.plot.field(field, mesh, 
                     xlim = xlim, 
                     ylim = ylim,
                     zlim = zlim)
    points(points)
  }
  
  df <- df %>% dplyr::filter(field > filter)
  
  if(plot.order == 1){
  gg <- ggplot(data = df, aes(x = field, y = dist)) +
    geom_line()
  }
  
  if(plot.order == 2){ 
  gg <- ggplot(data = df, aes(x = dist, y = field)) +
    geom_line()
  }
  
  return.list <- list(df = summary(df), gg = gg)
  return(return.list)
}
```


```{r}
b1 <- corr.covfx(range.fraction = c(.5,.5),
                id.node = id.node,
                prior.range = prior.range)
field <- b1$corr
b1.df <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

b1.plots <- corr.plots(field, df = b1.df,
                      xlim = c(3,17), 
                      ylim, zlim,
                      points = NULL,
                      filter = 0.2,
                      show.plot.field = F)
corr.plots(field, df = b1.df, xlim, ylim, zlim, filter = -1)

b1 <- corr.covfx(range.fraction = c(1,1),
                id.node = id.node,
                prior.range = prior.range)
field <- b1$corr
b1.df <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

b1.plots <- corr.plots(field, df = b1.df,
                      xlim = c(3,17), 
                      ylim, zlim,
                      points = NULL,
                      filter = 0.2,
                      show.plot.field = F)
corr.plots(field, df = b1.df, xlim, ylim, zlim, filter = -1)

b1 <- corr.covfx(range.fraction = c(.1,.1),
                id.node = id.node,
                prior.range = prior.range)
field <- b1$corr
b1.df <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

b1.plots <- corr.plots(field, df = b1.df,
                      xlim = c(3,17), 
                      ylim, zlim,
                      points = NULL,
                      filter = 0.2,
                      show.plot.field = F)
corr.plots(field, df = b1.df, xlim, ylim, zlim, filter = -1)

```


```{r}
# dims can be change for different resolution
local.plot.field = function(field, mesh, xlim, ylim, ...){
  # Error when using the wrong mesh
  stopifnot(length(field) == mesh$n)
  
  # Choose plotting region to be the same as the study area polygon
  if (missing(xlim)) xlim = poly.water@bbox[1, ] 
  if (missing(ylim)) ylim = poly.water@bbox[2, ]
  
  # Project the mesh onto a 300x300 grid
  proj = inla.mesh.projector(mesh, xlim = xlim, 
                             ylim = ylim, dims=c(300, 300))
  
  # Do the projection 
  field.proj = inla.mesh.project(proj, field)
  
  # Plot it
  image.plot(list(x = proj$x, y=proj$y, z = field.proj), 
             xlim = xlim, ylim = ylim, ...)  
}
local.plot.field(field, mesh, 
                     xlim = c(3,17), 
                     ylim = ylim,
                     zlim = zlim)
    points(points)
  
  
  df <- df %>% dplyr::filter(field > filter)
  
  if(plot.order == 1){
  gg <- ggplot(data = df, aes(x = field, y = dist)) +
    geom_line()
  }
  
  if(plot.order == 2){ 
  gg <- ggplot(data = df, aes(x = dist, y = field)) +
    geom_line()
  }
  

corr.plots(field, df = b1.df, xlim = c(3,17), ylim, zlim, filter = -1)
b1.plots
```