This was the first idea of transparency ratios

Whether the point should be taken at the edge or the middle is I think up to interpretation. 
I would think if one is thinking that the chance of crossing the barrier (because let's say the habitat conditions are worse there) is 20% I would choose a point at the edge because I'm wondering whether to "enter" the barrier area. 

Now, thinking about it, if I take an area to be stationary or in this case locally stationary the correlation vs distance plot shouldn't have much variation, and I should see a somewhat "clean" line. This same plot should have high variation when measured at a point close to the edge. This is due to the fact that the correlation at x distance to the right (normal area) and to the left (barrier area) won't be the same even though the distance is the same, i.e. we have really low correlation and high correlation at the same measured distance.

So now we can think of (correlation at) three points to compare: i) point at the middle of normal area; ii) point at the middle of barrier area; iii) point at the edge. 
Note that I am not taking the correlation between a pair of points rather one point and the entire correlation vs distance distribution.

As a first approach for this new idea, I will just play with the prior range, and leaving all the range fractions at 1. This is just to visualize this "clean" curves in their "cleanest" way. For this I only need one point since I am not using any barriers around.
Next, I will play around changing the range fractions and locations of points. Mainly locations at the different sides of the edge.

Do several trials of the previous ideas to show this works for more than one example by coincidence.

(Expected) Results
+ this shouldn't depend on the geometry of the barrier because I am not measuring how much of this correlation is changing (kind of like the mass of the correlation that is shifting), rather only the fact that it is shifting. The fact that it is shifting indicates a barrier independant of the area of the barrier.
+ clean curves inside the locally stationary areas, noisy curves close to the edge.
+ noise at the edge will be proportional to the range fraction at correlation 0.2
+ If I want to increase the noise at a given distance then I might need to measure the correlation at that distance as if everything was normal area, do the corr ratio and fin an r thta will give that noise (at that distance).
+ When might this be helpful? When I want to increase the noise at a distance much closer than when correlation is 0.2. For example, if i have this 20% case, then I will want to increase the noise 80% at the distance from the edge I am choosing my measuring point.  
The reason for this, is that if the chances are 20% of what they use to cross to certain area, then the "clean" curve should move 80%. Note that the curve consider all correlation around my desired point, hence the curve will contain the normal area correlation and the barrier area correlations, that's why I will get a super noisy curve.


More on the latter,
Following this noisy curve idea, why would I want this to happen before 0.2 correlation?
i.e. why would I want to the noise before 0.2 corr.

Let's say the correlation is 0.2 at a distance $d_1 = 15m$. When I add noise by changing the range I will get correlation values of 0.2 at 5m too (look at the following example plots) but is this what I want?

Not really, I don't want the correlation to drop if I'm 15m away from the barrier, I want the correlation to drop at the edge. On other words I don't want to see a correlation decay before it hits the barrier.
I still have to find what kind of ratio will give me this result but this is the main idea. Maybe the ratio is still the same at corr 0.8, and it is not only true at 0.2. The latter is more or less obvious from the plots.

Maybe it is worth thinking what happens from the edge out instead of from the normal area to the barrier. It's worth mentioning that multiplying the range in the normal area instead of doing a fraction on the barrier area worked well on the proposal. This would mean thinking of the barrier as a reference area and then the normal area as a "better" area with higher range.

It's also worth noting that points close to the barrier will have less interference from other barriers with different ranges. Barriers with the same range won't interfere since the noise produced will be the same. Still the curve considering the correlation as if there were no barrier $b_2$ is inherently considering some of the noise of the permanent barrier $b_1$


The next is organized as follows: 
`range.fraction = c(fraction normal area, range.fraction b1, range.fraction b1)*prior.range[1]`
The fraction for the normal area is 1, here we will modify it just to prove our point.

i) `range.fraction = c(1, 1, 1)` for all barriers so there are no barriers in practice and the range is equal to the prior range everywhere.
ii) `range.fraction = c(0.3, 0.3, 0.3)` for all normal and barrier area, so in practice there will be no barriers just a normal area 0.3 of the prior range from i).
iii) `range.fraction = c(1, 1, 0.3)` the barrier 2 scenario -with $r_{b_1} = 1$, so basically no barrier 1.- This plot should be a combination of plots i) and ii).
iv) `range.fraction = c(1, 0.01, 0.3)` the actual barrier scenario with both fractions for $b_1$ and $b_2$.
v) `range.fraction = c(1, 0.01, 1)` the barrier scenario just accounting for barrier 1, just to check how it affects the noise of the normal area.

After the plots:
Maybe it's worth exploring the distribution of the maximum and the minimum correlation vs the distance


```{r}
#choose a ref point
gg_mesh.bars +
  xlim(c(-950, -900)) +
  ylim(c(2870,2890))

gg_mesh.bars +
  xlim(c(-925, -915)) +
  ylim(c(2874,2878))

location <- matrix(c(c(-918), 
                     c(2877)), ncol = 2)
location.sp <- SpatialPoints(location, proj4string = crs_km)

gg_mesh.bars +
  geom_sf(data = st_as_sf(location.sp), col = "red") +
  xlim(c(-925, -915)) +
  ylim(c(2874,2878))

mesh <- mesh.dng
## barrier area pair of points
y.up <- location[1,2]
y.low <- location[1,1]
A.tmp <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(y.low,y.up), nrow=1, ncol=2))

id.node = which.max(A.tmp[1, ])
id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])

gg_mesh.bars +
  geom_sf(data = st_as_sf(SpatialPoints(
    matrix(c(c(-917.986), c(2876.862)), ncol = 2), proj4string = crs_km)), col = "red") +
  xlim(c(-925, -915)) +
  ylim(c(2874,2878))
```

```{r}
# dims can be change for different resolution
local.plot.field = function(field, mesh, xlim, ylim, ...){
  # Error when using the wrong mesh
  stopifnot(length(field) == mesh$n)
  
  # Choose plotting region to be the same as the study area polygon
  if (missing(xlim)) xlim = poly.water@bbox[1, ] 
  if (missing(ylim)) ylim = poly.water@bbox[2, ]
  
  # Project the mesh onto a 300x300 grid
  proj = inla.mesh.projector(mesh, xlim = xlim, 
                             ylim = ylim, dims=c(300, 300))
  
  # Do the projection 
  field.proj = inla.mesh.project(proj, field)
  
  # Plot it
  image.plot(list(x = proj$x, y=proj$y, z = field.proj), 
             xlim = xlim, ylim = ylim, ...)  
}
```

```{r}
prior.range = c(21.0,  0.5)
prior.sigma = c(3.00, 0.01)

corr.covfx <- function(range.fraction = range.fraction,
                       id.node = id.node,
                       prior.range = prior.range) {
  
  barrier.model <- inla.barrier.pcmatern.plus(
    mesh = mesh,
    fem = fem,
    barrier.triangles = barrier.triangles,
    prior.range = prior.range,
    prior.sigma = prior.sigma,
    range.fraction = range.fraction)
  
  Q <- inla.rgeneric.q(
    barrier.model, 
    "Q",
    theta = c(log(prior.sigma[1]), 
              log(prior.range[1])))

  sd <- sqrt(diag(inla.qinv(Q)))
  Inode <- rep(0, dim(Q)[1])
  Inode[id.node] <- 1

  covar.column <- solve(Q, Inode)
  corr = drop(matrix(covar.column))/(sd*sd[id.node])
  cov = drop(matrix(covar.column))

  return.list <- list(corr = corr, cov = cov)
  return(return.list)
}

df4plot <- function(field, 
                    dims = 300,
                    id.coord = id.coord) {
  
  proj = inla.mesh.projector(mesh, xlim = xlim, 
                             ylim = ylim, dims=c(dims, dims))
  
  # Do the projection 
  field.proj = inla.mesh.project(proj, field)
  
  hilo <- list()
  for(i in 1:dims) {
    hilo[[i]] <- field.proj[,i]
  }
  
  hilo <- unlist(hilo)

  df <- cbind(proj$lattice$loc,
    sqrt((proj$lattice$loc[,1] - id.coord[[1]])^2 + (proj$lattice$loc[,2] - id.coord[[2]])^2),
    hilo)

  colnames(df) <- c("x", "y", "dist", "field")
  df <- as.data.frame(df)
  return(df)
}

corr.plots <- function(field, df,
                       xlim, ylim, zlim,
                       points = NULL,
                       filter = 0.2,
                       show.plot.field = TRUE,
                       plot.order = 1){
  
  if(show.plot.field == TRUE) {
    local.plot.field(field, mesh, 
                     xlim = xlim, 
                     ylim = ylim,
                     zlim = zlim)
    points(points)
  }
  
  df <- df %>% dplyr::filter(field > filter)
  
  if(plot.order == 1){
  gg <- ggplot(data = df, aes(x = field, y = dist)) +
    geom_line()
  }
  
  if(plot.order == 2){ 
  gg <- ggplot(data = df, aes(x = dist, y = field)) +
    geom_line()
  }
  
  return.list <- list(df = summary(df), gg = gg)
  return(return.list)
}
```

```{r}
range.fraction <- c(1, 1)
i <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- i$corr
i.df <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

xlim = (c(-950, -900))
ylim = (c(2870,2890))
zlim = c(0.1,1)
#zlim = c(0.1, 1)
#xlim = poly.water@bbox[1, ] 
#ylim = poly.water@bbox[2, ]

i.plots <- corr.plots(field, df = i.df,
                      xlim, ylim, zlim,
                      points = NULL,
                      filter = 0.2,
                      show.plot.field = F)

corr.plots(field, df = i.df, xlim, ylim, zlim, filter = -1)
i.plots
```


```{r}
prior.range <- c(21.0*0.3,  0.5)
range.fraction <- c(1, 1)
ii <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- ii$corr
ii.df <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

ii.plots <- corr.plots(field, df = ii.df,
                      xlim, ylim, zlim,
                      points = NULL,
                      filter = 0.2,
                      show.plot.field = F)

corr.plots(field, df = ii.df, xlim, ylim, zlim, filter = -1)
ii.plots
```


```{r}
prior.range <- c(21.0,  0.5)
range.fraction <- c(1, 0.3)
iii <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- iii$corr
iii.df <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

iii.plots <- corr.plots(field, df = iii.df,
                      xlim, ylim, zlim,
                      points = NULL,
                      filter = 0.2,
                      show.plot.field = F)

corr.plots(field, df = iii.df, xlim, ylim, zlim, filter = -1)
iii.plots
```

```{r}
prior.range <- c(21.0,  0.5)
range.fraction <- c(0.01, 0.3)
iv <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- iv$corr
iv.df <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

iv.plots <- corr.plots(field, df = iv.df,
                      xlim, ylim, zlim,
                      points = NULL,
                      filter = 0.2,
                      show.plot.field = F)

corr.plots(field, df = iv.df, xlim, ylim, zlim, filter = -1)
iv.plots
```

```{r}
prior.range <- c(21.0,  0.5)
range.fraction <- c(0.01, 1)
v <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- v$corr
v.df <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

v.plots <- corr.plots(field, df = v.df,
                      xlim, ylim, zlim,
                      points = NULL,
                      filter = 0.2,
                      show.plot.field = F)

corr.plots(field, df = v.df, xlim, ylim, zlim, filter = -1)
v.plots
```

# Results

When comparing the summary tables of all the cases  without filtering the correlation we see the summary of the distance is the same with all the range fraction variations, meaning it's not only being affected by 0.3, but 0.1 is affecting the same way as 0.3.

I also notice that 0.01 affects the field variation at low correlation but starts disappearing after ~0.5. It makes sense since that barrier is not close to the reference point so it will only affect distant (low correlated) points. This proves that we need to work with high corr part of the field if there are barriers with different ranges around so that the noise we see is actually from the barrier we want and not other neighbors. This also means we need points at the edge of the barrier i am trying to find the range for.

Now, to get this kind of range of noise i am talking about I need (when I have the mix of range) not to only look at the max but now at the max and minimum distance for a give correlation, e.g. the maximum distance I will get a correlation of let's say 0.6, and the minimum distance I will get a correlation fo 0.6. It like looking at a range (in the difference on the y axis sense not in the range parameter sense).
At least when filtering corr > 0.2 for  the i) and ii) case the 0.3 proportion from one case to another holds for the max, 3rd q, mean, median, and so on... so I would guess making the cut at 0.6 instead of 0.2 will still be valid but I have to check.

Before making the cuts, I need to compare this maximum and minimum I mentioned before.

Once I have the range (on the y axis not the hyperparameter) get the ratio and then do the optimization that gives me the range for that ratio, moving along side the barrier shouldn't change this ratio if I choose points close enough to the barrier.

From the plots on the supplementary section I can see that obviously I will have little obs at 15m distance because I am lowering the range.
I can get the ratio from the range on the y axis considering a distance ratio or a correlation ratio, it's just like imagining a ratio on whatever I put on the y-axis.

Steps to get the ratios (whichever I choose) -let's work with example iv) first-.
  + redo the plots just to take a closer look at the options (supplementary section)
  + correlation values are not duplicated, but the differences are at e^-5
  + after looking at the plots (at the end, supplementary section) I think I can make decent correlation categories by = 0.0001
  
```{r}
corr.cat <- seq(0, 1, by = 0.01) #corr category 
df.corr.cat <- list() #each category will be a df in a list
for (i in 1:(length(corr.cat)-1)) {
  df.corr.cat[[i]] <- iv.df %>% dplyr::filter(field >= corr.cat[i] & field < corr.cat[i+1])
}
#str(df.corr.cat)

df.clist <- list()
for (i in 1:(length(corr.cat)-1)) { #length(df.corr.cat)
  max <- rep(max(df.corr.cat[[i]]$dist), dim(df.corr.cat[[i]])[1]) #ccat from corr.cat
  min <- rep(min(df.corr.cat[[i]]$dist), dim(df.corr.cat[[i]])[1])
  cat <- rep(corr.cat[i+1], dim(df.corr.cat[[i]])[1])
  df.clist[[i]] <- cbind(df.corr.cat[[i]], max, min, cat)
}

# I need to bind the lists so it's one data frame for ggplot
df.c <- df.clist[[1]]
for (i in 2:(length(corr.cat)-1)) {
  df.c <- rbind(df.c, df.clist[[i]])
}

ggplot(data = df.c, aes(x = field, y = dist)) +
    geom_line(linewidth = 0.1, alpha = 0.5) +
    geom_point(aes(x = cat, y = max), colour = "red1") +
    geom_point(aes(x = cat, y = min), colour = "orange1")
```

```{r}
df.c2 <- df.c %>% 
  dplyr::mutate(dist.max.3 = max*0.3,
                dist.range = (max - min),
                dist.range.3 = (max - min)*0.3,
                minmax = min/max)
df.c2 <- df.c2 %>% dplyr::mutate(per = dist.range/max)

ggplot(data = df.c2, aes(x = field, y = dist)) +
    geom_line(linewidth = 0.1, alpha = 0.5) +
    geom_point(aes(x = cat, y = max), colour = "red1") +
    geom_point(aes(x = cat, y = min), colour = "orange1") +
    geom_point(aes(x = cat, y = dist.max.3), colour = "green2") +
    geom_point(aes(x = cat, y = dist.range), colour = "cyan1") +
    #geom_point(aes(x = cat, y = dist.range.3), colour = "yellow1") +
    #geom_point(aes(x = cat, y = minmax), colour = "yellow1") +
    geom_point(aes(x = cat, y = per), colour = "yellow1") +
    geom_line(data = v.df, aes(x = field, y = dist),
              alpha = 0.1, colour = "lightblue") 
    
summary(df.c2)
```

Now v is the reference case, i.e. the results as if there was no barrier.

```{r}
corr.cat <- seq(0, 1, by = 0.01) #corr category 
df.corr.cat <- list() #each category will be a df in a list
for (i in 1:(length(corr.cat)-1)) {
  df.corr.cat[[i]] <- v.df %>% dplyr::filter(field >= corr.cat[i] & field < corr.cat[i+1])
}
#str(df.corr.cat)

df.clist <- list()
for (i in 1:(length(corr.cat)-1)) { #length(df.corr.cat)
  max <- rep(max(df.corr.cat[[i]]$dist), dim(df.corr.cat[[i]])[1]) #ccat from corr.cat
  min <- rep(min(df.corr.cat[[i]]$dist), dim(df.corr.cat[[i]])[1])
  cat <- rep(corr.cat[i+1], dim(df.corr.cat[[i]])[1])
  df.clist[[i]] <- cbind(df.corr.cat[[i]], max, min, cat)
}

# I need to bind the lists so it's one data frame for ggplot
df.c.v <- df.clist[[1]]
for (i in 2:(length(corr.cat)-1)) {
  df.c.v <- rbind(df.c.v, df.clist[[i]])
}

ggplot(data = df.c.v, aes(x = field, y = dist)) +
    geom_line(linewidth = 0.1, alpha = 0.5) +
    geom_point(aes(x = cat, y = max), colour = "red1") +
    geom_point(aes(x = cat, y = min), colour = "orange1")
```
```{r}
df.cv2 <- df.c.v %>% 
  dplyr::mutate(dist.max.3 = max*0.3,
                dist.range = (max - min),
                dist.range.3 = (max - min)*0.3,
                minmax = min/max)
df.cv2 <- df.cv2 %>% dplyr::mutate(per = dist.range/max)

df.c2.75 <- df.c2 %>% dplyr::filter(field >= 0.75)
df.cv2.75 <- df.cv2 %>% dplyr::filter(field >= 0.75)

ggplot(data = df.c2.75, aes(x = field, y = dist)) +
    geom_line(linewidth = 0.5, alpha = 0.5) +
    geom_point(aes(x = cat, y = max), colour = "red1") +
    geom_point(aes(x = cat, y = min), colour = "orange1") +
    geom_point(aes(x = cat, y = dist.max.3), colour = "green2") +
    geom_point(aes(x = cat, y = dist.range), colour = "cyan1") +
    #geom_point(aes(x = cat, y = dist.range.3), colour = "yellow1") +
    #geom_point(aes(x = cat, y = minmax), colour = "yellow1") +
    geom_point(aes(x = cat, y = per), colour = "yellow1") +
    geom_line(data = df.cv2.75, aes(x = field, y = dist),
              alpha = 0.8, colour = "lightblue") +

    geom_point(data = df.cv2.75, aes(x = cat, y = max), colour = "red1", shape = 8) +
    geom_point(data = df.cv2.75, aes(x = cat, y = min), colour = "orange1", shape = 8) +
    geom_point(data = df.cv2.75, aes(x = cat, y = dist.max.3), colour = "green2", shape = 8) +
    geom_point(data = df.cv2.75, aes(x = cat, y = dist.range), colour = "cyan1", shape = 8) +
    geom_point(data = df.cv2.75, aes(x = cat, y = per), colour = "yellow1", shape = 8) 



```
Range on y axis of the barrier over the reference is kinda stable ish, this could be my ratio 

```{r}
summary(df.c2.75)
summary(df.cv2.75)

data.frame(dist.range.v = unique(df.cv2.75$dist.range),
           dist.range.iv = unique(df.c2.75$dist.range), 
           
           iv.div.v = (unique(df.cv2.75$dist.range)/(unique(df.c2.75$dist.range))),
           dist.min.v = unique(df.cv2.75$min),
           dist.min.iv = unique(df.c2.75$min),
           dist.max.v = unique(df.cv2.75$max),
           dist.max.iv = unique(df.c2.75$max))

df.iv.div.v <- data.frame(y = (unique(df.cv2.75$dist.range)/(unique(df.c2.75$dist.range))),
                          x = unique(df.c2.75$cat))


ggplot(data = df.c2.75, aes(x = field, y = dist)) +
    geom_line(aes(x = cat, y = max), colour = "red1") +
    geom_line(aes(x = cat, y = min), colour = "orange1") +
    geom_line(aes(x = cat, y = dist.range), colour = "cyan1") +
    geom_line(data = df.cv2.75, aes(x = cat, y = max), colour = "red1", shape = 8) +
    geom_line(data = df.cv2.75, aes(x = cat, y = min), colour = "orange1", shape = 8) +
    geom_line(data = df.cv2.75, aes(x = cat, y = dist.range), colour = "cyan1", shape = 8) +
    geom_line(data = df.iv.div.v, aes(x = x, y = y), colour = "yellow1", shape = 8) 

```

```{r}
data.frame(dist.range.v = unique(df.cv2.75$dist.range),
           dist.range.iv = unique(df.c2.75$dist.range), 
           
           v.div.iv = (unique(df.cv2.75$dist.range)/(unique(df.c2.75$dist.range))),
           dist.min.v = unique(df.cv2.75$min),
           dist.min.iv = unique(df.c2.75$min),
           dist.max.v = unique(df.cv2.75$max),
           dist.max.iv = unique(df.c2.75$max))

data.frame(dist.min.v = unique(df.cv2.75$min),
           dist.min.iv = unique(df.c2.75$min), 
           
           v.div.iv = (unique(df.cv2.75$min)/(unique(df.c2.75$min))),
           iv.div.v = (unique(df.c2.75$min)/(unique(df.cv2.75$min))))
```

All the same but field in the y axis by distance on the x axis

```{r}
corr.plots(field, df = i.df, xlim, ylim, zlim, filter = 0.1,
           show.plot.field = F,
           plot.order = 2)
corr.plots(field, df = ii.df, xlim, ylim, zlim, filter = 0.1,
           show.plot.field = F,
           plot.order = 2)
corr.plots(field, df = iii.df, xlim, ylim, zlim, filter = 0.1,
           show.plot.field = F,
           plot.order = 2)
corr.plots(field, df = iv.df, xlim, ylim, zlim, filter = 0.1,
           show.plot.field = F,
           plot.order = 2)
corr.plots(field, df = v.df, xlim, ylim, zlim, filter = 0.1,
           show.plot.field = F,
           plot.order = 2)
```

```{r}
iv.dfilter.1 <- iv.df %>% dplyr::filter(field > 0.1)
df <- iv.dfilter.1
f <- floor(min(df$dist))
c <- ceiling(max(df$dist))
dist.cat <- seq(f, c, by = 0.1)

df.dcat <- list() #each distance category (dcat) will be a df in a list
for (i in 1:(length(dist.cat)-1)) {
  df.dcat[[i]] <- df %>% dplyr::filter(dist >= dist.cat[i] & dist < dist.cat[i+1])
}

df.dlist <- list()
for (i in 1:(length(dist.cat)-1)) { #length(dist.dcat)
  max <- rep(max(df.dcat[[i]]$field), dim(df.dcat[[i]])[1]) #ccat from corr.cat
  min <- rep(min(df.dcat[[i]]$field), dim(df.dcat[[i]])[1])
  cat <- rep(dist.cat[i+1], dim(df.dcat[[i]])[1])
  df.dlist[[i]] <- cbind(df.dcat[[i]], max, min, cat)
}

# I need to bind the lists so it's one data frame for ggplot
df.d <- df.dlist[[1]]
for (i in 2:(length(dist.cat)-1)) {
  df.d <- rbind(df.d, df.dlist[[i]])
}

ggplot(data = df.d, aes(x = dist, y = field)) +
    geom_line(linewidth = 0.1, alpha = 0.5) +
    geom_point(aes(x = cat, y = max), colour = "red1") +
    geom_point(aes(x = cat, y = min), colour = "orange1")
```

```{r}
df.d2 <- df.d %>% 
  dplyr::mutate(field.range = (max - min),
                field.mean =(max+min)/2,
                minmax = min/max)
df.d2 <- df.d2 %>% dplyr::mutate(a = minmax*field.mean,
                                 b = minmax*field.range)

v.dfilter.1 <- v.df %>% dplyr::filter(field > 0.1)
ggplot(data = df.d2, aes(x = dist, y = field)) +
    geom_line(linewidth = 0.1, alpha = 0.5) +
    geom_point(aes(x = cat, y = max), colour = "red1") +
    geom_point(aes(x = cat, y = min), colour = "orange1") +
    #geom_point(aes(x = cat, y = field.range), colour = "green1") +
    geom_point(aes(x = cat, y = field.mean), colour = "cyan1") +
    geom_point(aes(x = cat, y = minmax), colour = "yellow1") +
    #geom_point(aes(x = cat, y = b), colour = "pink1") +
    geom_line(data = v.dfilter.1, aes(x = dist, y = field),
              alpha = 0.2, colour = "lightblue") 

summary(df.d2)
```


```{r}
v.dfilter.1 <- v.df %>% dplyr::filter(field > 0.1)
df <- v.dfilter.1
f <- floor(min(df$dist))
c <- ceiling(max(df$dist))
dist.cat <- seq(f, c, by = 0.1)

df.dcat <- list() #each distance category (dcat) will be a df in a list
for (i in 1:(length(dist.cat)-1)) {
  df.dcat[[i]] <- df %>% dplyr::filter(dist >= dist.cat[i] & dist < dist.cat[i+1])
}

df.dlist <- list()
for (i in 1:(length(dist.cat)-1)) { #length(dist.dcat)
  max <- rep(max(df.dcat[[i]]$field), dim(df.dcat[[i]])[1]) #ccat from corr.cat
  min <- rep(min(df.dcat[[i]]$field), dim(df.dcat[[i]])[1])
  cat <- rep(dist.cat[i+1], dim(df.dcat[[i]])[1])
  df.dlist[[i]] <- cbind(df.dcat[[i]], max, min, cat)
}

# I need to bind the lists so it's one data frame for ggplot
df.d.v <- df.dlist[[1]]
for (i in 2:(length(dist.cat)-1)) {
  df.d.v <- rbind(df.d.v, df.dlist[[i]])
}

ggplot(data = df.d.v, aes(x = dist, y = field)) +
    geom_line(linewidth = 0.1, alpha = 0.5) +
    geom_point(aes(x = cat, y = max), colour = "red1") +
    geom_point(aes(x = cat, y = min), colour = "orange1")

``` 

```{r}
df.dv2 <- df.d.v %>% 
  dplyr::mutate(field.range = (max - min),
                field.mean =(max+min)/2,
                minmax = min/max)
df.dv2 <- df.dv2 %>% dplyr::mutate(a = minmax*field.mean,
                                 b = minmax*field.range)

ggplot(data = df.d2, aes(x = dist, y = field)) +
    geom_line(linewidth = 0.1, alpha = 0.5) +
    geom_point(aes(x = cat, y = max), colour = "red1") +
    geom_point(aes(x = cat, y = min), colour = "orange1") +
    geom_line(data = df.dv2, aes(x = dist, y = field),
            alpha = 0.8, colour = "lightblue") 

df.d2.5 <- df.d2 %>% dplyr::filter(dist <= 5)
df.dv2.5 <- df.dv2 %>% dplyr::filter(dist <= 5)

ggplot(data = df.d2.5, aes(x = dist, y = field)) +
    geom_line(linewidth = 0.1, alpha = 0.5) +
    geom_point(aes(x = cat, y = max), colour = "red1") +
    geom_point(aes(x = cat, y = min), colour = "orange1") +
    geom_point(aes(x = cat, y = field.range), colour = "cyan1") +
    geom_point(aes(x = cat, y = minmax), colour = "green1") +

    geom_point(data = df.dv2.5, aes(x = cat, y = max), colour = "red1", shape = 8) +
    geom_point(data = df.dv2.5, aes(x = cat, y = min), colour = "orange1", shape = 8) +
    geom_point(data = df.dv2.5, aes(x = cat, y = field.range), colour = "cyan1", shape = 8) +
    geom_point(data = df.dv2.5, aes(x = cat, y = minmax), colour = "green2", shape = 8)



```

```{r}
df.d.ratios <- data.frame(cat = unique(df.dv2.5$cat),
  field.range.v = unique(df.dv2.5$field.range),
  field.range.iv = unique(df.d2.5$field.range), 
  range.ratio.inv = (unique(df.dv2.5$field.range)/(unique(df.d2.5$field.range))),
  range.ratio = (unique(df.d2.5$field.range)/unique(df.dv2.5$cat)),
  field.min.v = unique(df.dv2.5$min),
  field.min.iv = unique(df.d2.5$min), 
  min.ratio.inv = (unique(df.dv2.5$min)/(unique(df.d2.5$min))),
  min.ratio  = (unique(df.d2.5$min)/(unique(df.dv2.5$min))),
  field.max.v = unique(df.dv2.5$max),
  field.max.iv = unique(df.d2.5$max),
  minmax.v = unique(df.dv2.5$minmax),
  minmax.iv = unique(df.d2.5$minmax), 
  minmax.ratio = unique(df.d2.5$minmax)/unique(df.dv2.5$minmax))

df.d.ratios %>% 
```
```{r}
# after all the data frames and possible ratios this could be the best:
df.ratio <- 
  data.frame(corr.cat = unique(df.cv2.75$cat),
             dist.range.ratio.v.iv = 
               (unique(df.cv2.75$dist.range)/(unique(df.c2.75$dist.range))),
             corr.by.ratio = 
               (unique(df.cv2.75$dist.range)/unique(df.c2.75$dist.range))*unique(df.cv2.75$cat),
             sum.v = (unique(df.cv2.75$min) + unique(df.cv2.75$max)),
             sum.iv = (unique(df.c2.75$min) + unique(df.c2.75$max)),
             iv.div.v = (unique(df.c2.75$min) + unique(df.c2.75$max))/(unique(df.cv2.75$min) + unique(df.cv2.75$max)))

df.ratio %>% dplyr::mutate(ratio2 = dist.range.ratio.v.iv/iv.div.v)

df.ratio %>% dplyr::mutate(fisher = 0.5*log((1+corr.cat)/(1-corr.cat))) %>% 
  dplyr::mutate(ratio2 = dist.range.ratio.v.iv*fisher) 

df.ratio2 <- df.ratio %>% dplyr::mutate(fisher = 0.5*log((1+corr.cat)/(1-corr.cat))) %>% 
  dplyr::mutate(ratio2 = dist.range.ratio.v.iv*fisher,
                ratio3 = dist.range.ratio.v.iv/fisher,
                ratio1 = dist.range.ratio.v.iv/iv.div.v) %>% 
  dplyr::filter(corr.cat != 1)


ggplot(data = df.ratio2, aes(x = field, y = dist)) +
    geom_line(aes(x = corr.cat, y = dist.range.ratio.v.iv), colour = "red1") +
    geom_line(aes(x = corr.cat, y = corr.by.ratio), colour = "orange1") +
    geom_line(aes(x = corr.cat, y = ratio1), colour = "cyan1") +
    geom_line(aes(x = corr.cat, y = fisher), colour = "yellow1") +
    geom_line(aes(x = corr.cat, y = ratio2), colour = "green1") +
    geom_line(aes(x = corr.cat, y = ratio3), colour = "pink1")

summary(df.ratio2)
```

What I kinda want to say is:
1. the expert says there's 30% chance of the Dugong being in deep sea $b_2$.
2. i will change the correlation structure of one point (close to the edge between the normal area and $b_2$) with respect to all of the other points by modifying the range fraction inside $b_2$

3. i will compare somehow what happens when there's no barrier vs what happens when there is a barrier
3.1. I start by getting the correlation with respect to that point when there's no barrier, and project it onto the map getting a squared matrix with dim = zlim.
3.2. Get the correlation with $b_2$, and project it onto the map getting a squared matrix with dim = zlim.

4. Now, I want to get a measure of the difference between the case with only normal area and the case where there's a barrier.
5. One way of putting a number on the dissimilarity between 2 matrices is $s = 1- \frac{||A-B||_F}{||A||_F + ||B||_F}$

6. Since I want the chance inside to be 30% I could say that the dissimilarity should be close to 70%, and $\frac{||A-B||_F}{||A||_F + ||B||_F}$ should be close to 0.3

7. transparency could be $\frac{||A-B||_F}{||A||_F + ||B||_F} = 1-c$ with $c$ the variation I want (70%)

Does it work in other cases? nope

I need to take max and min correlation (or max and min distance), the entire matrix will of course not work because it depends on the area of the barrier
Keep in mind I want to "extend" what happens at the edge of the barrier to the entire barrier, meaning the knowledge I have is about the edge

```{r}
range.fraction <- c(0.01, 0.3)
iv <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)

range.fraction <- c(0.01, 1)
v <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)

A <- inla.mesh.project(proj, v$corr)
A[is.na(A)] <- 0
A[which(A < 0.8)] <- 0
Af <- norm(A, "F")

B <- inla.mesh.project(proj, iv$corr)
B[is.na(B)] <- 0
B[which(B < 0.8)] <- 0
Bf <- norm(B, "F")

A_B <- A-B
A_Bf <- norm(A_B, "F")
1-(A_Bf/(Af+Bf)) #0.665688
(A_Bf/(Af+Bf)) #0.334312

```
```{r}
range.fraction <- c(0.01, 0.5)
iv_ <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)

range.fraction <- c(0.01, 1)
v_ <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)

A <- inla.mesh.project(proj, v_$corr)
A[is.na(A)] <- 0
A[which(A < 0.9)] <- 0
Af <- norm(A, "F")

B <- inla.mesh.project(proj, iv_$corr)
B[is.na(B)] <- 0
B[which(B < 0.9)] <- 0
Bf <- norm(B, "F")

A_B <- A-B
A_Bf <- norm(A_B, "F")
1-(A_Bf/(Af+Bf)) #0.6855269
(A_Bf/(Af+Bf)) #0.3144731
```


```{r}
s <- 0.9+0.8+0.5+0.2 
0.9*100/2.4
```
```{r}
corr.plots(field, df = i.df, xlim, ylim, zlim, filter = 0.1,
           show.plot.field = F,
           plot.order = 2)
corr.plots(field, df = ii.df, xlim, ylim, zlim, filter = 0.1,
           show.plot.field = F,
           plot.order = 2)
corr.plots(field, df = iii.df, xlim, ylim, zlim, filter = 0.1,
           show.plot.field = F,
           plot.order = 2)
corr.plots(field, df = iv.df, xlim, ylim, zlim, filter = 0.1,
           show.plot.field = F,
           plot.order = 2)
corr.plots(field, df = v.df, xlim, ylim, zlim, filter = 0.1,
           show.plot.field = F,
           plot.order = 2)

i.df <- i.df %>% mutate(ln.field = log(field))
ii.df <- ii.df %>% mutate(ln.field = log(field))
i.df <- i.df %>% mutate(ln.field = ln(field))

ggplot(data = i.df, aes(x = dist, y = field)) +
  geom_line(data = iii.df, aes(x = dist, y = field), color = "red1", alpha = 1) +
  geom_line(data = iv.df, aes(x = dist, y = field), color = "blue1", alpha = 0.5) +
  geom_line(data = v.df, aes(x = dist, y = field), color = "lightblue1", alpha = 0.8) +
  geom_line() +
  geom_line(data = ii.df, aes(x = dist, y = field)) +
  ylim(c(0.5,1)) + xlim(c(0,10))



```
```{r}
prior.sigma = c(3.00, 0.01)
xlim = (c(-950, -900))
ylim = (c(2870,2890))
zlim = c(0.1,1)
##i
i <- list()
i.df <- list()
prior.range <- c(21,  0.5)
range.fraction <- c(1, 1)
i[[1]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- i[[1]]$corr
i.df[[1]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

#ii
ii <- list()
ii.df <- list()
prior.range <- c(21.0*0.3,  0.5)
range.fraction <- c(1, 1)
ii[[1]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- ii[[1]]$corr
ii.df[[1]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
##iii
iii <- list()
iii.df <- list()
prior.range <- c(21.0,  0.5)
range.fraction <- c(1, 0.3)
iii[[1]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- iii[[1]]$corr
iii.df[[1]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
#iv
iv <- list()
iv.df <- list()
prior.range <- c(21.0,  0.5)
range.fraction <- c(0.01, 0.3)
iv[[1]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- iv[[1]]$corr
iv.df[[1]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
##v
v <- list()
v.df <- list()
prior.range <- c(21.0,  0.5)
range.fraction <- c(0.01, 1)
v[[1]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- v[[1]]$corr
v.df[[1]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

ggplot(data = i.df[[1]], aes(x = dist, y = field)) +
  geom_line(data = iii.df[[1]], aes(x = dist, y = field), color = "red1", alpha = 1) +
  geom_line(data = iv.df[[1]], aes(x = dist, y = field), color = "blue1", alpha = 0.5) +
  geom_line(data = v.df[[1]], aes(x = dist, y = field), color = "lightblue1", alpha = 0.8) +
  geom_line() +
  geom_line(data = ii.df[[1]], aes(x = dist, y = field)) +
  ylim(c(0.5,1)) + xlim(c(0,10))
```

```{r}
##i
prior.range <- c(21,  0.5)
range.fraction <- c(1, 1)
i[[2]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- i[[2]]$corr
i.df[[2]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

#ii
prior.range <- c(21.0*0.5,  0.5)
range.fraction <- c(1, 1)
ii[[2]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- ii[[2]]$corr
ii.df[[2]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
##iii
prior.range <- c(21.0,  0.5)
range.fraction <- c(1, 0.5)
iii[[2]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- iii[[2]]$corr
iii.df[[2]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
#iv
prior.range <- c(21.0,  0.5)
range.fraction <- c(0.01, 0.5)
iv[[2]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- iv[[2]]$corr
iv.df[[2]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
##v
prior.range <- c(21.0,  0.5)
range.fraction <- c(0.01, 1)
v[[2]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- v[[2]]$corr
v.df[[2]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

ggplot(data = i.df[[2]], aes(x = dist, y = field)) +
  geom_line(data = iii.df[[2]], aes(x = dist, y = field), color = "red1", alpha = 1) +
  geom_line(data = iv.df[[2]], aes(x = dist, y = field), color = "blue1", alpha = 0.5) +
  geom_line(data = v.df[[2]], aes(x = dist, y = field), color = "lightblue1", alpha = 0.8) +
  geom_line() +
  geom_line(data = ii.df[[2]], aes(x = dist, y = field)) +
  ylim(c(0.5,1)) + xlim(c(0,10))
```
```{r}
##i
prior.range <- c(21,  0.5)
range.fraction <- c(1, 1)
i[[3]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- i[[3]]$corr
i.df[[3]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

#ii
prior.range <- c(21.0*0.8,  0.5)
range.fraction <- c(1, 1)
ii[[3]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- ii[[3]]$corr
ii.df[[3]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
##iii
prior.range <- c(21.0,  0.5)
range.fraction <- c(1, 0.8)
iii[[3]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- iii[[3]]$corr
iii.df[[3]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
#iv
prior.range <- c(21.0,  0.5)
range.fraction <- c(0.01, 0.8)
iv[[3]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- iv[[3]]$corr
iv.df[[3]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
##v
prior.range <- c(21.0,  0.5)
range.fraction <- c(0.01, 1)
v[[3]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- v[[3]]$corr
v.df[[3]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

ggplot(data = i.df[[3]], aes(x = dist, y = field)) +
  geom_line(data = iii.df[[3]], aes(x = dist, y = field), color = "red1", alpha = 1) +
  geom_line(data = iv.df[[3]], aes(x = dist, y = field), color = "blue1", alpha = 0.5) +
  geom_line(data = v.df[[3]], aes(x = dist, y = field), color = "lightblue1", alpha = 0.8) +
  geom_line() +
  geom_line(data = ii.df[[3]], aes(x = dist, y = field)) +
  ylim(c(0.7,1)) + xlim(c(0,4))

```

```{r}
##i
prior.range <- c(21,  0.5)
range.fraction <- c(1, 1)
i[[4]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- i[[4]]$corr
i.df[[4]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

#ii
prior.range <- c(21.0*0.2,  0.5)
range.fraction <- c(1, 1)
ii[[4]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- ii[[4]]$corr
ii.df[[4]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
##iii
prior.range <- c(21.0,  0.5)
range.fraction <- c(1, 0.2)
iii[[4]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- iii[[4]]$corr
iii.df[[4]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
#iv
prior.range <- c(21.0,  0.5)
range.fraction <- c(0.01, 0.2)
iv[[4]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- iv[[4]]$corr
iv.df[[4]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
##v
prior.range <- c(21.0,  0.5)
range.fraction <- c(0.01, 1)
v[[4]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- v[[4]]$corr
v.df[[4]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

ggplot(data = i.df[[4]], aes(x = dist, y = field)) +
  geom_line(data = iii.df[[4]], aes(x = dist, y = field), color = "red1", alpha = 1) +
  geom_line(data = iv.df[[4]], aes(x = dist, y = field), color = "blue1", alpha = 0.5) +
  geom_line(data = v.df[[4]], aes(x = dist, y = field), color = "lightblue1", alpha = 0.8) +
  geom_line() +
  geom_line(data = ii.df[[4]], aes(x = dist, y = field)) +
  ylim(c(0.5,1)) + xlim(c(0,10))

```
```{r}
##i
prior.range <- c(21,  0.5)
range.fraction <- c(1, 1)
i[[5]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- i[[5]]$corr
i.df[[5]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

#ii
prior.range <- c(21.0*0.1,  0.5)
range.fraction <- c(1, 1)
ii[[5]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- ii[[5]]$corr
ii.df[[5]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
##iii
prior.range <- c(21.0,  0.5)
range.fraction <- c(1, 0.1)
iii[[5]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- iii[[5]]$corr
iii.df[[5]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
#iv
prior.range <- c(21.0,  0.5)
range.fraction <- c(0.01, 0.1)
iv[[5]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- iv[[5]]$corr
iv.df[[5]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)
##v
prior.range <- c(21.0,  0.5)
range.fraction <- c(0.01, 1)
v[[5]] <- corr.covfx(range.fraction = range.fraction,
                id.node = id.node,
                prior.range = prior.range)
field <- v[[5]]$corr
v.df[[5]] <- df4plot(field, 
                dims = 300,
                id.coord = id.coord)

ggplot(data = i.df[[5]], aes(x = dist, y = field)) +
  geom_line(data = iii.df[[5]], aes(x = dist, y = field), color = "red1", alpha = 1) +
  geom_line(data = iv.df[[5]], aes(x = dist, y = field), color = "blue1", alpha = 0.5) +
  geom_line(data = v.df[[5]], aes(x = dist, y = field), color = "lightblue1", alpha = 0.8) +
  geom_line() +
  geom_line(data = ii.df[[5]], aes(x = dist, y = field)) +
  ylim(c(0.5,1)) + xlim(c(0,10))
```



```{r}
ii.df[[4]] %>% dplyr::filter(field > .79 & field < .81)
i.df[[4]] %>% dplyr::filter(field > .79 & field < .81)
iv.df08 <- iv.df[[4]] %>% dplyr::filter(field > .79 & field < .81)
max(iv.df08[,3])
min(iv.df08[,3])

n <- list()
b <- list()
ratio <- list()

b[[4]] <- ii.df[[4]] %>% dplyr::filter(dist > .999 & dist < 1.001)
n[[4]] <- i.df[[4]] %>% dplyr::filter(dist > .999 & dist < 1.001)
ratio[[4]] <- b[[4]][,4]/n[[4]][,4]

iv.df[[4]] %>% dplyr::filter(dist > .999 & dist < 1.001)
i.df[[4]] %>% dplyr::filter(dist > .999 & dist < 1.001)

b[[1]] <- ii.df[[1]] %>% dplyr::filter(dist > .999 & dist < 1.001)
n[[1]] <- i.df[[1]] %>% dplyr::filter(dist > .999 & dist < 1.001)
ratio[[1]] <- b[[1]][,4]/n[[1]][,4]

b[[2]] <- ii.df[[2]] %>% dplyr::filter(dist > .999 & dist < 1.001)
n[[2]] <- i.df[[2]] %>% dplyr::filter(dist > .999 & dist < 1.001)
ratio[[2]] <- b[[2]][,4]/n[[2]][,4]

b[[3]] <- ii.df[[3]] %>% dplyr::filter(dist > .999 & dist < 1.001)
n[[3]] <- i.df[[3]] %>% dplyr::filter(dist > .999 & dist < 1.001)
ratio[[3]] <- b[[3]][,4]/n[[3]][,4]

b[[5]] <- ii.df[[5]] %>% dplyr::filter(dist > .999 & dist < 1.001)
n[[5]] <- i.df[[5]] %>% dplyr::filter(dist > .999 & dist < 1.001)
ratio[[5]] <- b[[5]][,4]/n[[5]][,4]

####

st <- 1-ratio[[5]]
norm.ratio <- list()
for (i in 1:4) {
  norm.ratio[[i]] <- (ratio[[i]]-st)/st
}
```

```{r}
b[[4]] <- ii.df[[4]] %>% dplyr::filter(dist > .099 & dist < .11)
n[[4]] <- i.df[[4]] %>% dplyr::filter(dist > .099 & dist < .11)
ratio[[4]] <- b[[4]][,4]/n[[4]][,4]

b[[1]] <- ii.df[[1]] %>% dplyr::filter(dist > .099 & dist < .11)
n[[1]] <- i.df[[1]] %>% dplyr::filter(dist > .099 & dist < .11)
ratio[[1]] <- b[[1]][,4]/n[[1]][,4]

b[[2]] <- ii.df[[2]] %>% dplyr::filter(dist > .099 & dist < .11)
n[[2]] <- i.df[[2]] %>% dplyr::filter(dist > .099 & dist < .11)
ratio[[2]] <- b[[2]][,4]/n[[2]][,4]

b[[3]] <- ii.df[[3]] %>% dplyr::filter(dist > .099 & dist < .11)
n[[3]] <- i.df[[3]] %>% dplyr::filter(dist > .099 & dist < .11)
ratio[[3]] <- b[[3]][,4]/n[[3]][,4]

ratio
```

This is the idea that I think I will actually choose

Meeting Elias Dec 11

```{r}
Distance <- seq(0, 5, .1)
kappas = c(1, 2, 3)
ranges = sqrt(8)/kappas
csmall = INLA:::inla.matern.cov(nu = 1, kappa = kappas, x = 0.3, d = 2, corr = TRUE)
csmall
plot(Distance, INLA:::inla.matern.cov(nu = 1, kappa = kappas[1], x = Distance, d = 2, corr = TRUE), 
     bty = "n", type = "l")
for(i in 1:3){
 lines(Distance, INLA:::inla.matern.cov(nu = 1, kappa = kappas[i], x = Distance, d = 2, corr = TRUE), col = 1 + i)
}
legend("topright", paste(kappas, ", ", format(ranges, digits = 2), format(csmall, digits = 2)), 
       title = expression(kappa~r~csmall), 
       bty = "n", col = 1:3, lty = 1)

```

```{r}
Distance <- seq(0, 5, .1)
kappas = c(1, 2, 3, 10)
ranges = sqrt(8)/kappas
csmall = INLA:::inla.matern.cov(nu = 1, kappa = kappas, x = 0.1, d = 2, corr = TRUE)
csmall
plot(Distance, INLA:::inla.matern.cov(nu = 1, kappa = kappas[1], x = Distance, d = 2, corr = TRUE), 
     bty = "n", type = "l")
for(i in 1:4){
 lines(Distance, INLA:::inla.matern.cov(nu = 1, kappa = kappas[i], x = Distance, d = 2, corr = TRUE), col = 1 + i)
}
legend("topright", paste(kappas, ", ", format(ranges, digits = 2), format(csmall, digits = 2)), 
       title = expression(kappa~r~csmall), 
       bty = "n", col = 1:4, lty = 1)
```

```{r}
fratio = function(p, r0 = 1, h = r0 * 0.3) {
  r1.e = log(p)/(r0 - h)
  r0.W = optimize(function(r) {
    c.r = inla.matern.cov(nu = 1, kappa = sqrt(8)/r, x = h, d = 2, corr = TRUE)
    c.r0 = inla.matern.cov(nu = 1, kappa = sqrt(8)/r0, x = h, d = 2, corr = TRUE)
    #print(c(c.r, c.r0))
    abs(c.r/c.r0 - p)
  }, c(0, r0))
  return(c(r0.W$minimum, E=r1.e))
}
fratio(0.5)
fratio(0.7)
```


```{r}
fratio = function(p, r0 = 5, h = r0 * 0.1) {
  r.W = optimize(function(r) {
    c.r = inla.matern.cov(nu = 1, kappa = sqrt(8)/r, x = h, d = 2, corr = TRUE)
    c.r0 = inla.matern.cov(nu = 1, kappa = sqrt(8)/r0, x = h, d = 2, corr = TRUE)
    #print(c(c.r, c.r0))
    abs(c.r/c.r0 - p)
  }, c(0, r0))
  fract = r.W$minimum/r0
  attr(fract, "ranges") = c("normal" = r0, "barrier"=r.W$minimum)
  return(fract)
}
fratio(0.5)
fratio(0.7)
```














