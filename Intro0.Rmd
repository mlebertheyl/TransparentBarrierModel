---
output:
  pdf_document: default
  html_document: default
  word_document: default
---


```{r, include=FALSE}
library(wesanderson)
library(fields)
library(viridisLite)
library(RColorBrewer)

library(INLA)
library(rgdal)
library(scales)
library(ggplot2)
library(sf) 
library(terra)
library(sp)
library(magick)
library(scales)
library(patchwork)

library(spatstat)

library(leaflet)
library(leafpop)
library(leaflet.extras)
library(htmltools)
library(tidyverse)
library(rnaturalearth)
library(lattice)
library(htmlwidgets)
library(widgetframe)
library(shiny)
library(mapdata)
library(maptools)
library(rgeos)
library(raster)
require(devtools)

library(ggmap)
library(stars)
library(fmesher)
library(viridis)

library(lbfgsb3c)
library(citr)
library(magick)
```


```{r, include=FALSE}
inla.barrier.fem.plus <- function (mesh, barrier.triangles) 
  {
  n <- length(barrier.triangles) #barrier triangles list
  t <- length(mesh$graph$tv[, 1])
  total_triangles <- unlist(barrier.triangles)
  Omega <- list()
  Omega$remaining <- setdiff(1:t, total_triangles)
  for (k in 1:n) {
    Omega[k+1] <- barrier.triangles[k] 
    names(Omega)[k+1] <- paste0("barrier.triangles.", k)
  }
  
    dt.fem.white <- function(mesh, subdomain) {
        Ck <- rep(0, mesh$n)
        for (t in subdomain) {
            px <- mesh$graph$tv[t, ]
            temp <- mesh$loc[px, ]
            p1 <- t(t(temp[1, c(1, 2)]))
            p2 <- t(t(temp[2, c(1, 2)]))
            p3 <- t(t(temp[3, c(1, 2)]))
            Ts <- cbind(p2 - p1, p3 - p1)
            area <- abs(det(Ts)) * 0.5
            for (i in 1:3) {
                Ck[px[i]] <- Ck[px[i]] + area
            }
        }
        return(Ck)
    }
    dt.fem.identity <- function(mesh) {
        len <- length(mesh$graph$tv[, 1])
        index.i <- rep(0, len * 6)
        index.j <- rep(0, len * 6)
        #index.q <- rep(0, len * 6)
        Aij <- rep(0, len * 6)
        counter <- 1
        for (t in 1:len) {
            px <- mesh$graph$tv[t, ]
            temp <- mesh$loc[px, ]
            p1 <- t(t(temp[1, c(1, 2)]))
            p2 <- t(t(temp[2, c(1, 2)]))
            p3 <- t(t(temp[3, c(1, 2)]))
            Ts <- cbind(p2 - p1, p3 - p1)
            twiceArea <- abs(det(Ts))
            for (i in 1:3) {
                index.i[counter] <- px[i]
                index.j[counter] <- px[i]
                #index.q[counter] <- px[i]
                Aij[counter] <- (twiceArea) * 1/12
                counter <- counter + 1
            }
            for (i in 1:2) {
                for (j in (i + 1):3) {
                  index.i[counter] <- px[i]
                  index.j[counter] <- px[j]
                  Aij[counter] <- (twiceArea) * 1/24
                  counter <- counter + 1
                  index.i[counter] <- px[j]
                  index.j[counter] <- px[i]
                  Aij[counter] <- (twiceArea) * 1/24
                  counter <- counter + 1
                }
            }
        }
        I <- sparseMatrix(i = index.i, j = index.j, x = Aij, 
            dims = c(mesh$n, mesh$n), repr = "T")
        return(I)
    }
    dt.fem.laplace <- function(mesh, subdomain) {
        Nphix <- rbind(c(-1, -1), c(1, 0), c(0, 1))
        len <- length(subdomain)
        index.i <- rep(0, len * 9)
        index.j <- rep(0, len * 9)
        Aij <- rep(0, len * 9)
        counter <- 1
        for (tri in subdomain) {
            px <- mesh$graph$tv[tri, ]
            temp <- mesh$loc[px, ]
            p1 <- t(t(temp[1, c(1, 2)]))
            p2 <- t(t(temp[2, c(1, 2)]))
            p3 <- t(t(temp[3, c(1, 2)]))
            Ts <- cbind(p2 - p1, p3 - p1)
            TTTinv <- solve(t(Ts) %*% Ts)
            area <- abs(det(Ts)) * 0.5
            for (k in 1:3) {
                for (m in 1:3) {
                  tmp <- (3 * m + k - 4) * length(subdomain)
                  index.i[(tmp + counter)] <- px[k]
                  index.j[(tmp + counter)] <- px[m]
                  Aij[(tmp + counter)] <- area * Nphix[k, c(1, 
                    2)] %*% TTTinv %*% as.matrix(Nphix[m, c(1, 
                    2)])
                }
            }
            counter <- counter + 1
        }
        Dk <- sparseMatrix(i = index.i, j = index.j, x = Aij, 
            dims = c(mesh$n, mesh$n), repr = "T")
        return(Dk)
    }
    xi <- length(Omega)
        fem <- list()
        fem$I <- dt.fem.identity(mesh)
        fem$D <- list()
        fem$C <- list()
        for (k in 1:xi) {
            fem$D[[k]] <- dt.fem.laplace(mesh, Omega[[k]])
        }
        for (k in 1:xi) {
            fem$C[[k]] <- dt.fem.white(mesh, Omega[[k]])
        }
        fem$hdim <- xi
    
    return(fem)
}

inla.barrier.q <- function (fem, ranges, sigma = 1, envir = NULL) 
{
    if (is.null(ranges)) 
        stop("ranges cannot be NULL")
    if (any(is.na(ranges))) 
        stop("No range can be NA")
    xi <- length(ranges)
    if (xi != length(fem$D)) {
        print("inla.barrier.q has encountered an error. Will stop.")
        stop("Ranges do no correspond to fem")
    }
    if (any(ranges < 0.001)) {
        warning("This hyper parameter value may fail. A very small maximum edge length needed in the mesh.")
    }
    Cdiag <- ranges[1]^2 * fem$C[[1]]
    if (xi > 1) {
        for (k in 2:xi) {
            Cdiag <- Cdiag + ranges[k]^2 * fem$C[[k]]
        }
    }
    N <- length(Cdiag)
    Cinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1/Cdiag, dims = c(N, 
        N), repr = "T")
    A <- fem$I
    for (k in 1:xi) {
        A <- A + (ranges[k]^2/8) * fem$D[[k]]
    }
    Q <- inla.as.sparse(t(A) %*% Cinv %*% A * (1/sigma^2)/pi * 
        2 * 3)
    if (is.environment(envir)) {
        if (!exists("cache.done", envir = envir)) {
            Qx.idx <- which(Q@i <= Q@j)
            assign("Qx.idx", Qx.idx, envir = envir)
            assign("cache.done", TRUE, envir = envir)
        }
        else {
            Qx.idx <- get("Qx.idx", envir = envir)
        }
        return(Q@x[Qx.idx])
    }
    else {
        return(Q)
    }
}

inla.barrier.pcmatern.plus <- function (mesh, fem, barrier.triangles, prior.range, prior.sigma, range.fraction = 0.2) 
{
    if (missing(prior.range)) {
        warning("Arbitrary prior values chosen automatically. This may suffice for a first attempt, \n            but should be changed in any serious analysis.")
        prior.range <- c(diff(range(mesh$loc[, 1]))/5, 0.5)
    }
    if (missing(prior.sigma)) {
        prior.sigma <- c(1, 0.5) 
    }
    stopifnot(inherits(mesh, "inla.mesh"))
    stopifnot(range.fraction > 1e-06)

    barrier.rgeneric.model <- function(cmd = c("graph", "Q", 
        "mu", "initial", "log.norm.const", "log.prior", "quit"), 
        theta = NULL) {
        envir = parent.env(environment())
        prior.sigma <- obj$prior.sigma
        prior.range <- obj$prior.range
        fem <- obj$fem
        inla.barrier.q <- obj$inla.barrier.q
        range.fraction <- obj$range.fraction
        initial <- function(theta) {
            initial.theta <- c()
            if (!is.na(prior.sigma[2])) {
                initial.theta <- c(0, initial.theta)
            }
            if (!is.na(prior.range[2])) {
                initial.theta <- c(initial.theta, 0)
            }
            return(initial.theta)
        }
        log.prior <- function(theta) {
            val <- 0
            if (!is.na(prior.sigma[2])) {
                lambda0 <- -log(prior.sigma[2])/prior.sigma[1]
                val <- val + log(lambda0) - lambda0 * exp(theta[1]) + 
                  theta[1]
                theta.ran <- theta[-1]
            }
            else {
                theta.ran <- theta
            }
            if (!is.na(prior.range[2])) {
                lambda1 <- -log(prior.range[2]) * prior.range[1]
                for (logrange in theta.ran) {
                  val <- val + log(lambda1) - lambda1 * exp(-logrange) + 
                    -logrange
                }
            }
            return(val)
        }
        Q <- function(theta) {
            theta.full <- theta
            if (is.na(prior.sigma[2])) {
                theta.full <- c(log(prior.sigma[1]), theta.full)
            }
            if (is.na(prior.range[2])) {
                theta.full <- c(theta.full, log(prior.range[1]))
            }
            stopifnot(length(theta.full) == 2)
            Q <- inla.barrier.q(fem = fem, ranges = exp(theta.full[2]) * 
                c(1, range.fraction), sigma = exp(theta.full[1]), 
                envir = envir) #ENVIR MAKES IT WORK
            return(Q)
        }
        graph <- function(theta) {
            require(methods)
            ntheta <- 2
            theta.full <- (1:ntheta)/3.217233456
            G1 <- inla.barrier.q(fem = fem, ranges = exp(theta.full[2]) * 
                c(1, range.fraction), sigma = exp(theta.full[1]))
            G1[G1 != 0] <- 1
            theta.full <- (1:ntheta)^2/12.1543534
            G2 <- inla.barrier.q(fem = fem, ranges = exp(theta.full[2]) * 
                c(1, range.fraction), sigma = exp(theta.full[1]))
            G2[G2 != 0] <- 1
            return(G1 + G2)
        }
        mu <- function(theta) numeric(0)
        log.norm.const <- function(theta) numeric(0)
        quit <- function(theta) invisible()
        val <- do.call(match.arg(cmd), args = list(theta))
        return(val)
    }
#   barrier.triangles <- unique(barrier.triangles)
    obj <- list()
    obj$prior.sigma <- prior.sigma
    obj$prior.range <- prior.range
    obj$range.fraction <- range.fraction
    obj$inla.barrier.q <- inla.barrier.q
    obj$fem <- fem
    barrier.model <- inla.rgeneric.define(model = barrier.rgeneric.model, 
        optimize = TRUE, obj = obj)
    if (!is.na(prior.sigma[2]) && !is.na(prior.range[2])) {
    }
    else {
        warning("Not properly tested, let us know if you have problems.")
    }
    return(barrier.model)
}

book.rMatern <- function(n, coords, sigma=1, range, kappa = sqrt(8*nu)/range, variance = sigma^2, nu=1) {
    m <- as.matrix(dist(coords))
    m <- exp((1-nu)*log(2) + nu*log(kappa*m)-
             lgamma(nu))*besselK(m*kappa, nu)
    diag(m) <- 1
    return(drop(crossprod(chol(variance*m),
                          matrix(rnorm(nrow(coords)*n), ncol=n))))
}

book.rspde <- function(coords, sigma=1, range, variance=sigma^2, alpha=2, kappa = sqrt(8*(alpha-1))/range, n=1, mesh, 
                  verbose=FALSE, seed, return.attributes=FALSE) {
    t0 <- Sys.time()
    theta <- c(-0.5*log(4*pi*variance*kappa^2), log(kappa))
    if (verbose) cat('theta =', theta, '\n')
    if (missing(mesh)) {
        mesh.pars <- c(0.5, 1, 0.1, 0.5, 1)*sqrt(alpha-ncol(coords)/2)/kappa 
        if (verbose) cat('mesh.pars =', mesh.pars, '\n')
        attributes <- list(
            mesh=inla.mesh.2d(
                coords[chull(coords), ], max.edge=mesh.pars[1:2], 
                cutoff=mesh.pars[3], offset=mesh.pars[4:5]))
        if (verbose) cat('n.mesh =', attributes$mesh$n, '\n')
    }
    else attributes <- list(mesh=mesh)
    attributes$spde <- inla.spde2.matern(attributes$mesh, alpha=alpha)
    attributes$Q <- inla.spde2.precision(attributes$spde, theta=theta)
    attributes$A <- inla.mesh.project(mesh=attributes$mesh, loc=coords)$A
    if (n==1) 
        result <- drop(attributes$A%*%inla.qsample(
            Q=attributes$Q,
            constr=attributes$spde$f$extraconstr))
    t1 <- Sys.time() 
    result <- inla.qsample(n, attributes$Q, 
                           seed=ifelse(missing(seed), 0, seed), 
                           constr=attributes$spde$f$extraconstr) 
    if (nrow(result)<nrow(attributes$A)) {
        result <- rbind(result, matrix(
            NA, nrow(attributes$A)-nrow(result), ncol(result)))
        dimnames(result)[[1]] <- paste('x', 1:nrow(result), sep='')
        for (j in 1:ncol(result)) 
            result[, j] <- drop(attributes$A%*%
                                result[1:ncol(attributes$A),j])
    }
    else {
        for (j in 1:ncol(result)) 
            result[1:nrow(attributes$A), j] <-
                drop(attributes$A%*%result[,j]) 
        result <- result[1:nrow(attributes$A), ]
    }
    t2 <- Sys.time()
    attributes$cpu <- c(prep=t1-t0, sample=t2-t1, total=t2-t0)
    if (return.attributes) 
        attributes(result) <- c(attributes(result), attributes)
    return(drop(result))
}

book.mesh.dual <- function(mesh) {
    if (mesh$manifold=='R2') {
        ce <- t(sapply(1:nrow(mesh$graph$tv), function(i)
            colMeans(mesh$loc[mesh$graph$tv[i, ], 1:2])))
        library(parallel)
        pls <- mclapply(1:mesh$n, function(i) {
            p <- unique(Reduce('rbind', lapply(1:3, function(k) {
                j <- which(mesh$graph$tv[,k]==i)
                if (length(j)>0) 
                    return(rbind(ce[j, , drop=FALSE],
                                 cbind(mesh$loc[mesh$graph$tv[j, k], 1] +
                                       mesh$loc[mesh$graph$tv[j, c(2:3,1)[k]], 1], 
                                       mesh$loc[mesh$graph$tv[j, k], 2] +
                                       mesh$loc[mesh$graph$tv[j, c(2:3,1)[k]], 2])/2))
                else return(ce[j, , drop=FALSE])
            })))
            j1 <- which(mesh$segm$bnd$idx[,1]==i)
            j2 <- which(mesh$segm$bnd$idx[,2]==i)
            if ((length(j1)>0) | (length(j2)>0)) {
                p <- unique(rbind(mesh$loc[i, 1:2], p,
                                  mesh$loc[mesh$segm$bnd$idx[j1, 1], 1:2]/2 +
                                  mesh$loc[mesh$segm$bnd$idx[j1, 2], 1:2]/2, 
                                  mesh$loc[mesh$segm$bnd$idx[j2, 1], 1:2]/2 +
                                  mesh$loc[mesh$segm$bnd$idx[j2, 2], 1:2]/2))
                yy <- p[,2]-mean(p[,2])/2-mesh$loc[i, 2]/2
                xx <- p[,1]-mean(p[,1])/2-mesh$loc[i, 1]/2
            }
            else {
                yy <- p[,2]-mesh$loc[i, 2]
                xx <- p[,1]-mesh$loc[i, 1]
            }
            Polygon(p[order(atan2(yy,xx)), ])
        })
        return(SpatialPolygons(lapply(1:mesh$n, function(i)
            Polygons(list(pls[[i]]), i))))
    }
    else stop("It only works for R2!")
}

genColor <- function(n, type=c('red', 'green', 'blue'), u=NULL) {
    cbp <- list(
        red = list(c(255, 254, 252, 252, 251, 239, 203, 165, 103), 
                   c(245, 224, 187, 146, 106, 59, 24, 15, 0), 
                   c(240, 210, 161, 114, 74, 44, 29, 21, 13)), 
        green = list(c(247, 229, 199, 161, 116, 65, 35, 0, 0), 
                     c(252, 245, 233, 217, 196, 171, 139, 109, 68), 
                     c(245, 224, 192, 155, 118, 93, 69, 44, 27)), 
        blue = list(c(247, 222, 198, 158, 107, 66, 33, 8, 8), 
                    c(251, 235, 219, 202, 174, 146, 113, 81, 48), 
                    c(255, 247, 239, 225, 214, 198, 181, 156, 107)))
    if (n<2) stop("Works for 'n>2'!")
    if (is.null(u))
        u <- 0:(n-1)/(n-1)
    u0 <- 0:8/8
    i <- findInterval(u, u0, TRUE)
    k <- pmatch(match.arg(type), c('red', 'green', 'blue'))
    w1 <- 8*(u0[i+1]-u)/255; w2 <- 8*(u-u0[i])/255
    rgb(cbp[[k]][[1]][i]*w1 + cbp[[k]][[1]][i+1]*w2, 
        cbp[[k]][[2]][i]*w1 + cbp[[k]][[2]][i+1]*w2, 
        cbp[[k]][[3]][i]*w1 + cbp[[k]][[3]][i+1]*w2)
}

plot.dgTMatrix <- function(x, y, ...) {
    cl <- match.call()
    if (is.null(cl$digits))
        digits <- 2
    z <- sort(unique(round(x@x, digits)))
    nz <- length(z)
    n1 <- sum(z<0)
    n2 <- sum(z>0)
    if (is.null(cl$colors)) 
        if (any(c(n1,n2)==0)) 
            colors <- gray(0.9*(1-(z-min(z))/diff(range(z))))
        else
            colors <- c(genColor(n1, 'red', z[z<0]/min(z)),
                        rep('white', nz-n1-n2),
                        genColor(n2, 'blue', z[z>0]/max(z)))
    z.breaks <- c(z[1]-diff(z[1:2])/2,
                  z[-nz]/2 + z[-1]/2,
                  z[nz]+diff(z[nz-1:0])/2)
    x@x <- round(x@x, digits)
    image(x, at=z.breaks, col.regions=colors, ...)
}

book.plot.field <- function(field, mesh, projector, xlim, ylim, 
			    dims=c(300,300), poly, asp = 1, 
			    axes = FALSE, xlab = '', ylab = '', 
			    col = book.color.c(), ...){
  ## you can supply field as a matrix vector or like a named list with 'x', 'y' and 'z' as for image
  ## when field is a vector, it will project it using projector, assuming projector will create a matrix 
  ## when mesh is supplied and projector not, projector will be created and used to project field
  if (missing(mesh)) {
    if (missing(projector)) {
      if (missing(xlim) | missing(ylim)) {
        image.plot(field, asp = asp, axes = axes, 
                   xlab = xlab, ylab = ylab, col = col, ...)
      } else {
        image.plot(field, xlim = xlim, ylim = ylim, asp = asp, 
                   axes = axes, xlab = xlab, ylab = ylab, col = col, ...)
      }
    } else {
      if (missing(xlim)) xlim <- range(projector$x)
      if (missing(ylim)) ylim <- range(projector$y)
      field.proj <- inla.mesh.project(projector, field)
      image.plot(x = projector$x, y = projector$y, z = field.proj, 
                 asp=asp, axes=axes, xlab = xlab, ylab = ylab, 
                 col=col, xlim=xlim, ylim=ylim, ...)
    }
  } else {
    if (missing(xlim)) xlim <- range(mesh$loc[,1])
    if (missing(ylim)) ylim <- range(mesh$loc[,2])
    projector <- inla.mesh.projector(mesh, xlim = xlim,
                                     ylim = ylim, dims=dims)
    field.proj <- inla.mesh.project(projector, field)
    image.plot(x = projector$x, y = projector$y, z = field.proj, 
               asp=asp, axes=axes, xlab = xlab, ylab = ylab, col=col, ...)
  }
  if (!missing(poly)) 
      plot(poly, add = TRUE, col = 'grey')
}

## Functions for barrier models

## Find the correlation of precision Q (defined on mesh) at location 
book.spatial.correlation <- function(Q, location, mesh) {
  ## The marginal standard deviations
  sd <- sqrt(diag(inla.qinv(Q)))

  ## Create a fake A matrix, to extract the closest mesh node index
  A.tmp <- inla.spde.make.A(mesh = mesh,
    loc = matrix(c(location[1], location[2]), 1, 2))
  id.node = which.max(A.tmp[1, ])

  ## Solve a matrix system to find just one column of the covariance matrix
  Inode <- rep(0, dim(Q)[1])
  Inode[id.node] <- 1
  covar.column <- solve(Q, Inode)
  corr <- drop(matrix(covar.column)) / (sd * sd[id.node])
  return(corr)
}

## Continuous and discrete colour scales for the book
# n=8; plot(1:n, col=brewer.pal(n = n, name = "Paired"))

# Continuous
book.color.c = function(n = 201) {
  return(viridis(n))
}

# Continuous (alternative)
book.color.c2 = function(n = 201) {
  return(magma(n))
}

# Discrete from a continuous
book.color.dc = function(n = 11) {
  return(viridis(n))
}

# Discrete (cannot be interpolated)
book.color.d = function(n=4) {
  return(brewer.pal(n = n, name = "Paired"))
}


crs_longlat <- CRS("+proj=longlat +datum=WGS84")
crs_km <- CRS("+proj=utm +zone=39 ellps=WGS84 +units=km")

## --------------------------------------------------------------------------------
local.plot.field = function(field, pal = plasma(50), ...){
  xlim = c(2, 8); ylim = xlim;
  proj = inla.mesh.projector(mesh, xlim = xlim, 
                             ylim = ylim, dims=c(300, 300))
  # - Can project from the mesh onto a 300x300 grid 
  #   for plots
  field.proj = inla.mesh.project(proj, field)
  # - Do the projection
  image.plot(list(x = proj$x, y=proj$y, z = field.proj), 
             xlim = xlim, ylim = ylim, col = pal, ...)  
  # - Use image.plot to get nice colors and legend
}

local.square.polygon <- function(xlim, ylim){
# - output is a square
  xlim = range(xlim); ylim = range(ylim)
  corner1 = c(xlim[1], ylim[2])
  corner2 = c(xlim[2], ylim[1])
  poly = Polygon(rbind(corner1, c(corner1[1], corner2[2]), corner2, c(corner2[1], corner1[2]), corner1), hole = FALSE)
  return(SpatialPolygons(list(Polygons(list(poly), ID = runif(1)))))
}

local.square.polygon_T = function(xlim, ylim){
# - output is a square
  xlim = range(xlim); ylim = range(ylim)
  corner1 = c(xlim[1], ylim[2])
  corner2 = c(xlim[2], ylim[1])
  poly = Polygon(rbind(corner1, c(corner1[1], corner2[2]), corner2, c(corner2[1], corner1[2]), corner1), hole = TRUE)
  return(poly)
}

fx.pre.field <- function(
    smalldist = 0.5, 
    width = c(0.4, 0.4), 
    max.edge.length = 0.4,
    set.inla.seed = 2303,
    loc.data = FALSE,
    n = 100 # only if loc.data is TRUE
    ){
  
  poly1 <- local.square.polygon(xlim=c(-1, 5-smalldist/2), 
                          ylim=5+width[1]*c(-.5, .5))
  poly2 <- local.square.polygon(xlim=c(5+smalldist/2, 11), 
                          ylim=5+width[2]*c(-.5, .5))
  poly.original <- SpatialPolygons(c(poly1@polygons, poly2@polygons))
  
  loc1 <- matrix(c(0,0, 10,0, 0,10, 10,10), 4, 2, byrow = T)
  
  seg <- inla.sp2segment(poly.original)
# - Transforms a SpatialPolygon to an "inla polygon"
  mesh <- inla.mesh.2d(loc=loc1, interior = seg, 
                    max.e = max.edge.length, offset=1)

  tl <- length(mesh$graph$tv[,1])
# - the number of triangles in the mesh
  posTri <- matrix(0, tl, 2)

  for (t in 1:tl){
    temp = mesh$loc[mesh$graph$tv[t, ], ]
    posTri[t,] = colMeans(temp)[c(1,2)] 
    }

  posTri <- SpatialPoints(posTri)
# - the positions of the triangle centers

  bar.original <- over(poly.original, SpatialPoints(posTri), returnList=T)
# - checking which mesh triangles are inside the barrier area
  bar.original <- unlist(bar.original)
  poly.bar.orginal <- inla.barrier.polygon(mesh, barrier.triangles = bar.original)
# - the Barrier model's polygon
# - in most cases this should be the same as poly.original

# BARRIER 1
  bar1 <- over(poly1, SpatialPoints(posTri), returnList=T)
# - checking which mesh triangles are inside the barrier area
  bar1 <- unlist(bar1)
  poly.bar1 <- inla.barrier.polygon(mesh, barrier.triangles = bar1)
# - the Barrier model's polygon
# - in most cases this should be the same as poly.original

# BARRIER 2
  bar2 <- over(poly2, SpatialPoints(posTri), returnList=T)
# - checking which mesh triangles are inside the barrier area
  bar2 <- unlist(bar2)
  poly.bar2 <- inla.barrier.polygon(mesh, barrier.triangles = bar2)

# PLOTS
  mat <-  inla.barrier.fem.plus(mesh, list(bar1, bar2))
  
  if(loc.data == TRUE){
    
    poly1_h <- local.square.polygon_T(xlim=c(2, 5-smalldist/2), 
                          ylim=5+width[1]*c(-.5, .5))

    poly2_h <- local.square.polygon_T(xlim=c(5+smalldist/2, 8), 
                          ylim=5+width[2]*c(-.5, .5))
    loc1 <- matrix(c(2,2, 8,2, 8,8, 2,8), 4, 2, byrow = T)

    locp <- Polygon(loc1, hole = FALSE)
    
    poly.water <- SpatialPolygons(list(Polygons(list(locp, poly1_h, poly2_h), '0')))
    poly.water_sf <- st_as_sf(poly.water)
    
    set.seed(set.inla.seed)
    loc.data <- spsample(x = poly.water, n = n, type = "random")
    loc.data_sf <- st_as_sf(loc.data)
    loc.data <- loc.data@coords
    
    mesh_h <-inla.mesh.2d(boundary = poly.water_sf, 
             max.e = max.edge.length, offset=1)
    
    return(list(poly1 = poly1, 
              poly2 = poly2, 
              poly.original = poly.original, 
              mesh = mesh, 
              posTri = posTri, 
              poly.bar.orginal = poly.bar.orginal, 
              bar1 = bar1, 
              bar2 = bar2, 
              mat = mat,
              loc.data = loc.data,
              poly.water = poly.water,
              poly.water_sf = poly.water_sf,
              mesh_h = mesh_h,
              loc.data_sf = loc.data_sf))
  }
  
  if(loc.data == FALSE) {
   
    return(list(poly1 = poly1, 
              poly2 = poly2, 
              poly.original = poly.original, 
              mesh = mesh, 
              posTri = posTri, 
              poly.bar.orginal = poly.bar.orginal, 
              bar1 = bar1, 
              bar2 = bar2, 
              mat = mat)) 
  }
}

transparency <- function(mesh = mesh, fem = fem, 
                         barrier.triangles = barrier.triangles, 
                     prior.range = c(1.44, 0.5), prior.sigma = c(0.7, 0.5),
                     range.fraction = range.fraction,
                     range = 3,
                     set.inla.seed = 2303, # make sure is the same as prev. fx if loc.data = T
                     loc.data = loc.data, 
                     sigma.u = 1, sigma.epsilon = 0.2,
                     poly.original = poly.bar.orginal,
                     prior.range.st = c(1, 0.5),    
                     prior.sigma.st = c(1, 0.5),
                     return.list = TRUE) {
  
  # field = TRUE has to be true to start
  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction)
  # range fraction has to have the same length as barrier triangles
  Q <- inla.rgeneric.q(barrier.model, "Q", theta = c(0, log(range)))
  u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))
  u <- u[ ,1]
    
  A.data <- inla.spde.make.A(mesh, loc.data)
  #Q from mydiff.r function
    
  u.data <- A.data %*% u
  
  df <- data.frame(loc.data)
  names(df) <- c('locx', 'locy')
  df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))
  
    
  stk <- inla.stack(data=list(y=df$y), 
                    A=list(A.data, 1),
                    effects=list(s=1:mesh$n, 
                                 intercept=rep(1, nrow(df))), 
                    remove.unused = FALSE, 
                    tag='est')

    
  formula <- y ~ 0 + intercept + f(s, model = barrier.model)
  # - The spatial model component is different from stationary
  # - The rest of the model setup is the same as in the stationary case!
  # - - e.g. the inla(...) call below is the same, 
  #     only this formula is different
  
    
  res.barrier <- inla(formula, data = inla.stack.data(stk),
                        control.predictor = list(A = inla.stack.A(stk)),
                        family = 'gaussian',
                        control.family = list(hyper = list(
                          prec = list(prior = "pc.prec", fixed = FALSE, param = c(0.2,0.5)))),
                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))
    
  model.stat <- inla.spde2.pcmatern(mesh, 
                                    prior.range = c(prior.range.st[1], prior.range.st[2]),
                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))
  
  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)
  
  res.stationary <- inla(formula.st, data=inla.stack.data(stk),
            control.predictor=list(A = inla.stack.A(stk)),
            family = 'gaussian',
            control.family = list(hyper = list(prec = list(
              prior = "pc.prec", fixed = FALSE, 
              param = c(0.2,0.5)))),
            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))
  
  if (return.list == TRUE) {
    
    list.field <- list(barrier.model = barrier.model, Q = Q, sample = u)
    pos.bm <- list(df = df, res = res.barrier)
    pos.st <- list(res = res.stationary)
    
    return(list(list.field = list.field, pos.bm = pos.bm, pos.st = pos.st))
  }
                     
}

plot.transparency <- function(nfrac = 1, # length of fractions for range
                              max.frac = 1, # 1/max.frac
                              left.poly = 0.1,
                              poly.bar.orginal = poly.bar.orginal,
                              range = 3,
                              fps = 1,
                              set.inla.seed = 2303,
                              col=alpha('grey', 0),
                              plot.points = points(loc.data, 
                                              pch = 16, 
                                              cex = 0.8, 
                                              col=alpha('gray', 0)),
                              gif.path = "gif/gif.fx/",
                              pal.field = turbo(50),
                              pal.pos.mean = turbo(50),
                              pal.pos.sd = turbo(50),
                              pal.pos.q25 = turbo(50),
                              pal.pos.q50 = turbo(50),
                              pal.pos.q975 = turbo(50),
                              
                              pal.pos.mean.st = turbo(50),
                              pal.pos.sd.st = turbo(50),
                              pal.pos.q25.st = turbo(50),
                              pal.pos.q50.st = turbo(50),
                              pal.pos.q975.st = turbo(50),
                              ...
    ){
  dir_out_f <- file.path(tempdir(), "truefield_gif")
  dir.create(dir_out_f, recursive = TRUE)
  
  # barrier model
  dir_out_pm <- file.path(tempdir(), "posmean_gif")
  dir.create(dir_out_pm, recursive = TRUE)
  
  dir_out_sd <- file.path(tempdir(), "possd_gif")
  dir.create(dir_out_sd, recursive = TRUE)
  
  dir_out_q25 <- file.path(tempdir(), "posq25_gif")
  dir.create(dir_out_q25, recursive = TRUE)
  
  dir_out_q5 <- file.path(tempdir(), "posq5_gif")
  dir.create(dir_out_q5, recursive = TRUE)
  
  dir_out_q975 <- file.path(tempdir(), "posq975_gif")
  dir.create(dir_out_q975, recursive = TRUE)
  
  # stationary model
  dir_out_s <- file.path(tempdir(), "statmodel_gif")
  dir.create(dir_out_s, recursive = TRUE)
  
  dir_out_st.sd <- file.path(tempdir(), "st.sd_gif")
  dir.create(dir_out_st.sd, recursive = TRUE)
  
  dir_out_st.q25 <- file.path(tempdir(), "pos.st.q25_gif")
  dir.create(dir_out_st.q25, recursive = TRUE)
  
  dir_out_st.q5 <- file.path(tempdir(), "pos.st.q5_gif")
  dir.create(dir_out_st.q5, recursive = TRUE)
  
  dir_out_st.q975 <- file.path(tempdir(), "pos.st.q975_gif")
  dir.create(dir_out_st.q975, recursive = TRUE)
  
  fr <- seq(from = left.poly, to = max.frac, length = nfrac)/max.frac
  if (fr[1] < left.poly) fr[1] <- left.poly
  for (r in 1:nfrac) {
    f <- fr[r]
    range.fraction <- c(left.poly, f)
    trans <- transparency(mesh = mesh, fem = fem, 
                barrier.triangles = barrier.triangles, 
                prior.range = c(1.44, 0.5), prior.sigma = c(0.7, 0.5),
                range.fraction = c(left.poly, f),
                range = range,
                set.inla.seed = set.inla.seed, # make sure is the same as prev. fx if loc.data = T
                loc.data = loc.data, 
                sigma.u = 1, sigma.epsilon = 0.2,
                poly.original = poly.bar.orginal,
                prior.range.st = c(1, 0.5),
                prior.sigma.st = c(1, 0.5),
                return.list = TRUE
    )
    
    # SPATIAL FIELD, u
    fpp <- file.path(dir_out_f, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans$list.field$sample, 
                     main="Spatial posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.field)
    plot(poly.bar.orginal, add=T, col = col)
    plot.points
    dev.off()
    
    # POSTERIOR MEAN
    fpp <- file.path(dir_out_pm, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans$pos.bm$res$summary.random$s$mean, 
                     main="Spatial mean posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD
    fpp <- file.path(dir_out_sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans$pos.bm$res$summary.random$s$sd, 
                     main="Spatial sd posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES
    # 0.025
    fpp <- file.path(dir_out_q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans$pos.bm$res$summary.random$s[,4], 
                     main="Spatial 0.025 quantile posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5
    fpp <- file.path(dir_out_q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans$pos.bm$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975
    fpp <- file.path(dir_out_q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans$pos.bm$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile posterior for Barrier model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # SPATIAL ESTIMATE WITH STATIONARY MODEL
    fpp <- file.path(dir_out_s, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans$pos.st$res$summary.random$s$mean,
                     main="Spatial estimate with the stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.mean.st) 
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS SD st
    fpp <- file.path(dir_out_st.sd, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans$pos.st$res$summary.random$s$sd, 
                     main="Spatial sd posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.sd.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    #POS QUANTILES st
    # 0.025 st
    fpp <- file.path(dir_out_st.q25, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans$pos.st$res$summary.random$s[,4], 
                     main="Spatial 0.025 quantile posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q25.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()

    # 0.5 st
    fpp <- file.path(dir_out_st.q5, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans$pos.st$res$summary.random$s[,5], 
                     main="Spatial 0.5 quantile posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q50.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
    
    # 0.975 st
    fpp <- file.path(dir_out_st.q975, paste0(f, ".png"))
    png(fpp)
    
    local.plot.field(trans$pos.st$res$summary.random$s[,6], 
                     main="Spatial 0.975 quantile posterior for Stationary model",
                     sub = paste("Barrier Model, range.fraction = c(", 
                               range.fraction[1], ", ", range.fraction[2], ")"),
                     pal = pal.pos.q975.st)
    plot(poly.bar.orginal, add=T, col = col)
    dev.off()
  }
  
    ## bm
    # SPATIAL FIELD, u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_f, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "true.field.gif"))
    
    # POSTERIOR MEAN
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_pm, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.mean.gif"))
    
    #POS SD
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.gif"))
    
    #POS QUANTILES
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.gif"))
    
    ## st
    # u
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_s, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "stat.rnadom.mean.gif"))
    
    # st sd
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.sd, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.sd.st.gif"))
    
    #POS QUANTILES st
    # 0.025
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q25, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q25.st.gif"))
    
    # 0.5
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q5, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q5.st.gif"))
    
    # 0.975
    image_write(image = image_animate(
      image_join(
        lapply(list.files(dir_out_st.q975, full.names = TRUE), image_read)), 
      fps = fps), 
      path = paste0(gif.path, "pos.q975.st.gif"))
    
    unlink(dir_out_f, recursive = T)
    unlink(dir_out_pm, recursive = T)
    unlink(dir_out_sd, recursive = T)
    unlink(dir_out_q25, recursive = T)
    unlink(dir_out_q5, recursive = T)
    unlink(dir_out_q975, recursive = T)
    unlink(dir_out_s, recursive = T)
    unlink(dir_out_st.sd, recursive = T)
    unlink(dir_out_st.q25, recursive = T)
    unlink(dir_out_st.q5, recursive = T)
    unlink(dir_out_st.q975, recursive = T)
}



corr.from.Q.simplified <- function( #I am calculating A.tmp and all outside
    Q = Q,
    id.node = id.node.n,
    id.coord = id.coord.n,
    in.id.node = id.node.b) { 
  
  sd <- sqrt(diag(inla.qinv(Q)))


  Inode = rep(0, dim(Q)[1]) 
  Inode[id.node] = 1
  covar.column = solve(Q, Inode)
# compute correlations
  corr = drop(matrix(covar.column)) / (sd*sd[id.node])
  corr2points <- corr[in.id.node]
  
  return(corr2points)
}

corr.from.Q <- function(
    Q = Q,
    location = location,
    y.up = y.up,
    max.edge.length = max.edge.length,
    mesh = mesh,
    in.id.node = in.id.node) { 
  
  sd <- sqrt(diag(inla.qinv(Q)))
#the 3 following are obvs the same for all
  A.tmp <- inla.spde.make.A(mesh=mesh,
                            loc = matrix(c(location[1,1],(y.up + max.edge.length/2)), nrow=1, ncol=2)) 
  id.node = which.max(A.tmp[1, ])
  id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])

  Inode = rep(0, dim(Q)[1]) 
  Inode[id.node] = 1
  covar.column = solve(Q, Inode)
# compute correlations
  corr = drop(matrix(covar.column)) / (sd*sd[id.node])
  corr2points <- corr[in.id.node]
  corr.from.Q <- list(corr2points = corr2points, corr = corr, id.coord = id.coord, id.node = id.node)
  
  return(corr.from.Q)
}

# choose the true range fraction to generate the data
# for family = 'gaussian'
trans.generate.q2 <- function(mesh = mesh, fem = fem, 
                        loc.data = loc.data, 
                        set.inla.seed = 2303, 
                        barrier.triangles = barrier.triangles, 
                        prior.range = c(1.44, 0.5), 
                        prior.sigma = c(0.7, 0.5),
                        range.fraction, #IMPORTANT,
                        range,
                        sigma.u = 1, sigma.epsilon = 0.2,
                        return.list = TRUE) {
  
  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, 
                                              prior.range, prior.sigma, 
                                              range.fraction)
  
  # range fraction has to have the same length as barrier triangles
  Q <- inla.rgeneric.q(barrier.model, "Q", theta = c(log(1), log(range)))
  u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))
  u <- u[ ,1]
    
  A.data <- inla.spde.make.A(mesh, loc.data)
  #Q from mydiff.r function
    
  u.data <- A.data %*% u
  
  df <- data.frame(loc.data)
  names(df) <- c('locx', 'locy')
  df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))
  
  if (return.list == TRUE) {
    
  data.list <- list(df = df, Q = Q, sample = u, 
                    A.data = A.data, barrier.model=barrier.model)
    
    return(list(list.field = data.list))
  }
                     
}

ratio.distance <- function(ratio){
  ratio.aim <- ratio
  trans.barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range,
                             prior.sigma,
                             range.fraction)
  Q.trans <- inla.rgeneric.q(trans.barrier.model, "Q", 
                             theta = c(log(prior.sigma[1]), log(prior.range[1])))
  
  #~ ratio, corr_b/1
  empirical.ratio <- 
    corr.from.Q.simplified(Q = Q.trans,
                           id.node = id.node.n,
                           id.coord = id.coord.n,
                           in.id.node = id.node.b)                             
  
  jump.data <- (empirical.ratio - ratio.aim)^2
  
  return(list(trans.barrier.model = trans.barrier.model, 
              Q.trans = Q.trans,
              empirical.ratio = empirical.ratio,
              sq.distance = jump.data)) 
  
}


corr.from.Q.alltogether <- function(
    Q,
    id.node,
    in.id.node) {
  
  sd <- sqrt(diag(inla.qinv(Q)))
  Inode <- rep(0, dim(Q)[1])
  
  for (i in 1:length(id.node)) {
    Inode[id.node[[i]]] <- 1
  }
  
  covar.column <- solve(Q, Inode)

  corr <- list()
  corr2points <- list()
  for (i in 1:length(id.node)) {
    corr[[i]] = drop(matrix(covar.column))/(sd*sd[id.node[[i]]])
    corr2points[[i]] <- corr[[i]][in.id.node[[i]]]
  }
  
  return(corr2points)
}

#sd*sd[id.node[[i]]]=sd[in.id.node[[i]]]*sd[id.node[[i]]]

corr.from.Q.separately <- function(
    Q,
    id.node,
    in.id.node) {
  
  sd <- sqrt(diag(inla.qinv(Q)))
  
  corr2points <- list()
  for (i in 1:length(id.node)) {
    
    Inode <- rep(0, dim(Q)[1]) 
    Inode[id.node[[i]]] = 1 
    covar.column = solve(Q, Inode)
    corr = drop(matrix(covar.column)) / (sd*sd[id.node[[i]]])
    corr2points[[i]] <- corr[in.id.node[[i]]]
  }
  
  return(corr2points)
}


find.aimed.ratios <- function(x, aimed.ratio) {
  
  barrier.model <- inla.barrier.pcmatern.plus(
    mesh = mesh,
    fem = fem,
    barrier.triangles = barrier.triangles,
    prior.range = prior.range,
    prior.sigma = prior.sigma,
    range.fraction = x)
  
  Q <- inla.rgeneric.q(
    barrier.model, 
    "Q",
    theta = c(log(prior.sigma[1]), 
              log(prior.range[1])))
  
  corr.bm <- corr.from.Q.alltogether(
    Q = Q, 
    id.node = id.node, 
    in.id.node = in.id.node)
  
  A <- diag(aimed.ratio)
  B <- diag(corr.bm)
  M <- A-B
  mini <- norm(M, "F")
  
  return(mini)
}

find.x <- function(x) {
  
  barrier.model <- inla.barrier.pcmatern.plus(
    mesh = mesh,
    fem = fem,
    barrier.triangles = barrier.triangles,
    prior.range = prior.range,
    prior.sigma = prior.sigma,
    range.fraction = x)
  
  Q <- inla.rgeneric.q(
    barrier.model, 
    "Q",
    theta = c(log(prior.sigma[1]), 
              log(prior.range[1])))
  
  corr.bm <- corr.from.Q.alltogether(
    Q = Q, 
    id.node = id.node, 
    in.id.node = in.id.node)
  
  A <- diag(aim)
  B <- diag(corr.bm)
  M <- A-B
  mini <- norm(M, "F")
  
  return(mini)
}

find.ratio.from.range <- function(x, corr.nb) {
  
  barrier.model <- inla.barrier.pcmatern.plus(
    mesh = mesh,
    fem = fem,
    barrier.triangles = barrier.triangles,
    prior.range = prior.range,
    prior.sigma = prior.sigma,
    range.fraction = x)
  
  Q <- inla.rgeneric.q(
    barrier.model, 
    "Q",
    theta = c(log(prior.sigma[1]), 
              log(prior.range[1])))
  
  corr.bm <- corr.from.Q.alltogether(
    Q = Q, 
    id.node = id.node, 
    in.id.node = in.id.node)
  
  corr <- c()
  for (i in seq_along(corr.bm)) {
    corr[i] <- corr.bm[[i]]/corr.nb[[i]]
  }

  B <- diag(corr, nrow = length(corr))
  
  return(B)
}

library(citr)
library(magick)
```


# Abstract {-}

Stationarity is widely assumed in spatial statistics models for Spatial Gaussian Fields (SGFs), such as the Matérn model. However in the presence of physical barriers, this assumption no longer holds. Barrier models have been successfully proposed as a solution for non-stationary cases, yet they rely on all barriers being impermeable, which is quite restrictive when barriers are of different nature. For applications requiring a model that includes barriers with different permeability, the Transparent Barrier model is proposed.

The Transparent Barrier model follows the same principal as the Barrier model proposed for non-stationary Gaussian fields with physical barriers. Firstly, a stochastic partial differential equation (SPDE) is proposed to be the solution for a spatial Gaussian field (SGF) with a Matérn correlation function. Secondly, this Matérn field does not longer rely on the Euclidean distance between two points for the construction of the covariance matrix function, but on a collection of all possible paths between the points. 

The structural difference between the Barrier model and the Transparent Barrier model is that the former aims at removing the collection of paths crossing the barrier. While our proposed model has the objective of weakening these paths in whatever manner we see fit depending on the nature of the barrier. 

Barriers of different nature are often encountered in real life applications as we will show using Dugong data on the Red Sea Coast. The Transparent Barrier model can handle these complex spatial structures while keeping the efficiency of stationary models in R-INLA.

# Introduction 

Spatial Gaussian fields (SGFs) are widely used in modeling spatial and spatio-temporal phenomena, particularly in applications where residual spatial structures arise due to unmeasured covariates, spatial aggregation, or spatial noise. Among these, the Matérn model is a prominent choice for its flexibility and diverse applications. Advances such as the integrated nested Laplace approximation (INLA) (Rue et al., 2009) and stochastic partial differential equation (SPDE) approach (Lindgren et al., 2011) also support the use of the Matérn model by enabling efficient Bayesian inference and computational feasibility.

One weakness is SGFs like the Matérn model rely on assumptions of stationarity and isotropy, implying spatial autocorrelation modeled through the random effect remains unchanged when the map is rotated. However, these assumptions become unrealistic in the presence of physical barriers, boundaries, or irregular features, such as coastlines or islands, where spatial dependency should not be based solely on the shortest Euclidean distance. Such cases require models that account for the effects of physical barriers.

The Barrier model was proposed to address this challenge by extending the Matérn framework to non-stationary settings. Instead of relying on the shortest Euclidean distance to determine spatial dependence, the Barrier model accounts for all potential connections between two locations. When physical barriers are present the paths that go over the barrier are removed weakening the overall dependency between the two locations.

While the original Barrier model is limited to physically impermeable barriers, many real-world scenarios involve barriers with varying permeability. To address this, the Transparent Barrier model has been developed, introducing a framework to account for barriers with partial permeability. For instance, islands may act as impermeable barriers for marine species, whereas sand patches with tidal water coverage may allow partial movement. The Transparent Barrier model extends the original by incorporating transparency as a parameter controlling permeability, enabling it to handle both fully impermeable and partially permeable barriers within the same model. The latter class of barriers will be called transparent barriers.

This research introduces the Transparent Barrier model and demonstrates its application in real-world spatial settings. It retains the computational efficiency of stationary models while addressing the complexity of spatial structures influenced by barriers of varying nature, making it a practical and versatile tool for spatial modeling in marine science and beyond.

# Motivation 

Marine megafauna, such as whales, sharks, and large rays, play crucial roles in the health and functioning of marine ecosystems. These species are often regarded as keystone species, having a disproportionate impact on their ecosystems by influencing the abundance and distribution of other organisms. For example, Dugongs play an important role in seagrass ecosystems by grazing on seagrass beds, which helps maintain the health and diversity of these habitats. Their feeding activity prevents seagrass overgrowth, allowing for the growth of diverse plant species and promoting habitat complexity that supports a variety of marine organisms. Thus, conservation efforts focused on marine megafauna are not only vital for the survival of these species but also for maintaining the overall resilience of marine ecosystems.

Species distribution models (SDMs) are a cornerstone of research on marine megafauna, providing valuable insights into species distributions, habitat preferences, and ecological interactions. The most common SDM models predict species occurrence based on environmental variables such as temperature and ocean currents, often using algorithms like MaxEnt, Random Forest, and Generalized Additive Models (GAMs). While these are powerful for assessing habitat suitability and projecting responses to environmental changes, their effectiveness is heavily reliant on the quality and completeness of the input data. When environmental data is insufficient or missing, SDMs that incorporate spatial random effects to account for unexplained spatial dependencies become essential. These random effects allow the model to capture variations in species distribution that cannot be fully explained by environmental factors alone. 

This study focuses on modeling the distribution of Dugongs (Dugong dugon) along the northern coast of the Saudi Arabian Red Sea, a region characterized by a complex spatial structure with numerous islands and varying physical barriers. The area presents additional challenges due to the imprecision of available maps, which group islands together rather than providing detailed spatial data. Bathymetry data was the only covariate available for this region, however, due to the lack of precise maps showing the islands, bathymetry had to be used not as a covariate for the model, but to construct a map of the study area itself. This construction was necessary to ensure the accurate representation of island locations, which were otherwise unclear. *This highlights the previously mentioned limitations of common methods like MaxEnt, Random Forest, and GAMs which rely on having a broader set of environmental variables to model species distribution accurately. With only bathymetric data available, these methods cannot be applied in this context.*

By developing a species distribution model that accounts for spatial random effects and permeable physical barriers, this research seeks to contribute to the conservation of Dugongs and other marine megafauna on the Red Sea region, also serving as a guideline for any other study where the context demands this kind of modeling. 

The Dugong data used in this study comes from incidental sightings, meaning it is collected opportunistically as a byproduct of activities such as tourism, research cruises, or citizen science initiatives. The Poisson process framework offers an appropriate modeling approach for random events occurring in continuous space or time, like our Dugong sightings. Additionally, bathymetry was provided by the Red Sea Global (RSG) project.

# Model

## Background

In spatial statistics, the Matérn model with Matérn covariance is frequently employed for representing SGFs (Whittle, 1954; Stein, 1999; Diggle, 2010)). Contributing to its interest is the INLA-SPDE framework (Rue et al., 2009; Lindgren et al., 2011) which reduces the burden of dealing with large covariance matrices by relying on sparse precision matrices. This has led to extensive use of the Matérn covariance not only in Gaussian likelihood settings, but also in more complex contexts such as marked point pattern models (Illian et al., 2012; Simpson..). 

The Matérn covariance for the random process $\mu(s)$ built as a function of the distance $||s_i-s_j||$ between points $s_i$ and $s_j$ is given by

$$Cov\left(\mu(s_i), \mu(s_j)\right)=\sigma_{\mu}^2 \frac{2^{1-\nu}}{\Gamma(\nu)}\left( \kappa\left\|s_i-s_j\right\| \right)^{\nu}K_\nu\left(\kappa\left\|s_i-s_j\right\| \right)$$

where $\sigma_{\mu}^2$ is the marginal standard deviation for the random process $\mu$, $K_\nu$ the modified Bessel function of second order, and $\nu>0$, and $\kappa>0$, the smoothness and scaling parameters. 

By setting $\nu=1$ and $\kappa$ to its empirically derived definition $\kappa = \sqrt{8 \nu}/r$ we get

$$Cov\left(\mu(s_i), \mu(s_j)\right)=\sigma_{\mu}^2 \left (\frac{\sqrt{8}}{r}\left\|s_i-s_j\right\|\right ) K_1 \left (\frac{\sqrt{8}}{r}\left\|s_i-s_j\right\|\right )$$
where $r=\sqrt{8 \nu}/\kappa$ the range parameter. $r$ is constant and interpretable since it is the number of units such that the correlation between two points is approximately $0.1$.

Because the Matérn covariance is a function of the Euclidean distance the SGF is assumed to be stationary and isotropic (from here on both qualities are referred to as stationarity), implying that the random process remains unchanged when the underlying map is moved or rotated. 

By introducing different Matérn fields on barriers and non barrier areas the Barrier model proposed in @bakka_non-stationary_2019 extends the INLA-SPDE framework to non-stationary SGFs. 

## Transparent Barrier Model

### INLA-SPDE framework

The SPDE approach constructs a continuously indexed approximation of the Gaussian random field by using an SPDE model instead of a discrete model on a set on a grid. The Matérn field $\mu(s)$ is the stationary solution of an SPDE. For the Barrier model a different Matérn field was introduced on normal area and barrier area, then $\mu(s)$ is the solution to

$$\begin{aligned}
& \mu(s)-\nabla \cdot \frac{r_n^2}{8} \nabla \mu(s)=r_n \sqrt{\frac{\pi}{2}} \sigma_{\mu} \mathcal{W}(s), \quad\text { for } s \in \Omega_n \\
& \mu(s)-\nabla \cdot \frac{r_b^2}{8} \nabla \mu(s)=r_b \sqrt{\frac{\pi}{2}} \sigma_{\mu} \mathcal{W}(s), \quad\text { for } s \in \Omega_b,
\end{aligned}$$

where $\Omega_n$ is the normal area, $\Omega_b$ the barrier area, and the disjoint union of both $\Omega_n$ and $\Omega_b$ gives the whole study area $\Omega$. $r_n$ is the range parameter for the normal area, and $r_b$ is the range parameter for the barrier. $r_b$ is close to $0$ to remove the correlation in this area, and it is a fixed fraction of $r_n$ so that $r_b=r_n/h$, where $h$ is a constant (e.g. $10$). $\nabla=\left(\frac{\partial}{\partial x}, \frac{\partial}{\partial y}\right)$, $\sigma_{\mu}$ is the same constant as *eq1*, and $\mathcal{W}(s)$ is white noise.

The Transparent Barrier model approach comes directly from the barrier model. The difference is in thinking of the study area $\Omega$ not only as $\Omega_n$ and $\Omega_b$, but $\Omega_n$ and $\Omega_{b_{i}}$ with $i=1,...,l$ and $l$ the number of barriers with different permeability. Then the SPDE representation for the Matérn field for the normal area and the Matérn field for the different types of barriers is

$$\begin{aligned}
& \mu(s)-\nabla \cdot \frac{r_n^2}{8} \nabla \mu(s)=r_n \sqrt{\frac{\pi}{2}} \sigma_{\mu} \mathcal{W}(s), \quad\text { for } s \in \Omega_n \\
& \mu(s)-\nabla \cdot \frac{r_{b_1}^2}{8} \nabla \mu(s)=r_{b_1} \sqrt{\frac{\pi}{2}} \sigma_{\mu} \mathcal{W}(s), \quad\text { for } s \in \Omega_{b_1} \\
& \mu(s)-\nabla \cdot \frac{r_{b_2}^2}{8} \nabla \mu(s)=r_{b_2} \sqrt{\frac{\pi}{2}} \sigma_{\mu} \mathcal{W}(s), \quad\text { for } s \in \Omega_{b_2}\\
& \vdots \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \vdots \\ 
& \mu(s)-\nabla \cdot \frac{r_{b_l}^2}{8} \nabla \mu(s)=r_{b_l} \sqrt{\frac{\pi}{2}} \sigma_{\mu} \mathcal{W}(s), \quad\text { for } s \in \Omega_{b_l}
\end{aligned}$$

With INLA, computational speed and accuracy comes from the sparse precision matrix representation $\mathbf{Q} = \mathbf{\Sigma}^{-1}$. To compute $\mathbf{Q}$, and approximate the continuously indexed Gaussian field $u(s)$ in a finite-dimensional setting, we employ a discretization scheme based on the finite element method (FEM).

At each mesh node *fig* a linear finite element basis function \( \psi_i(s) \) 
is defined and takes a value of 1 at node \( i \) and 0 at all other nodes. The spatial field approximation $\tilde{u}(s)$ is then $\tilde{u}(s) = \sum_{i=1}^{n} u_i \psi_i(s)$, where \( n \) denotes the total number of mesh nodes. The coefficients \( u_i \) are Gaussian random variables with precision matrix \( Q \).

On the other side, reformulating the SPDE results in the following

\[
\left[ 1 - \nabla \frac{r(s)^2}{8} \nabla \right] u(s) = r(s) \sqrt{\frac{\pi}{2}} W(s),
\]

where \( r(s) \) defines the spatially varying range parameter, partitioned into subdomains \( \Omega_q \) such that \( r(s) = r_q \) for each \( \Omega_q \) with \( q=1,...,k\). 

Using the finite elements we reformulate the SPDE in weak form, yielding

\[
\left\langle \psi_j, \left[ 1 - \nabla \frac{r(·)^2}{8} \nabla \right] \tilde{u} \right\rangle =
\left\langle \psi_j, r(·) \sqrt{\frac{\pi}{2}} W(·) \right\rangle.
\]

The inner product \( \langle f, g \rangle = \int f(s) g(s) \text {d}s\) represents integration over the spatial domain. From this formulation, we define the key finite element matrices

\[
J_{i,j} = \langle \psi_i, \psi_j \rangle, \quad
(D_q)_{i,j} = \langle 1_{\Omega_q} \nabla \psi_i, \nabla \psi_j \rangle, \quad
(C_q)_{i,i} = \langle 1_{\Omega_q} \psi_i, 1 \rangle.
\]

The final system of equations plus the approximation for $\tilde{u}(s)$ leads to $A\tilde{u}=\epsilon$ where $A$ is a matrix of the form

\[
A = J - \frac{1}{8} \sum_{q=1}^{k} r_q^2 D_q.
\]

and $\epsilon$ a multivariate Gaussian with 

\[
\text{Cov}(\epsilon) \approx \tilde{C} = \frac{\pi}{2} \sum_{q=1}^{k} r_q^2 \tilde{C}_q.
\]

With this formulation, we obtain a sparse precision matrix \( Q = A \tilde{C}^{-1} A \), which is crucial for efficient computations in large-scale spatial models.


For the marginal standard deviation of the field at a given location \( s \), we retain the spatially varying standard deviation as derived from solving the SPDE. This approach naturally results in increased prior uncertainty in regions such as narrow inlets, where spatial constraints influence movement patterns. The non-uniform marginal standard deviation aligns with real-world spatial processes—areas with restricted movement exhibit greater variation in occupancy, as they are either highly concentrated or nearly unoccupied. This interpretation emerges naturally from SPDE framework, where the modeled field represents the expected location of a randomly moving entity constrained by the differential operator. 




## Mesh

Use https://haakonbakkagit.github.io/btopic103.html#3_Simulate_data
Add from Dolphin paper

The system of differential equations in (2) can be solved by constructing a Delaunay triangulation of the study area (Fig. 1) and then applying the finite element method as explained in Bakka et al. (2019). 



```{r, echo=FALSE, out.width="100%", fig.cap= "Delaunay triangulation for the different geometries used"}
r <- magick::image_read("plots/mesh/mesh1.png")
t <- magick::image_read("plots/mesh/mesh1.1.png")
t <- magick::image_scale(t, "350")

y <- magick::image_read("plots/mesh/mesh2.png")
u <- magick::image_read("plots/mesh/mesh2.2.png")
u <- magick::image_scale(u, "350")


a <- c(r,t); a <- image_append(a, stack = F)
b <- c(y,u); b <- image_append(b, stack = F)
image_append(c(a,b), stack = TRUE)
```


```{r, eval=FALSE, echo=FALSE, out.width="100%", fig.cap= "Delaunay triangulation for the different geometries used"}
r <- magick::image_read("gif.sel/geom1/mesh.g880.png")
r <- magick::image_crop(r, geometry = "320x200+000+30")

t <- magick::image_read("gif.sel/geom2/mesh.g987.png")
t <- magick::image_crop(t, geometry = "320x200+000+30")
img <- c(r,t)

image_append(img, stack = TRUE)
```

```{r, eval = FALSE, echo=FALSE, out.width="70%", fig.cap= "Mesh and data for Poisson observations"}
r <- magick::image_read("gif.sel/geom1/mesh.pp874.png")
r <- magick::image_crop(r, geometry = "320x200+000+30")
img <- c(r)

image_append(img, stack = TRUE)

## Mesh geom 2

r <- magick::image_read("gif.sel/geom2/mesh.pp763.png")
r <- magick::image_crop(r, geometry = "320x200+000+30")
img <- c(r)

image_append(img, stack = TRUE)
```

## Correlation Plots

```{r, echo=FALSE, out.width="100%", fig.cap= "Correlation structure of some specific points (black dots) for the Transparent barrier model in row 1, the Barrier model in row 2, and the stationary model in row 3. For the Transparent Barrier model both the left and the right barrier have the same range fraction 0.5."}
r <- magick::image_read("gif.sel/geom1/corr2points.pp874.png")
img <- c(r)
image_append(img, stack = TRUE)

```

```{r, echo=FALSE, out.width="100%", fig.cap= "Correlation structure of some specific points (black dots) for the Transparent barrier model in row 1, the Barrier model in row 2, and the stationary model in row 3. For the Transparent Barrier model the left barrier is impermeable with range fraction 0.01, and the right barrier is a transparent barrier with range fraction 0.5"}
r <- magick::image_read("gif.sel/geom1.2/corr2points.pp874.png")
img <- c(r)
image_append(img, stack = TRUE)

```


# Results

## Simulation for Gaussian observations

```{r, echo=FALSE, out.width="100%", fig.cap= "Two symmetrical barrier scenario: for the different models the spatial estimate is shown on the left and the density of the range hyperparameter on the right. Row one shows the results for the Transparent Barrier model, row two for the Barrier model and row three for the stationary model."}
r <- magick::image_read("gif.sel/geom1/g1.png")
image_append(r)
```



```{r, echo=FALSE, out.width="100%", fig.cap= "Two symmetrical barrier scenario: for the different models the spatial estimate is shown on the left and the density of the range hyperparameter on the right. Row one shows the results for the Transparent Barrier model, row two for the Barrier model and row three for the stationary model."}
r <- magick::image_read("gif.sel/geom1/g1.pp.png")
image_append(r)
```



```{r, echo=FALSE, out.width="100%", fig.cap= "Correlation structure of some specific points (black dots) for the Transparent barrier model in row 1, the Barrier model in row 2, and the stationary model in row 3. For the Transparent Barrier model both the left and the right barrier have the same range fraction 0.5."}
r <- magick::image_read("gif.sel/geom2/corr2points.pp763.png")
img <- c(r)
image_append(img, stack = TRUE)

```

```{r, echo=FALSE, out.width="100%", fig.cap= "Correlation structure of some specific points (black dots) for the Transparent barrier model in row 1, the Barrier model in row 2, and the stationary model in row 3. For the Transparent Barrier model the left barrier is impermeable with range fraction 0.01, and the right barrier is a transparent barrier with range fraction 0.5"}
r <- magick::image_read("gif.sel/geom2.2/corr2points.pp763.png")
img <- c(r)
image_append(img, stack = TRUE)

```


# Results

### Log-Gaussian Cox Process (LGCP)

Additionally, we will consider non-Gaussian observations as they often appear in real-world applications in particular  modeling point processes is needed for a wide range of data.

A point pattern refers to the arrangement or distribution of individual points or locations within a study area. These points represent the sampled elements for which occurrence is assumed to be influenced by an inherent spatial process. The underlying process is modeled using an intensity function \( \lambda(s) \), which is taken to be the intensity of a Poisson process.

A Cox Process is used for analyzing the distribution of events or occurrences in a continuous spatial domain where the number of events in a region $A$ follow a Poisson process with intensity $\lambda_A$.

$$\lambda_A=\int_A\lambda(s)ds$$
In the log-Gaussian Cox process (LGCP), the intensity function is assumed to be an exponentiated Gaussian random field

\[
\log \lambda(s) = Z(s)
\]

where \( Z(s) \) is a Gaussian random field. 

A method for fitting LGCP models considering an SPDE approach was developed by @simpson_going_2016. Because of it, it is possible to fit an LGCP model over a mesh instead of a regular grid. The integration of the SPDE approach allows for computationally scalable inference.


## Simulation for Gaussian observations

```{r, echo=FALSE, out.width="100%", fig.cap= "Two symmetrical barrier scenario: for the different models the spatial estimate is shown on the left and the density of the range hyperparameter on the right. Row one shows the results for the Transparent Barrier model, row two for the Barrier model and row three for the stationary model."}
r <- magick::image_read("gif.sel/geom2/g2.png")
image_append(r)
```



```{r, echo=FALSE, out.width="100%", fig.cap= "Two symmetrical barrier scenario: for the different models the spatial estimate is shown on the left and the density of the range hyperparameter on the right. Row one shows the results for the Transparent Barrier model, row two for the Barrier model and row three for the stationary model."}
r <- magick::image_read("gif.sel/geom2/g2.pp.png")
image_append(r)
```

# Applied example

### Point processes and LGCP 

A point pattern refers to the arrangement or distribution of individual points or locations within a study area. These points represent the sampled elements for which occurrence we assume to be influenced by an inherent spatial process. The underlying process is modeled using an intensity function $\lambda(s)$, which it is taken to be the intensity of a Poisson process. 

A Cox Process is used for analyzing the distribution of events or occurrences in a continuous spatial domain where the number of events in a region $A$ follow a Poisson process with intensity $\lambda_A$.

$$\lambda_A=\int_A\lambda(s)ds$$

Particularly the intensity function of the Cox process is log-transformed for a Log-Gaussian Cox Process (LGCP). We then assume that conditional on a set of hyper-parameters, the logarithm of the intensity function follows a Gaussian distribution. The Gaussian process is used to model the spatial variation in the log-intensity function. It is a stochastic process where the values at any finite set of locations are jointly Gaussian distributed. Then, $log(\lambda(s)) = \beta_0 +u(s)$, with $\beta_0$ a fixed value and $u(s)$ a Gaussian process with Matérn covariance and zero mean. Moreover, an LGCP is an inhomogeneous Poisson process, conditional on a realization of $u(s)$.

A method for fitting LGCP models considering an SPDE approach was developed by @simpson_going_2016. Because of it it is possible to fit an LGCP model over a mesh instead of a regular grid. 

```{r, echo=FALSE, out.width="70%", fig.cap= "Satellite image of (a part) the study area, and mesh constructed over water and land. On the mesh, land is in white and deep sea is the area covered in pink shade."}
r <- magick::image_read("dng_plots/dngmesh.png")
image_append(r)
```

```{r, echo=FALSE, out.width="100%", fig.cap= "Study area and barriers."}
r <- magick::image_read("plots/study.area.png")
image_append(r)
```

```{r, echo=FALSE, out.width="70%", fig.cap= "Delaunay triangulation of the study area. Mesh constructed over water and land. On the mesh, land is in white and deep sea is the area covered in pink shade.."}
r <- magick::image_read("plots/mesh.dng.png")
image_append(r)
```

```{r, echo=FALSE, out.width="100%", fig.cap="Close of a part of the mesh"}
r <- magick::image_read("plots/mesh.dngx2.png")
image_append(r)
```

```{r, echo=FALSE, out.width="100%", fig.cap= "Posterior Density."}
r <- magick::image_read("plots/pos.dng.png")
image_append(r)
```

```{r, echo=FALSE, out.width="80%", fig.cap= "Correlation structure with respect to one point using i) the existing Barrier model considering only land as barrier; ii) the existing Barrier model considering land and deep sea as barrier; iii) and the Transparent Barrier model considering land as an impermeable barrier and deep sea as a transparent barrier."}
r <- magick::image_read("dng_plots/corrst.png")
image_append(r)
```

```{r, echo=FALSE, out.width="50%", fig.cap= "Posterior field stationary model."}
r <- magick::image_read("plots/field.posBM.png")
image_append(r)
```

```{r, echo=FALSE, out.width="50%", fig.cap= "Posterior field Transparent Barrier model."}
r <- magick::image_read("plots/field.posBM2.png")
image_append(r)
```

```{r, echo=FALSE, out.width="50%", fig.cap= "Mesh and data for Dugong."}
r <- magick::image_read("plots/mesh.points.png")
image_append(r)
```


## Notes for discussion


This approach allows for computational efficiency while preserving the spatial structure of the model. Unlike grid-based methods, which require interpolation post-processing, FEM constructs a piecewise linear representation directly on a mesh, eliminating additional approximation errors.

Something on boudary conditions:
The boundary conditions are set as Neumann conditions on \( \partial\Omega \), ensuring proper treatment of domain edges.


## Notes for results

For the marginal standard deviation of the field at a given location \( s \), we retain the spatially varying standard deviation as derived from solving the SPDE. This approach naturally results in increased prior uncertainty in regions such as narrow inlets, where spatial constraints influence movement patterns. The non-uniform marginal standard deviation aligns with real-world spatial processes—areas with restricted movement exhibit greater variation in occupancy, as they are either highly concentrated or nearly unoccupied.

This interpretation emerges naturally from the stochastic partial differential equation (SPDE) framework, where the modeled field represents the expected location of a randomly moving entity constrained by the differential operator. *For instance, in an archipelago setting, mobile organisms such as fish or marine mammals may be less likely to traverse narrow passages but, once within these regions, they tend to stay longer. Consequently, the model captures this increased variability, reflecting greater uncertainty in confined areas compared to open waters, a property that a stationary Gaussian field model would fail to incorporate.*

Unlike stationary spatial effects, the underlying idea is to construct a Gaussian Markov random field (GMRF) locally, with one governing equation for the normal area (sea), and another for the barrier area (earth). The prior spatial effect only depends on two unknown hyperparameters, the standard deviation (σu) and the range in the normal area (r), because the range in the barrier area (rb) is fixed at close to zero. As a result, the system in (2) represents a local averaging of nearby values. If there are two points separated by a landmass, the very small range stops the local averaging on the barrier. It forces the dependency to focus on moving around the barrier, via local averages in the water area. 


```{r, echo=FALSE, out.width="70%", fig.cap= "Correlation plots range fraction 1, 0.2, 0.3, 0.5, 0.7, 0.8, 1"}
##0.01
##bm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.01/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.01/bm0.01.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.01/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.01/st0.01.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.01/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.01/tbm0.01.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
i <- image_append(c(d,f), stack = F)

##0.2
##bm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.2/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.2/bm0.2.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.2/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.2/st0.2.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.2/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.2/tbm0.2.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
o <- image_append(c(d,f), stack = F)

##0.3
##bm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.3/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.3/bm0.3.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.3/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.3/st0.3.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.3/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.3/tbm0.3.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
p <- image_append(c(d,f), stack = F)

##0.4
##bm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.4/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.4/bm0.4.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.4/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.4/st0.4.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.4/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.4/tbm0.4.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
l <- image_append(c(d,f), stack = F)

##0.5
##bm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.5/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.5/bm0.5.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.5/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.5/st0.5.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.5/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.5/tbm0.5.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
k <- image_append(c(d,f), stack = F)

##0.7
##bm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.7/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.7/bm0.7.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.7/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.7/st0.7.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.7/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.7/tbm0.7.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
j <- image_append(c(d,f), stack = F)

##0.8
##bm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.8/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.8/bm0.8.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.8/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.8/st0.8.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.8/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom1.2_2/sm1.5w3r2seed880.n30fr0.8/tbm0.8.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
h <- image_append(c(d,f), stack = F)

a <- image_append(c(i,o,p,l,k,j,h), stack = T)
#image_write(a, path = "plots/geom1.2_2/all.png", format = "png")
```


```{r, echo=FALSE, out.width="70%", fig.cap= "Correlation plots range fraction 1, 0.2, 0.3, 0.5, 0.7, 0.8, 1"}
##0.01
##bm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.01/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.01/bm0.01.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.01/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.01/st0.01.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.01/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.01/tbm0.01.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
i <- image_append(c(d,f), stack = F)

##0.2
##bm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.2/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.2/bm0.2.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.2/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.2/st0.2.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.2/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.2/tbm0.2.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
o <- image_append(c(d,f), stack = F)

##0.3
##bm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.3/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.3/bm0.3.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.3/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.3/st0.3.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.3/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.3/tbm0.3.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
p <- image_append(c(d,f), stack = F)

##0.4
##bm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.4/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.4/bm0.4.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.4/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.4/st0.4.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.4/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.4/tbm0.4.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
l <- image_append(c(d,f), stack = F)

##0.5
##bm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.5/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.5/bm0.5.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.5/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.5/st0.5.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.5/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.5/tbm0.5.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
k <- image_append(c(d,f), stack = F)

##0.7
##bm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.7/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.7/bm0.7.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.7/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.7/st0.7.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.7/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.7/tbm0.7.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
j <- image_append(c(d,f), stack = F)

##0.8
##bm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.8/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.8/bm0.8.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.8/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.8/st0.8.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.8/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2/sm0w1r4seed987.n50fr0.8/tbm0.8.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
h <- image_append(c(d,f), stack = F)

a <- image_append(c(i,o,p,l,k,j,h), stack = T)
#image_write(a, path = "plots/geom2/all.png", format = "png")
```


```{r, echo=FALSE, out.width="70%", fig.cap= "Correlation plots range fraction 1, 0.2, 0.3, 0.5, 0.7, 0.8, 1"}
##0.01
##bm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.01/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.01/bm0.01.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.01/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.01/st0.01.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.01/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.01/tbm0.01.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
i <- image_append(c(d,f), stack = F)

##0.2
##bm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.2/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.2/bm0.2.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.2/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.2/st0.2.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.2/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.2/tbm0.2.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
o <- image_append(c(d,f), stack = F)

##0.3
##bm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.3/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.3/bm0.3.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.3/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.3/st0.3.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.3/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.3/tbm0.3.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
p <- image_append(c(d,f), stack = F)

##0.4
##bm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.4/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.4/bm0.4.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.4/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.4/st0.4.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.4/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.4/tbm0.4.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
l <- image_append(c(d,f), stack = F)

##0.5
##bm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.5/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.5/bm0.5.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.5/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.5/st0.5.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.5/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.5/tbm0.5.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
k <- image_append(c(d,f), stack = F)

##0.7
##bm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.7/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.7/bm0.7.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.7/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.7/st0.7.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.7/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.7/tbm0.7.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
j <- image_append(c(d,f), stack = F)

##0.8
##bm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.8/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.8/bm0.8.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.8/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.8/st0.8.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.8/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3.2pp/sm1.5wl1wr4r2seed84fr0.8/tbm0.8.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
h <- image_append(c(d,f), stack = F)

a <- image_append(c(i,o,p,l,k,j,h), stack = T)
#image_write(a, path = "plots/geom3.2pp/all.png", format = "png")
```

```{r, echo=FALSE, out.width="70%", fig.cap= "Correlation plots range fraction 1, 0.2, 0.3, 0.5, 0.7, 0.8, 1"}
##0.01
##bm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.01/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.01/bm0.01.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.01/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.01/st0.01.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.01/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.01/tbm0.01.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
i <- image_append(c(d,f), stack = F)

##0.2
##bm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.2/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.2/bm0.2.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.2/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.2/st0.2.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.2/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.2/tbm0.2.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
o <- image_append(c(d,f), stack = F)

##0.3
##bm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.3/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.3/bm0.3.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.3/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.3/st0.3.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.3/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.3/tbm0.3.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
p <- image_append(c(d,f), stack = F)

##0.4
##bm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.4/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.4/bm0.4.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.4/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.4/st0.4.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.4/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.4/tbm0.4.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
l <- image_append(c(d,f), stack = F)

##0.5
##bm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.5/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.5/bm0.5.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.5/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.5/st0.5.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.5/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.5/tbm0.5.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
k <- image_append(c(d,f), stack = F)

##0.7
##bm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.7/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.7/bm0.7.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.7/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.7/st0.7.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.7/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.7/tbm0.7.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
j <- image_append(c(d,f), stack = F)

##0.8
##bm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.8/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.8/bm0.8.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.8/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.8/st0.8.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.8/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom3pp/sm1.5wl1wr4r2seed84fr0.8/tbm0.8.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
h <- image_append(c(d,f), stack = F)

a <- image_append(c(i,o,p,l,k,j,h), stack = T)
#image_write(a, path = "plots/geom3pp/all.png", format = "png")
```

```{r, echo=FALSE, out.width="70%", fig.cap= "Correlation plots range fraction 1, 0.2, 0.3, 0.5, 0.7, 0.8, 1"}
##0.01
##bm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.01/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.01/bm0.01.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.01/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.01/st0.01.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.01/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.01/tbm0.01.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
i <- image_append(c(d,f), stack = F)

##0.2
##bm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.2/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.2/bm0.2.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.2/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.2/st0.2.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.2/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.2/tbm0.2.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
o <- image_append(c(d,f), stack = F)

##0.3
##bm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.3/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.3/bm0.3.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.3/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.3/st0.3.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.3/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.3/tbm0.3.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
p <- image_append(c(d,f), stack = F)

##0.4
##bm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.4/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.4/bm0.4.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.4/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.4/st0.4.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.4/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.4/tbm0.4.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
l <- image_append(c(d,f), stack = F)

##0.5
##bm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.5/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.5/bm0.5.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.5/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.5/st0.5.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.5/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.5/tbm0.5.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
k <- image_append(c(d,f), stack = F)

##0.7
##bm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.7/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.7/bm0.7.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.7/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.7/st0.7.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.7/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.7/tbm0.7.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
j <- image_append(c(d,f), stack = F)

##0.8
##bm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.8/mean.bm.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.8/bm0.8.png")
w <- magick::image_scale(w, geometry = "420")
a <- image_append(c(q,w), stack = F)
#st
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.8/mean.st.gif")
q <- magick::image_crop(q, geometry = "480x460-85+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.8/st0.8.png")
w <- magick::image_scale(w, geometry = "420")
s <- image_append(c(q,w), stack = F)
#tbm
q <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.8/mean.tbm.gif")
q <- magick::image_crop(q, geometry = "480x480-0+00")
w <- magick::image_read("plots/geom2.2pp/sm0w1r4seed273fr0.8/tbm0.8.png")
w <- magick::image_scale(w, geometry = "420")
d <- image_append(c(q,w), stack = F)
d <- image_scale(d, "400")
#all
f <- image_append(c(a,s), stack = T)
f <- image_scale(f, "200")
h <- image_append(c(d,f), stack = F)

a <- image_append(c(i,o,p,l,k,j,h), stack = T)
#image_write(a, path = "plots/geom2.2pp/all.273.png", format = "png")
```

```{r}
magick::image_read("plots/geom1.2_2/all.png")
```


## Project 2

```{r, echo=FALSE, fig.cap= "Drone survey and coverage in Sindalah area 2024."}
#r <- magick::image_read("plots/mesh/geom1.2.mesh.png")
#r <- magick::image_scale(r, "190")
magick::image_read("plots/map.data.drona.png")
```

```{r, echo=FALSE, fig.cap= "Dugong sightings (30) from drone focal surveys"}
magick::image_read("plots/map.data.drona2.png")
```


## Project 3

```{r, echo=FALSE, out.width="70%", fig.cap= "Aerial survey: transect footprint and data."}
magick::image_read("plots/map.data3.png")
magick::image_read("plots/map.data4.png")
magick::image_read("plots/map.data5.png")
magick::image_read("plots/map.data6.png")
```

```{r, echo=FALSE, out.width="70%", fig.cap= "Different survey transects Sindalah Islands."}
magick::image_read("plots/survey1.png")
magick::image_read("plots/survey2.png")
magick::image_read("plots/survey3.png")

```


```{r, echo=FALSE, out.width="70%", fig.cap= "Overall sightings of dugongs during drone and MMO Surveys showing the bathymetry of the project area and spatial overlap of sightings with the proposed vessel route. Zones of high risk (red line) and medium risk (orange line) where speed restrictions of <10 km/s should be implemented are shown, as well as recommended rerouting into deeper, open water areas"}
#r <- magick::image_read("plots/mesh/geom1.2.mesh.png")
#r <- magick::image_scale(r, "190")
magick::image_read("plots/map.data1.png")

```

```{r, echo=FALSE, out.width="70%", fig.cap= "Overall sightings of dolphins during drone and MMO Surveys showing the bathymetry of the project area and spatial overlap of sightings with the proposed vessel route. Zones of high risk (red line) and medium risk (orange line) where speed restrictions of <10 km/s should be implemented are shown, as well as recommended rerouting into deeper, open water areas"}
#r <- magick::image_read("plots/mesh/geom1.2.mesh.png")
#r <- magick::image_scale(r, "190")
magick::image_read("plots/suvey4.png")
```

```{r, echo=FALSE, out.width="70%", fig.cap= "Overall sightings of marine megafauna during drone and MMO Surveys showing the bathymetry of the project area and spatial overlap of sightings with the proposed vessel route. Zones of high risk (red line) and medium risk (orange line) where speed restrictions of <10 km/s should be implemented are shown, as well as recommended rerouting into deeper, open water areas"}

magick::image_read("plots/map.data2.png")
```
