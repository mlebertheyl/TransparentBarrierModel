"0","transparency <- function(mesh = mesh, fem = fem, "
"0","                         barrier.triangles = barrier.triangles, "
"0","                     prior.range = c(1.44, 0.5), prior.sigma = c(0.7, 0.5),"
"0","                     range.fraction = range.fraction,"
"0","                     range = 3,"
"0","                     set.inla.seed = 2303, # make sure is the same as prev. fx if loc.data = T"
"0","                     loc.data = loc.data, "
"0","                     sigma.u = 1, sigma.epsilon = 0.2,"
"0","                     poly.original = poly.bar.orginal,"
"0","                     prior.range.st = c(1, 0.5),    "
"0","                     prior.sigma.st = c(1, 0.5),"
"0","                     return.list = TRUE) {"
"0","  "
"0","  # field = TRUE has to be true to start"
"0","  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, "
"0","                                              prior.range, prior.sigma, "
"0","                                              range.fraction)"
"0","  # range fraction has to have the same length as barrier triangles"
"0","  Q <- inla.rgeneric.q(barrier.model, ""Q"", theta = c(0, log(range)))"
"0","  u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))"
"0","  u <- u[ ,1]"
"0","    "
"0","  A.data <- inla.spde.make.A(mesh, loc.data)"
"0","  #Q from mydiff.r function"
"0","    "
"0","  u.data <- A.data %*% u"
"0","  "
"0","  df <- data.frame(loc.data)"
"0","  names(df) <- c('locx', 'locy')"
"0","  df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))"
"0","  "
"0","    "
"0","  stk <- inla.stack(data=list(y=df$y), "
"0","                    A=list(A.data, 1),"
"0","                    effects=list(s=1:mesh$n, "
"0","                                 intercept=rep(1, nrow(df))), "
"0","                    remove.unused = FALSE, "
"0","                    tag='est')"
"0",""
"0","    "
"0","  formula <- y ~ 0 + intercept + f(s, model = barrier.model)"
"0","  # - The spatial model component is different from stationary"
"0","  # - The rest of the model setup is the same as in the stationary case!"
"0","  # - - e.g. the inla(...) call below is the same, "
"0","  #     only this formula is different"
"0","  "
"0","    "
"0","  res.barrier <- inla(formula, data = inla.stack.data(stk),"
"0","                        control.predictor = list(A = inla.stack.A(stk)),"
"0","                        family = 'gaussian',"
"0","                        control.family = list(hyper = list("
"0","                          prec = list(prior = ""pc.prec"", fixed = FALSE, param = c(0.2,0.5)))),"
"0","                        control.mode=list(restart=T, theta=c(3.2, 0.4, 1.6)))"
"0","    "
"0","  model.stat <- inla.spde2.pcmatern(mesh, "
"0","                                    prior.range = c(prior.range.st[1], prior.range.st[2]),"
"0","                                    prior.sigma = c(prior.sigma.st[1], prior.sigma.st[2]))"
"0","  "
"0","  formula.st <- y ~ 0 + intercept + f(s, model=model.stat)"
"0","  "
"0","  res.stationary <- inla(formula.st, data=inla.stack.data(stk),"
"0","            control.predictor=list(A = inla.stack.A(stk)),"
"0","            family = 'gaussian',"
"0","            control.family = list(hyper = list(prec = list("
"0","              prior = ""pc.prec"", fixed = FALSE, "
"0","              param = c(0.2,0.5)))),"
"0","            control.mode=list(restart=T, theta=c(4,-1.7,0.25)))"
"0","  "
"0","  if (return.list == TRUE) {"
"0","    "
"0","    list.field <- list(barrier.model = barrier.model, Q = Q, sample = u)"
"0","    pos.bm <- list(df = df, res = res.barrier)"
"0","    pos.st <- list(res = res.stationary)"
"0","    "
"0","    return(list(list.field = list.field, pos.bm = pos.bm, pos.st = pos.st))"
"0","  }"
"0","                     "
"0","}"
"0",""
