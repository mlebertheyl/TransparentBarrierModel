"0","book.rMatern <- function(n, coords, sigma=1, range, kappa = sqrt(8*nu)/range, variance = sigma^2, nu=1) {"
"0","    m <- as.matrix(dist(coords))"
"0","    m <- exp((1-nu)*log(2) + nu*log(kappa*m)-"
"0","             lgamma(nu))*besselK(m*kappa, nu)"
"0","    diag(m) <- 1"
"0","    return(drop(crossprod(chol(variance*m),"
"0","                          matrix(rnorm(nrow(coords)*n), ncol=n))))"
"0","}"
"0",""
"0","book.rspde <- function(coords, sigma=1, range, variance=sigma^2, alpha=2, kappa = sqrt(8*(alpha-1))/range, n=1, mesh, "
"0","                  verbose=FALSE, seed, return.attributes=FALSE) {"
"0","    t0 <- Sys.time()"
"0","    theta <- c(-0.5*log(4*pi*variance*kappa^2), log(kappa))"
"0","    if (verbose) cat('theta =', theta, '\n')"
"0","    if (missing(mesh)) {"
"0","        mesh.pars <- c(0.5, 1, 0.1, 0.5, 1)*sqrt(alpha-ncol(coords)/2)/kappa "
"0","        if (verbose) cat('mesh.pars =', mesh.pars, '\n')"
"0","        attributes <- list("
"0","            mesh=inla.mesh.2d("
"0","                coords[chull(coords), ], max.edge=mesh.pars[1:2], "
"0","                cutoff=mesh.pars[3], offset=mesh.pars[4:5]))"
"0","        if (verbose) cat('n.mesh =', attributes$mesh$n, '\n')"
"0","    }"
"0","    else attributes <- list(mesh=mesh)"
"0","    attributes$spde <- inla.spde2.matern(attributes$mesh, alpha=alpha)"
"0","    attributes$Q <- inla.spde2.precision(attributes$spde, theta=theta)"
"0","    attributes$A <- inla.mesh.project(mesh=attributes$mesh, loc=coords)$A"
"0","    if (n==1) "
"0","        result <- drop(attributes$A%*%inla.qsample("
"0","            Q=attributes$Q,"
"0","            constr=attributes$spde$f$extraconstr))"
"0","    t1 <- Sys.time() "
"0","    result <- inla.qsample(n, attributes$Q, "
"0","                           seed=ifelse(missing(seed), 0, seed), "
"0","                           constr=attributes$spde$f$extraconstr) "
"0","    if (nrow(result)<nrow(attributes$A)) {"
"0","        result <- rbind(result, matrix("
"0","            NA, nrow(attributes$A)-nrow(result), ncol(result)))"
"0","        dimnames(result)[[1]] <- paste('x', 1:nrow(result), sep='')"
"0","        for (j in 1:ncol(result)) "
"0","            result[, j] <- drop(attributes$A%*%"
"0","                                result[1:ncol(attributes$A),j])"
"0","    }"
"0","    else {"
"0","        for (j in 1:ncol(result)) "
"0","            result[1:nrow(attributes$A), j] <-"
"0","                drop(attributes$A%*%result[,j]) "
"0","        result <- result[1:nrow(attributes$A), ]"
"0","    }"
"0","    t2 <- Sys.time()"
"0","    attributes$cpu <- c(prep=t1-t0, sample=t2-t1, total=t2-t0)"
"0","    if (return.attributes) "
"0","        attributes(result) <- c(attributes(result), attributes)"
"0","    return(drop(result))"
"0","}"
"0",""
"0","book.mesh.dual <- function(mesh) {"
"0","    if (mesh$manifold=='R2') {"
"0","        ce <- t(sapply(1:nrow(mesh$graph$tv), function(i)"
"0","            colMeans(mesh$loc[mesh$graph$tv[i, ], 1:2])))"
"0","        library(parallel)"
"0","        pls <- mclapply(1:mesh$n, function(i) {"
"0","            p <- unique(Reduce('rbind', lapply(1:3, function(k) {"
"0","                j <- which(mesh$graph$tv[,k]==i)"
"0","                if (length(j)>0) "
"0","                    return(rbind(ce[j, , drop=FALSE],"
"0","                                 cbind(mesh$loc[mesh$graph$tv[j, k], 1] +"
"0","                                       mesh$loc[mesh$graph$tv[j, c(2:3,1)[k]], 1], "
"0","                                       mesh$loc[mesh$graph$tv[j, k], 2] +"
"0","                                       mesh$loc[mesh$graph$tv[j, c(2:3,1)[k]], 2])/2))"
"0","                else return(ce[j, , drop=FALSE])"
"0","            })))"
"0","            j1 <- which(mesh$segm$bnd$idx[,1]==i)"
"0","            j2 <- which(mesh$segm$bnd$idx[,2]==i)"
"0","            if ((length(j1)>0) | (length(j2)>0)) {"
"0","                p <- unique(rbind(mesh$loc[i, 1:2], p,"
"0","                                  mesh$loc[mesh$segm$bnd$idx[j1, 1], 1:2]/2 +"
"0","                                  mesh$loc[mesh$segm$bnd$idx[j1, 2], 1:2]/2, "
"0","                                  mesh$loc[mesh$segm$bnd$idx[j2, 1], 1:2]/2 +"
"0","                                  mesh$loc[mesh$segm$bnd$idx[j2, 2], 1:2]/2))"
"0","                yy <- p[,2]-mean(p[,2])/2-mesh$loc[i, 2]/2"
"0","                xx <- p[,1]-mean(p[,1])/2-mesh$loc[i, 1]/2"
"0","            }"
"0","            else {"
"0","                yy <- p[,2]-mesh$loc[i, 2]"
"0","                xx <- p[,1]-mesh$loc[i, 1]"
"0","            }"
"0","            Polygon(p[order(atan2(yy,xx)), ])"
"0","        })"
"0","        return(SpatialPolygons(lapply(1:mesh$n, function(i)"
"0","            Polygons(list(pls[[i]]), i))))"
"0","    }"
"0","    else stop(""It only works for R2!"")"
"0","}"
"0",""
"0","genColor <- function(n, type=c('red', 'green', 'blue'), u=NULL) {"
"0","    cbp <- list("
"0","        red = list(c(255, 254, 252, 252, 251, 239, 203, 165, 103), "
"0","                   c(245, 224, 187, 146, 106, 59, 24, 15, 0), "
"0","                   c(240, 210, 161, 114, 74, 44, 29, 21, 13)), "
"0","        green = list(c(247, 229, 199, 161, 116, 65, 35, 0, 0), "
"0","                     c(252, 245, 233, 217, 196, 171, 139, 109, 68), "
"0","                     c(245, 224, 192, 155, 118, 93, 69, 44, 27)), "
"0","        blue = list(c(247, 222, 198, 158, 107, 66, 33, 8, 8), "
"0","                    c(251, 235, 219, 202, 174, 146, 113, 81, 48), "
"0","                    c(255, 247, 239, 225, 214, 198, 181, 156, 107)))"
"0","    if (n<2) stop(""Works for 'n>2'!"")"
"0","    if (is.null(u))"
"0","        u <- 0:(n-1)/(n-1)"
"0","    u0 <- 0:8/8"
"0","    i <- findInterval(u, u0, TRUE)"
"0","    k <- pmatch(match.arg(type), c('red', 'green', 'blue'))"
"0","    w1 <- 8*(u0[i+1]-u)/255; w2 <- 8*(u-u0[i])/255"
"0","    rgb(cbp[[k]][[1]][i]*w1 + cbp[[k]][[1]][i+1]*w2, "
"0","        cbp[[k]][[2]][i]*w1 + cbp[[k]][[2]][i+1]*w2, "
"0","        cbp[[k]][[3]][i]*w1 + cbp[[k]][[3]][i+1]*w2)"
"0","}"
"0",""
"0","plot.dgTMatrix <- function(x, y, ...) {"
"0","    cl <- match.call()"
"0","    if (is.null(cl$digits))"
"0","        digits <- 2"
"0","    z <- sort(unique(round(x@x, digits)))"
"0","    nz <- length(z)"
"0","    n1 <- sum(z<0)"
"0","    n2 <- sum(z>0)"
"0","    if (is.null(cl$colors)) "
"0","        if (any(c(n1,n2)==0)) "
"0","            colors <- gray(0.9*(1-(z-min(z))/diff(range(z))))"
"0","        else"
"0","            colors <- c(genColor(n1, 'red', z[z<0]/min(z)),"
"0","                        rep('white', nz-n1-n2),"
"0","                        genColor(n2, 'blue', z[z>0]/max(z)))"
"0","    z.breaks <- c(z[1]-diff(z[1:2])/2,"
"0","                  z[-nz]/2 + z[-1]/2,"
"0","                  z[nz]+diff(z[nz-1:0])/2)"
"0","    x@x <- round(x@x, digits)"
"0","    image(x, at=z.breaks, col.regions=colors, ...)"
"0","}"
"0",""
"0","book.plot.field <- function(field, mesh, projector, xlim, ylim, "
"0","			    dims=c(300,300), poly, asp = 1, "
"0","			    axes = FALSE, xlab = '', ylab = '', "
"0","			    col = book.color.c(), ...){"
"0","  ## you can supply field as a matrix vector or like a named list with 'x', 'y' and 'z' as for image"
"0","  ## when field is a vector, it will project it using projector, assuming projector will create a matrix "
"0","  ## when mesh is supplied and projector not, projector will be created and used to project field"
"0","  if (missing(mesh)) {"
"0","    if (missing(projector)) {"
"0","      if (missing(xlim) | missing(ylim)) {"
"0","        image.plot(field, asp = asp, axes = axes, "
"0","                   xlab = xlab, ylab = ylab, col = col, ...)"
"0","      } else {"
"0","        image.plot(field, xlim = xlim, ylim = ylim, asp = asp, "
"0","                   axes = axes, xlab = xlab, ylab = ylab, col = col, ...)"
"0","      }"
"0","    } else {"
"0","      if (missing(xlim)) xlim <- range(projector$x)"
"0","      if (missing(ylim)) ylim <- range(projector$y)"
"0","      field.proj <- inla.mesh.project(projector, field)"
"0","      image.plot(x = projector$x, y = projector$y, z = field.proj, "
"0","                 asp=asp, axes=axes, xlab = xlab, ylab = ylab, "
"0","                 col=col, xlim=xlim, ylim=ylim, ...)"
"0","    }"
"0","  } else {"
"0","    if (missing(xlim)) xlim <- range(mesh$loc[,1])"
"0","    if (missing(ylim)) ylim <- range(mesh$loc[,2])"
"0","    projector <- inla.mesh.projector(mesh, xlim = xlim,"
"0","                                     ylim = ylim, dims=dims)"
"0","    field.proj <- inla.mesh.project(projector, field)"
"0","    image.plot(x = projector$x, y = projector$y, z = field.proj, "
"0","               asp=asp, axes=axes, xlab = xlab, ylab = ylab, col=col, ...)"
"0","  }"
"0","  if (!missing(poly)) "
"0","      plot(poly, add = TRUE, col = 'grey')"
"0","}"
"0",""
"0","## Functions for barrier models"
"0",""
"0","## Find the correlation of precision Q (defined on mesh) at location "
"0","book.spatial.correlation <- function(Q, location, mesh) {"
"0","  ## The marginal standard deviations"
"0","  sd <- sqrt(diag(inla.qinv(Q)))"
"0",""
"0","  ## Create a fake A matrix, to extract the closest mesh node index"
"0","  A.tmp <- inla.spde.make.A(mesh = mesh,"
"0","    loc = matrix(c(location[1], location[2]), 1, 2))"
"0","  id.node = which.max(A.tmp[1, ])"
"0",""
"0","  ## Solve a matrix system to find just one column of the covariance matrix"
"0","  Inode <- rep(0, dim(Q)[1])"
"0","  Inode[id.node] <- 1"
"0","  covar.column <- solve(Q, Inode)"
"0","  corr <- drop(matrix(covar.column)) / (sd * sd[id.node])"
"0","  return(corr)"
"0","}"
"0",""
"0","## Continuous and discrete colour scales for the book"
"0","# n=8; plot(1:n, col=brewer.pal(n = n, name = ""Paired""))"
"0",""
"0","# Continuous"
"0","book.color.c = function(n = 201) {"
"0","  return(viridis(n))"
"0","}"
"0",""
"0","# Continuous (alternative)"
"0","book.color.c2 = function(n = 201) {"
"0","  return(magma(n))"
"0","}"
"0",""
"0","# Discrete from a continuous"
"0","book.color.dc = function(n = 11) {"
"0","  return(viridis(n))"
"0","}"
"0",""
"0","# Discrete (cannot be interpolated)"
"0","book.color.d = function(n=4) {"
"0","  return(brewer.pal(n = n, name = ""Paired""))"
"0","}"
"0",""
