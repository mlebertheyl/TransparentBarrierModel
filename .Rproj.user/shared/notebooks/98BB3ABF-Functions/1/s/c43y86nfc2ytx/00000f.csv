"0","corr.from.Q.simplified <- function( #I am calculating A.tmp and all outside"
"0","    Q = Q,"
"0","    id.node = id.node.n,"
"0","    id.coord = id.coord.n,"
"0","    in.id.node = id.node.b) { "
"0","  "
"0","  sd <- sqrt(diag(inla.qinv(Q)))"
"0",""
"0",""
"0","  Inode = rep(0, dim(Q)[1]) "
"0","  Inode[id.node] = 1"
"0","  covar.column = solve(Q, Inode)"
"0","# compute correlations"
"0","  corr = drop(matrix(covar.column)) / (sd*sd[id.node])"
"0","  corr2points <- corr[in.id.node]"
"0","  "
"0","  return(corr2points)"
"0","}"
"0",""
"0","corr.from.Q <- function("
"0","    Q = Q,"
"0","    location = location,"
"0","    y.up = y.up,"
"0","    max.edge.length = max.edge.length,"
"0","    mesh = mesh,"
"0","    in.id.node = in.id.node) { "
"0","  "
"0","  sd <- sqrt(diag(inla.qinv(Q)))"
"0","#the 3 following are obvs the same for all"
"0","  A.tmp <- inla.spde.make.A(mesh=mesh,"
"0","                            loc = matrix(c(location[1,1],(y.up + max.edge.length/2)), nrow=1, ncol=2)) "
"0","  id.node = which.max(A.tmp[1, ])"
"0","  id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])"
"0",""
"0","  Inode = rep(0, dim(Q)[1]) "
"0","  Inode[id.node] = 1"
"0","  covar.column = solve(Q, Inode)"
"0","# compute correlations"
"0","  corr = drop(matrix(covar.column)) / (sd*sd[id.node])"
"0","  corr2points <- corr[in.id.node]"
"0","  corr.from.Q <- list(corr2points = corr2points, corr = corr, id.coord = id.coord, id.node = id.node)"
"0","  "
"0","  return(corr.from.Q)"
"0","}"
"0",""
"0","# choose the true range fraction to generate the data"
"0","trans.generate.q2 <- function(mesh = mesh, fem = fem, "
"0","                        loc.data = loc.data, "
"0","                        set.inla.seed = 2303, "
"0","                        barrier.triangles = barrier.triangles, "
"0","                        prior.range = c(1.44, 0.5), "
"0","                        prior.sigma = c(0.7, 0.5),"
"0","                        range.fraction, #IMPORTANT,"
"0","                        range,"
"0","                        sigma.u = 1, sigma.epsilon = 0.2,"
"0","                        return.list = TRUE) {"
"0","  "
"0","  barrier.model <- inla.barrier.pcmatern.plus(mesh, fem, barrier.triangles, "
"0","                                              prior.range, prior.sigma, "
"0","                                              range.fraction)"
"0","  "
"0","  # range fraction has to have the same length as barrier triangles"
"0","  Q <- inla.rgeneric.q(barrier.model, ""Q"", theta = c(log(1), log(range)))"
"0","  u <- suppressWarnings(inla.qsample(n=1, Q=Q, seed = set.inla.seed))"
"0","  u <- u[ ,1]"
"0","    "
"0","  A.data <- inla.spde.make.A(mesh, loc.data)"
"0","  #Q from mydiff.r function"
"0","    "
"0","  u.data <- A.data %*% u"
"0","  "
"0","  df <- data.frame(loc.data)"
"0","  names(df) <- c('locx', 'locy')"
"0","  df$y <- drop(sigma.u * u.data + sigma.epsilon * rnorm(nrow(df)))"
"0","  "
"0","  if (return.list == TRUE) {"
"0","    "
"0","  data.list <- list(df = df, Q = Q, sample = u, "
"0","                    A.data = A.data, barrier.model=barrier.model)"
"0","    "
"0","    return(list(list.field = data.list))"
"0","  }"
"0","                     "
"0","}"
"0",""
"0","ratio.distance <- function(ratio){"
"0","  ratio.aim <- ratio"
"0","  trans.barrier.model <- inla.barrier.pcmatern.plus(mesh, "
"0","                             fem, "
"0","                             barrier.triangles, "
"0","                             prior.range,"
"0","                             prior.sigma,"
"0","                             range.fraction)"
"0","  Q.trans <- inla.rgeneric.q(trans.barrier.model, ""Q"", "
"0","                             theta = c(log(prior.sigma[1]), log(prior.range[1])))"
"0","  "
"0","  #~ ratio, corr_b/1"
"0","  empirical.ratio <- "
"0","    corr.from.Q.simplified(Q = Q.trans,"
"0","                           id.node = id.node.n,"
"0","                           id.coord = id.coord.n,"
"0","                           in.id.node = id.node.b)                             "
"0","  "
"0","  jump.data <- (empirical.ratio - ratio.aim)^2"
"0","  "
"0","  return(list(trans.barrier.model = trans.barrier.model, "
"0","              Q.trans = Q.trans,"
"0","              empirical.ratio = empirical.ratio,"
"0","              sq.distance = jump.data)) "
"0","  "
"0","}"
"0",""
"0",""
"0","corr.from.Q.alltogether <- function("
"0","    Q,"
"0","    id.node,"
"0","    in.id.node) {"
"0","  "
"0","  sd <- sqrt(diag(inla.qinv(Q)))"
"0","  Inode <- rep(0, dim(Q)[1])"
"0","  "
"0","  for (i in 1:length(id.node)) {"
"0","    Inode[id.node[[i]]] <- 1"
"0","  }"
"0","  "
"0","  covar.column <- solve(Q, Inode)"
"0",""
"0","  corr <- list()"
"0","  corr2points <- list()"
"0","  for (i in 1:length(id.node)) {"
"0","    corr[[i]] = drop(matrix(covar.column))/(sd*sd[id.node[[i]]])"
"0","    corr2points[[i]] <- corr[[i]][in.id.node[[i]]]"
"0","  }"
"0","  "
"0","  return(corr2points)"
"0","}"
"0",""
"0","#sd*sd[id.node[[i]]]=sd[in.id.node[[i]]]*sd[id.node[[i]]]"
"0",""
"0","find.aimed.ratios <- function(x, aimed.ratio) {"
"0","  "
"0","  barrier.model <- inla.barrier.pcmatern.plus("
"0","    mesh = mesh,"
"0","    fem = fem,"
"0","    barrier.triangles = barrier.triangles,"
"0","    prior.range = prior.range,"
"0","    prior.sigma = prior.sigma,"
"0","    range.fraction = x)"
"0","  "
"0","  Q <- inla.rgeneric.q("
"0","    barrier.model, "
"0","    ""Q"","
"0","    theta = c(log(prior.sigma[1]), "
"0","              log(prior.range[1])))"
"0","  "
"0","  corr.bm <- corr.from.Q.alltogether("
"0","    Q = Q, "
"0","    id.node = id.node, "
"0","    in.id.node = in.id.node)"
"0","  "
"0","  A <- diag(aimed.ratio)"
"0","  B <- diag(corr.bm)"
"0","  M <- A-B"
"0","  mini <- norm(M, ""F"")"
"0","  "
"0","  return(mini)"
"0","}"
"0",""
"0","find.x <- function(x) {"
"0","  "
"0","  barrier.model <- inla.barrier.pcmatern.plus("
"0","    mesh = mesh,"
"0","    fem = fem,"
"0","    barrier.triangles = barrier.triangles,"
"0","    prior.range = prior.range,"
"0","    prior.sigma = prior.sigma,"
"0","    range.fraction = x)"
"0","  "
"0","  Q <- inla.rgeneric.q("
"0","    barrier.model, "
"0","    ""Q"","
"0","    theta = c(log(prior.sigma[1]), "
"0","              log(prior.range[1])))"
"0","  "
"0","  corr.bm <- corr.from.Q.alltogether("
"0","    Q = Q, "
"0","    id.node = id.node, "
"0","    in.id.node = in.id.node)"
"0","  "
"0","  A <- diag(aim)"
"0","  B <- diag(corr.bm)"
"0","  M <- A-B"
"0","  mini <- norm(M, ""F"")"
"0","  "
"0","  return(mini)"
"0","}"
"0",""
