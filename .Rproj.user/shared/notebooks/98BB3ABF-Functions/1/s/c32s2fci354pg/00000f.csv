"0","inla.barrier.fem.plus <- function (mesh, barrier.triangles) "
"0","  {"
"0","  n <- length(barrier.triangles) #barrier triangles list"
"0","  t <- length(mesh$graph$tv[, 1])"
"0","  total_triangles <- unlist(barrier.triangles)"
"0","  Omega <- list()"
"0","  Omega$remaining <- setdiff(1:t, total_triangles)"
"0","  for (k in 1:n) {"
"0","    Omega[k+1] <- barrier.triangles[k] "
"0","    names(Omega)[k+1] <- paste0(""barrier.triangles."", k)"
"0","  }"
"0","  "
"0","    dt.fem.white <- function(mesh, subdomain) {"
"0","        Ck <- rep(0, mesh$n)"
"0","        for (t in subdomain) {"
"0","            px <- mesh$graph$tv[t, ]"
"0","            temp <- mesh$loc[px, ]"
"0","            p1 <- t(t(temp[1, c(1, 2)]))"
"0","            p2 <- t(t(temp[2, c(1, 2)]))"
"0","            p3 <- t(t(temp[3, c(1, 2)]))"
"0","            Ts <- cbind(p2 - p1, p3 - p1)"
"0","            area <- abs(det(Ts)) * 0.5"
"0","            for (i in 1:3) {"
"0","                Ck[px[i]] <- Ck[px[i]] + area"
"0","            }"
"0","        }"
"0","        return(Ck)"
"0","    }"
"0","    dt.fem.identity <- function(mesh) {"
"0","        len <- length(mesh$graph$tv[, 1])"
"0","        index.i <- rep(0, len * 6)"
"0","        index.j <- rep(0, len * 6)"
"0","        #index.q <- rep(0, len * 6)"
"0","        Aij <- rep(0, len * 6)"
"0","        counter <- 1"
"0","        for (t in 1:len) {"
"0","            px <- mesh$graph$tv[t, ]"
"0","            temp <- mesh$loc[px, ]"
"0","            p1 <- t(t(temp[1, c(1, 2)]))"
"0","            p2 <- t(t(temp[2, c(1, 2)]))"
"0","            p3 <- t(t(temp[3, c(1, 2)]))"
"0","            Ts <- cbind(p2 - p1, p3 - p1)"
"0","            twiceArea <- abs(det(Ts))"
"0","            for (i in 1:3) {"
"0","                index.i[counter] <- px[i]"
"0","                index.j[counter] <- px[i]"
"0","                #index.q[counter] <- px[i]"
"0","                Aij[counter] <- (twiceArea) * 1/12"
"0","                counter <- counter + 1"
"0","            }"
"0","            for (i in 1:2) {"
"0","                for (j in (i + 1):3) {"
"0","                  index.i[counter] <- px[i]"
"0","                  index.j[counter] <- px[j]"
"0","                  Aij[counter] <- (twiceArea) * 1/24"
"0","                  counter <- counter + 1"
"0","                  index.i[counter] <- px[j]"
"0","                  index.j[counter] <- px[i]"
"0","                  Aij[counter] <- (twiceArea) * 1/24"
"0","                  counter <- counter + 1"
"0","                }"
"0","            }"
"0","        }"
"0","        I <- sparseMatrix(i = index.i, j = index.j, x = Aij, "
"0","            dims = c(mesh$n, mesh$n), repr = ""T"")"
"0","        return(I)"
"0","    }"
"0","    dt.fem.laplace <- function(mesh, subdomain) {"
"0","        Nphix <- rbind(c(-1, -1), c(1, 0), c(0, 1))"
"0","        len <- length(subdomain)"
"0","        index.i <- rep(0, len * 9)"
"0","        index.j <- rep(0, len * 9)"
"0","        Aij <- rep(0, len * 9)"
"0","        counter <- 1"
"0","        for (tri in subdomain) {"
"0","            px <- mesh$graph$tv[tri, ]"
"0","            temp <- mesh$loc[px, ]"
"0","            p1 <- t(t(temp[1, c(1, 2)]))"
"0","            p2 <- t(t(temp[2, c(1, 2)]))"
"0","            p3 <- t(t(temp[3, c(1, 2)]))"
"0","            Ts <- cbind(p2 - p1, p3 - p1)"
"0","            TTTinv <- solve(t(Ts) %*% Ts)"
"0","            area <- abs(det(Ts)) * 0.5"
"0","            for (k in 1:3) {"
"0","                for (m in 1:3) {"
"0","                  tmp <- (3 * m + k - 4) * length(subdomain)"
"0","                  index.i[(tmp + counter)] <- px[k]"
"0","                  index.j[(tmp + counter)] <- px[m]"
"0","                  Aij[(tmp + counter)] <- area * Nphix[k, c(1, "
"0","                    2)] %*% TTTinv %*% as.matrix(Nphix[m, c(1, "
"0","                    2)])"
"0","                }"
"0","            }"
"0","            counter <- counter + 1"
"0","        }"
"0","        Dk <- sparseMatrix(i = index.i, j = index.j, x = Aij, "
"0","            dims = c(mesh$n, mesh$n), repr = ""T"")"
"0","        return(Dk)"
"0","    }"
"0","    xi <- length(Omega)"
"0","        fem <- list()"
"0","        fem$I <- dt.fem.identity(mesh)"
"0","        fem$D <- list()"
"0","        fem$C <- list()"
"0","        for (k in 1:xi) {"
"0","            fem$D[[k]] <- dt.fem.laplace(mesh, Omega[[k]])"
"0","        }"
"0","        for (k in 1:xi) {"
"0","            fem$C[[k]] <- dt.fem.white(mesh, Omega[[k]])"
"0","        }"
"0","        fem$hdim <- xi"
"0","    "
"0","    return(fem)"
"0","}"
"0",""
"0","inla.barrier.q <- function (fem, ranges, sigma = 1, envir = NULL) "
"0","{"
"0","    if (is.null(ranges)) "
"0","        stop(""ranges cannot be NULL"")"
"0","    if (any(is.na(ranges))) "
"0","        stop(""No range can be NA"")"
"0","    xi <- length(ranges)"
"0","    if (xi != length(fem$D)) {"
"0","        print(""inla.barrier.q has encountered an error. Will stop."")"
"0","        stop(""Ranges do no correspond to fem"")"
"0","    }"
"0","    if (any(ranges < 0.001)) {"
"0","        warning(""This hyper parameter value may fail. A very small maximum edge length needed in the mesh."")"
"0","    }"
"0","    Cdiag <- ranges[1]^2 * fem$C[[1]]"
"0","    if (xi > 1) {"
"0","        for (k in 2:xi) {"
"0","            Cdiag <- Cdiag + ranges[k]^2 * fem$C[[k]]"
"0","        }"
"0","    }"
"0","    N <- length(Cdiag)"
"0","    Cinv <- sparseMatrix(i = 1:N, j = 1:N, x = 1/Cdiag, dims = c(N, "
"0","        N), repr = ""T"")"
"0","    A <- fem$I"
"0","    for (k in 1:xi) {"
"0","        A <- A + (ranges[k]^2/8) * fem$D[[k]]"
"0","    }"
"0","    Q <- inla.as.sparse(t(A) %*% Cinv %*% A * (1/sigma^2)/pi * "
"0","        2 * 3)"
"0","    if (is.environment(envir)) {"
"0","        if (!exists(""cache.done"", envir = envir)) {"
"0","            Qx.idx <- which(Q@i <= Q@j)"
"0","            assign(""Qx.idx"", Qx.idx, envir = envir)"
"0","            assign(""cache.done"", TRUE, envir = envir)"
"0","        }"
"0","        else {"
"0","            Qx.idx <- get(""Qx.idx"", envir = envir)"
"0","        }"
"0","        return(Q@x[Qx.idx])"
"0","    }"
"0","    else {"
"0","        return(Q)"
"0","    }"
"0","}"
"0",""
"0","inla.barrier.pcmatern.plus <- function (mesh, fem, barrier.triangles, prior.range, prior.sigma, range.fraction = 0.2) "
"0","{"
"0","    if (missing(prior.range)) {"
"0","        warning(""Arbitrary prior values chosen automatically. This may suffice for a first attempt, \n            but should be changed in any serious analysis."")"
"0","        prior.range <- c(diff(range(mesh$loc[, 1]))/5, 0.5)"
"0","    }"
"0","    if (missing(prior.sigma)) {"
"0","        prior.sigma <- c(1, 0.5) "
"0","    }"
"0","    stopifnot(inherits(mesh, ""inla.mesh""))"
"0","    stopifnot(range.fraction > 1e-06)"
"0",""
"0","    barrier.rgeneric.model <- function(cmd = c(""graph"", ""Q"", "
"0","        ""mu"", ""initial"", ""log.norm.const"", ""log.prior"", ""quit""), "
"0","        theta = NULL) {"
"0","        envir = parent.env(environment())"
"0","        prior.sigma <- obj$prior.sigma"
"0","        prior.range <- obj$prior.range"
"0","        fem <- obj$fem"
"0","        inla.barrier.q <- obj$inla.barrier.q"
"0","        range.fraction <- obj$range.fraction"
"0","        initial <- function(theta) {"
"0","            initial.theta <- c()"
"0","            if (!is.na(prior.sigma[2])) {"
"0","                initial.theta <- c(0, initial.theta)"
"0","            }"
"0","            if (!is.na(prior.range[2])) {"
"0","                initial.theta <- c(initial.theta, 0)"
"0","            }"
"0","            return(initial.theta)"
"0","        }"
"0","        log.prior <- function(theta) {"
"0","            val <- 0"
"0","            if (!is.na(prior.sigma[2])) {"
"0","                lambda0 <- -log(prior.sigma[2])/prior.sigma[1]"
"0","                val <- val + log(lambda0) - lambda0 * exp(theta[1]) + "
"0","                  theta[1]"
"0","                theta.ran <- theta[-1]"
"0","            }"
"0","            else {"
"0","                theta.ran <- theta"
"0","            }"
"0","            if (!is.na(prior.range[2])) {"
"0","                lambda1 <- -log(prior.range[2]) * prior.range[1]"
"0","                for (logrange in theta.ran) {"
"0","                  val <- val + log(lambda1) - lambda1 * exp(-logrange) + "
"0","                    -logrange"
"0","                }"
"0","            }"
"0","            return(val)"
"0","        }"
"0","        Q <- function(theta) {"
"0","            theta.full <- theta"
"0","            if (is.na(prior.sigma[2])) {"
"0","                theta.full <- c(log(prior.sigma[1]), theta.full)"
"0","            }"
"0","            if (is.na(prior.range[2])) {"
"0","                theta.full <- c(theta.full, log(prior.range[1]))"
"0","            }"
"0","            stopifnot(length(theta.full) == 2)"
"0","            Q <- inla.barrier.q(fem = fem, ranges = exp(theta.full[2]) * "
"0","                c(1, range.fraction), sigma = exp(theta.full[1]), "
"0","                envir = envir) #ENVIR MAKES IT WORK"
"0","            return(Q)"
"0","        }"
"0","        graph <- function(theta) {"
"0","            require(methods)"
"0","            ntheta <- 2"
"0","            theta.full <- (1:ntheta)/3.217233456"
"0","            G1 <- inla.barrier.q(fem = fem, ranges = exp(theta.full[2]) * "
"0","                c(1, range.fraction), sigma = exp(theta.full[1]))"
"0","            G1[G1 != 0] <- 1"
"0","            theta.full <- (1:ntheta)^2/12.1543534"
"0","            G2 <- inla.barrier.q(fem = fem, ranges = exp(theta.full[2]) * "
"0","                c(1, range.fraction), sigma = exp(theta.full[1]))"
"0","            G2[G2 != 0] <- 1"
"0","            return(G1 + G2)"
"0","        }"
"0","        mu <- function(theta) numeric(0)"
"0","        log.norm.const <- function(theta) numeric(0)"
"0","        quit <- function(theta) invisible()"
"0","        val <- do.call(match.arg(cmd), args = list(theta))"
"0","        return(val)"
"0","    }"
"0","#   barrier.triangles <- unique(barrier.triangles)"
"0","    obj <- list()"
"0","    obj$prior.sigma <- prior.sigma"
"0","    obj$prior.range <- prior.range"
"0","    obj$range.fraction <- range.fraction"
"0","    obj$inla.barrier.q <- inla.barrier.q"
"0","    obj$fem <- fem"
"0","    barrier.model <- inla.rgeneric.define(model = barrier.rgeneric.model, "
"0","        optimize = TRUE, obj = obj)"
"0","    if (!is.na(prior.sigma[2]) && !is.na(prior.range[2])) {"
"0","    }"
"0","    else {"
"0","        warning(""Not properly tested, let us know if you have problems."")"
"0","    }"
"0","    return(barrier.model)"
"0","}"
