 
# Poisson data with toy mesh Example


Mesh here is built in the same way as previous examples (BTopic103). However, data is simulated as if it was a Poisson process (SPDE book).
I'm not evaluating the models here, but if needed I can just use the code of the next Poisson with different mesh example.


```{r}
ex4 <- fx.pre.field(loc.data = TRUE,
                               smalldist = 0.5,
                               width = c(2,2)) 

#range = 2
pf <- ex4
mesh <- pf$mesh 
fem <- pf$mat 
barrier.triangles <- list(pf$bar1, pf$bar2)
#loc.data <- pf$loc.data
poly.bar.orginal <- pf$poly.bar.orginal
poly.water <- pf$poly.water

zlim = c(0.1, 1)
xlim = poly.water@bbox[1, ] 
ylim = poly.water@bbox[2, ]

proj = inla.mesh.projector(mesh, xlim = xlim, 
                           ylim = ylim, dims=c(300, 300))
```

```{r}
win <- polyCub::as.owin.SpatialPolygons(poly.water)
plot(win)

npix <- 300
spatstat.options(npixel = npix)

beta0 <- 1
exp(beta0) * diff(range(win$x)) * diff(range(win$y))

sigma2x <- 0.2
range <- 2
nu <- 1

## ----simulapp,eval=TRUE, warning=FALSE, message=FALSE--------------------
set.seed(set.inla.seed)
lg.s <- rLGCP('matern', beta0, var = sigma2x,
              scale = range / sqrt(8), 
              nu = nu, win = win)

## ----xy------------------------------------------------------------------
xy <- cbind(lg.s$x, lg.s$y)
loc.data <- SpatialPoints(xy)
loc.data_sf <- st_as_sf(loc.data)
loc.data <- loc.data@coords
    
ggplot(data = pf$poly.water_sf) + 
      inlabru::gg(pf$mesh_h) +
      geom_sf(data =loc.data_sf,
          col='purple',size=1.7,alpha=0.5) 
```

## Choose two pair of points

One for each block with different r

```{r}
width <- 2
y.mid <- 5
y.up <- y.mid + (width/2)
y.low <- y.mid - (width/2)

location <- matrix(c(c(3.5, 6.5), rep(y.mid, 2)), ncol = 2)
```

```{r}
max.edge.length = 0.4
  
A <- list()
A[[1]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[1,1],y.up), nrow=1, ncol=2))
A[[2]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[1,1],(y.up + max.edge.length/2)), nrow=1, ncol=2))
A[[3]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[1,1],(y.up + max.edge.length)), nrow=1, ncol=2))

id.nodeA <- c()
id.nodeA[1] = which.max(A[[1]][1, ])
id.nodeA[2] = which.max(A[[2]][1, ])
id.nodeA[3] = which.max(A[[3]][1, ])

# just to check the coordinates and compare to the plot above
data.frame(x = c(mesh$loc[id.nodeA[1], 1], mesh$loc[id.nodeA[2], 1], mesh$loc[id.nodeA[3], 1]),
           y = c(mesh$loc[id.nodeA[1], 2], mesh$loc[id.nodeA[2], 2], mesh$loc[id.nodeA[3], 2]))

A.y.vector <- c(mesh$loc[id.nodeA[[1]],][2],
                  mesh$loc[id.nodeA[[2]],][2],
                  mesh$loc[id.nodeA[[3]],][2])

A.tmp <- A[[which(A.y.vector > y.up)[1]]]
id.node <- id.nodeA[which(A.y.vector > y.up)[1]]
id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])
return.list.up <- list(A.tmp = A.tmp, id.coord = id.coord, id.node = id.node)

## lower point, i.e. point in barrier area
A <- list()
A[[1]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[1,1],y.up), nrow=1, ncol=2))
A[[2]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[1,1],(y.up - max.edge.length/2)), nrow=1, ncol=2))
A[[3]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[1,1],(y.up - max.edge.length)), nrow=1, ncol=2))
id.nodeA <- c()
id.nodeA[1] = which.max(A[[1]][1, ])
id.nodeA[2] = which.max(A[[2]][1, ])
id.nodeA[3] = which.max(A[[3]][1, ])

A.y.vector <- c(mesh$loc[id.nodeA[[1]],][2],
                  mesh$loc[id.nodeA[[2]],][2],
                  mesh$loc[id.nodeA[[3]],][2])

A.tmp <- A[[which(A.y.vector < y.up)[1]]]
id.node <- id.nodeA[which(A.y.vector < y.up)[1]]
id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])

return.list.low <- list(A.tmp = A.tmp, id.coord = id.coord, id.node = id.node)

return.list <- list(normal.point = return.list.up, barrier.point = return.list.low)

coord.df_norm <- return.list$normal.point$id.coord
coord.df_bar <- return.list$barrier.point$id.coord

points_nb <- rbind(coord.df_norm, coord.df_bar)
rownames(points_nb) <- NULL
colnames(points_nb) <- c("x", "y")
points_nb <- as.matrix(points_nb)
poly_nb <- Polygon(points_nb)
SpatialPoints(poly_nb@coords)

sp_points_nb <- SpatialPoints(poly_nb@coords)
sf_points_nb <- st_as_sf(sp_points_nb)

ggplot(data = pf$poly.water_sf) + 
      inlabru::gg(pf$mesh) + #plot mesh_hb alternatively
      geom_sf(data =sf_points_nb,
          col='purple',size=1.7,alpha=0.5) 

ggplot(data = pf$poly.water_sf) + 
      inlabru::gg(pf$mesh) +
  geom_sf(data =sf_points_nb,
          col='purple',size=1.7,alpha=0.5) +
  ylim(c(4,6.5)) +
  xlim(c(2,5))

return.list.left <- return.list
coord.df_norm.left <- coord.df_norm
coord.df_bar.left <- coord.df_bar
```

```{r}
A <- list()
A[[1]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[2,1],y.up), nrow=1, ncol=2))
A[[2]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[2,1],(y.up + max.edge.length/2)), nrow=1, ncol=2))
A[[3]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[2,1],(y.up + max.edge.length)), nrow=1, ncol=2))

id.nodeA <- c()
id.nodeA[1] = which.max(A[[1]][1, ])
id.nodeA[2] = which.max(A[[2]][1, ])
id.nodeA[3] = which.max(A[[3]][1, ])

# just to check the coordinates and compare to the plot above
data.frame(x = c(mesh$loc[id.nodeA[1], 1], mesh$loc[id.nodeA[2], 1], mesh$loc[id.nodeA[3], 1]),
           y = c(mesh$loc[id.nodeA[1], 2], mesh$loc[id.nodeA[2], 2], mesh$loc[id.nodeA[3], 2]))

A.y.vector <- c(mesh$loc[id.nodeA[[1]],][2],
                  mesh$loc[id.nodeA[[2]],][2],
                  mesh$loc[id.nodeA[[3]],][2])

A.tmp <- A[[which(A.y.vector > y.up)[1]]]
id.node <- id.nodeA[which(A.y.vector > y.up)[1]]
id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])
return.list.up <- list(A.tmp = A.tmp, id.coord = id.coord, id.node = id.node)

## lower point, i.e. point in barrier area
A <- list()
A[[1]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[2,1],y.up), nrow=1, ncol=2))
A[[2]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[2,1],(y.up - max.edge.length/2)), nrow=1, ncol=2))
A[[3]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[2,1],(y.up - max.edge.length)), nrow=1, ncol=2))
id.nodeA <- c()
id.nodeA[1] = which.max(A[[1]][1, ])
id.nodeA[2] = which.max(A[[2]][1, ])
id.nodeA[3] = which.max(A[[3]][1, ])

A.y.vector <- c(mesh$loc[id.nodeA[[1]],][2],
                  mesh$loc[id.nodeA[[2]],][2],
                  mesh$loc[id.nodeA[[3]],][2])

A.tmp <- A[[which(A.y.vector < y.up)[1]]]
id.node <- id.nodeA[which(A.y.vector < y.up)[1]]
id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])

return.list.low <- list(A.tmp = A.tmp, id.coord = id.coord, id.node = id.node)

return.list <- list(normal.point = return.list.up, barrier.point = return.list.low)

coord.df_norm <- return.list$normal.point$id.coord
coord.df_bar <- return.list$barrier.point$id.coord

points_nb <- rbind(coord.df_norm, coord.df_bar)
rownames(points_nb) <- NULL
colnames(points_nb) <- c("x", "y")
points_nb <- as.matrix(points_nb)
poly_nb <- Polygon(points_nb)
SpatialPoints(poly_nb@coords)

sp_points_nb <- SpatialPoints(poly_nb@coords)
sf_points_nb <- st_as_sf(sp_points_nb)

ggplot(data = pf$poly.water_sf) + 
      inlabru::gg(pf$mesh) + #plot mesh_hb alternatively
      geom_sf(data =sf_points_nb,
          col='purple',size=1.7,alpha=0.5) 

ggplot(data = pf$poly.water_sf) + 
      inlabru::gg(pf$mesh) +
  geom_sf(data =sf_points_nb,
          col='purple',size=1.7,alpha=0.5) +
  ylim(c(4,6.5)) +
  xlim(c(5.5,7.5))

return.list.right <- return.list
coord.df_norm.right <- coord.df_norm
coord.df_bar.right <- coord.df_bar
```

## corr.from.Q function for two (or more) rb's

I need to calculate correlation for two points now, so pass a vector to solve instead of one Inode

```{r}
id.node <- list()
id.coord <- list()
in.id.node <- list()

id.node[[1]] = return.list.left$normal.point$id.node
id.node[[2]] = return.list.right$normal.point$id.node
id.coord[[1]] = return.list.left$normal.point$id.coord
id.coord[[2]] = return.list.right$normal.point$id.coord
in.id.node[[1]] = return.list.left$barrier.point$id.node
in.id.node[[2]] = return.list.right$barrier.point$id.node
```

## optim

```{r}
nb.model <- function(rbs, #rbs number of r_b
                     id.node = id.node, 
                     in.id.node = in.id.node) { 
  
  nb.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range,
                             prior.sigma,
                             range.fraction = rep(1, rbs))
  
  Q.nb <- inla.rgeneric.q(nb.model, "Q", 
                          theta = c(log(prior.sigma[1]), log(prior.range[1])))
  
  corr.nb <- 
    corr.from.Q.alltogether(Q = Q.nb,
                            id.node = id.node,
                            in.id.node = in.id.node)
  
  return(list(nb.model = nb.model, Q = Q.nb, corr = corr.nb))
}


find.aimed.ratios_ <- function(x, 
                               aimed.ratio,
                               corr.nb) {
  
  barrier.model <- inla.barrier.pcmatern.plus(
    mesh = mesh,
    fem = fem,
    barrier.triangles = barrier.triangles,
    prior.range = prior.range,
    prior.sigma = prior.sigma,
    range.fraction = x)
  
  Q <- inla.rgeneric.q(
    barrier.model, 
    "Q",
    theta = c(log(prior.sigma[1]), 
              log(prior.range[1])))
  
  corr.bm <- corr.from.Q.alltogether(
    Q = Q, 
    id.node = id.node, 
    in.id.node = in.id.node)
  
  corr <- c()
  for (i in seq_along(corr.bm)) {
    corr[i] <- corr.bm[[i]]/corr.nb[[i]]
  }
  
  A <- diag(aimed.ratio, nrow = length(aimed.ratio))
  B <- diag(corr, nrow = length(corr))
  M <- A-B
  mini <- norm(M, "F")
  
  return(mini)
}

aim <- c(0.1, 0.1)
## with corr nb = 1
par = rep(0.5, length(aim))
optim(par = par, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = list(1,1),
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))

x <- c(0.4103100, 0.3536333) #result from optim
find.ratio.from.range(x = x,
                      corr.nb = list(1,1))
```


```{r}
## with corr nb = corr.ref
corr.ref <- nb.model(rbs = 2, id.node = id.node, in.id.node = in.id.node)$corr
optim(par = par, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = corr.ref,
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))
```

$par: [1] 0.3114490 0.2949309

# Poisson data with Poisson mesh Example

The mesh built here is done according to what I would do in a real life application for point processes. The data is simulated as if it was a Poisson process (it's the same as previous example).


```{r}
# the study area is 
# matrix(c(2,2, 8,2, 8,8, 2,8, 2,2), 5, 2, byrow = T), not matrix(c(0,0, 10,0, 0,10, 10,10), 4, 2, byrow = T)
# I need to change the barrier triangles, owin is the same

# POLYGONS
smalldist = 0.5; width = c(2,2)

poly1 <- local.square.polygon(xlim=c(2, 5-smalldist/2), 
                          ylim=5+width[1]*c(-.5, .5))

poly2 <- local.square.polygon(xlim=c(5+smalldist/2, 8), 
                          ylim=5+width[2]*c(-.5, .5))

poly.original <- SpatialPolygons(c(poly1@polygons, poly2@polygons))

poly1_h <- local.square.polygon_T(xlim=c(2, 5-smalldist/2), 
                          ylim=5+width[1]*c(-.5, .5))

poly2_h <- local.square.polygon_T(xlim=c(5+smalldist/2, 8), 
                          ylim=5+width[2]*c(-.5, .5))

loc1 <- matrix(c(2,2, 8,2, 8,8, 2,8, 2,2), 5, 2, byrow = T)

locp <- Polygon(loc1, hole = FALSE)
locp_sp <- SpatialPolygons(list(Polygons(list(locp), '0')))
locp_sf <- st_as_sf(locp_sp)
    
poly.water <- SpatialPolygons(list(Polygons(list(locp, poly1_h, poly2_h), '0')))

poly.water_sf <- st_as_sf(poly.water)

#this is basically what's inside fx.pre.field

# MESH
bound.outer = diff(range(lg.s$x))/3
mesh.pp <- inla.mesh.2d(loc.domain = loc1,
                    max.edge = c(1,5)*max.edge.length,
                    cutoff = 0.05,
                    offset = c(max.edge.length, bound.outer))

ggplot() + 
  inlabru::gg(mesh.pp) + 
  geom_sf(data =loc.data_sf,
          col='purple',size=1.7,alpha=0.5) + 
  geom_segment(aes(x=2, y = 2,
                   xend = 8, yend = 2),
               color = "lightgreen", size = 1) +
  geom_segment(aes(x=8, y = 2,
                   xend = 8, yend = 8),
               color = "lightgreen", size = 1) +
  geom_segment(aes(x=8, y = 8,
                   xend = 2, yend = 8),
               color = "lightgreen", size = 1) +
  geom_segment(aes(x=2, y = 8,
                   xend = 2, yend = 2),
               color = "lightgreen", size = 1)
  

# BARRIER TRIANGLES
tl <- length(mesh.pp$graph$tv[,1])
# - the number of triangles in the mesh.pp
posTri <- matrix(0, tl, 2)

for (t in 1:tl){
    temp = mesh.pp$loc[mesh.pp$graph$tv[t, ], ]
    posTri[t,] = colMeans(temp)[c(1,2)] 
}

posTri <- SpatialPoints(posTri)

# - the positions of the triangle centers
bar.original <- over(poly.original, SpatialPoints(posTri), returnList=T)
# - checking which mesh.pp triangles are inside the barrier area
bar.original <- unlist(bar.original)
poly.bar.orginal <- inla.barrier.polygon(mesh.pp, barrier.triangles = bar.original)
# - the Barrier model's polygon
# - in most cases this should be the same as poly.original

# BARRIER 1
bar1 <- over(poly1, SpatialPoints(posTri), returnList=T)
# - checking which mesh.pp triangles are inside the barrier area
bar1 <- unlist(bar1)
poly.bar1 <- inla.barrier.polygon(mesh.pp, barrier.triangles = bar1)
# - the Barrier model's polygon
# - in most cases this should be the same as poly.original

# BARRIER 2
bar2 <- over(poly2, SpatialPoints(posTri), returnList=T)
# - checking which mesh.pp triangles are inside the barrier area
bar2 <- unlist(bar2)
poly.bar2 <- inla.barrier.polygon(mesh.pp, barrier.triangles = bar2)

mat <-  inla.barrier.fem.plus(mesh.pp, list(bar1, bar2))
fem <- mat

barrier.triangles <- list(bar1, bar2)

zlim = c(0.1, 1)
xlim = poly.water@bbox[1, ] 
ylim = poly.water@bbox[2, ]

proj = inla.mesh.projector(mesh.pp, xlim = xlim, 
                           ylim = ylim, dims=c(300, 300))

#PLOT
coast_bbox <- st_bbox(poly.water_sf) %>% st_as_sfc()

poly.bar.orginal_sf <- st_as_sf(poly.bar.orginal)

poly.bar1_sf <- st_as_sf(poly.bar1)
poly.bar2_sf <- st_as_sf(poly.bar2)

ggplot() + 
  inlabru::gg(mesh.pp) + 
  geom_sf(data =loc.data_sf,
          col='purple',size=1.7,alpha=0.5) +
  geom_sf(data =poly.bar.orginal_sf,
          col='red', alpha=0.5) +
  geom_sf(data=coast_bbox, fill=NA, color="blue")
```

## Choose two pair of points

One for each block with different r

```{r}
width <- 2
y.mid <- 5
y.up <- y.mid + (width/2)
y.low <- y.mid - (width/2)

location <- matrix(c(c(3.2, 6.7), rep(y.mid, 2)), ncol = 2)
```

```{r}
mesh <- mesh.pp
max.edge.length = 0.4
  
A <- list()
A[[1]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[1,1],y.up), nrow=1, ncol=2))
A[[2]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[1,1],(y.up + max.edge.length/2)), nrow=1, ncol=2))
A[[3]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[1,1],(y.up + max.edge.length)), nrow=1, ncol=2))

id.nodeA <- c()
id.nodeA[1] = which.max(A[[1]][1, ])
id.nodeA[2] = which.max(A[[2]][1, ])
id.nodeA[3] = which.max(A[[3]][1, ])

# just to check the coordinates and compare to the plot above
data.frame(x = c(mesh$loc[id.nodeA[1], 1], mesh$loc[id.nodeA[2], 1], mesh$loc[id.nodeA[3], 1]),
           y = c(mesh$loc[id.nodeA[1], 2], mesh$loc[id.nodeA[2], 2], mesh$loc[id.nodeA[3], 2]))

A.y.vector <- c(mesh$loc[id.nodeA[[1]],][2],
                  mesh$loc[id.nodeA[[2]],][2],
                  mesh$loc[id.nodeA[[3]],][2])

A.tmp <- A[[which(A.y.vector > y.up)[1]]]
id.node <- id.nodeA[which(A.y.vector > y.up)[1]]
id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])
return.list.up <- list(A.tmp = A.tmp, id.coord = id.coord, id.node = id.node)

## lower point, i.e. point in barrier area
A <- list()
A[[1]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[1,1],y.up), nrow=1, ncol=2))
A[[2]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[1,1],(y.up - max.edge.length/2)), nrow=1, ncol=2))
A[[3]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[1,1],(y.up - max.edge.length)), nrow=1, ncol=2))
id.nodeA <- c()
id.nodeA[1] = which.max(A[[1]][1, ])
id.nodeA[2] = which.max(A[[2]][1, ])
id.nodeA[3] = which.max(A[[3]][1, ])

A.y.vector <- c(mesh$loc[id.nodeA[[1]],][2],
                  mesh$loc[id.nodeA[[2]],][2],
                  mesh$loc[id.nodeA[[3]],][2])

A.tmp <- A[[which(A.y.vector < (y.up - max.edge.length/2))[1]]]
id.node <- id.nodeA[which(A.y.vector < (y.up - max.edge.length/2))[1]]
id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])

return.list.low <- list(A.tmp = A.tmp, id.coord = id.coord, id.node = id.node)

return.list <- list(normal.point = return.list.up, barrier.point = return.list.low)

coord.df_norm <- return.list$normal.point$id.coord
coord.df_bar <- return.list$barrier.point$id.coord

points_nb <- rbind(coord.df_norm, coord.df_bar)
rownames(points_nb) <- NULL
colnames(points_nb) <- c("x", "y")
points_nb <- as.matrix(points_nb)
poly_nb <- Polygon(points_nb)
SpatialPoints(poly_nb@coords)

sp_points_nb <- SpatialPoints(poly_nb@coords)
sf_points_nb <- st_as_sf(sp_points_nb)

ggplot() + 
      inlabru::gg(mesh) + 
      geom_sf(data =sf_points_nb,
          col='purple',size=1.7,alpha=0.5) +
  geom_sf(data =poly.bar.orginal_sf,
          col='red', alpha=0) +
  geom_sf(data=coast_bbox, fill=NA, color="blue")

ggplot() + 
      inlabru::gg(mesh) + 
      geom_sf(data =sf_points_nb,
          col='purple',size=1.7,alpha=0.5) +
  geom_sf(data =poly.bar.orginal_sf,
          col='red', alpha=0) +
  geom_sf(data=coast_bbox, fill=NA, color="blue") +
  ylim(c(4,6.5)) +
  xlim(c(2,5))

return.list.left <- return.list
coord.df_norm.left <- coord.df_norm
coord.df_bar.left <- coord.df_bar
```

```{r}
A <- list()
A[[1]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[2,1],y.up), nrow=1, ncol=2))
A[[2]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[2,1],(y.up + max.edge.length/2)), nrow=1, ncol=2))
A[[3]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[2,1],(y.up + max.edge.length)), nrow=1, ncol=2))

id.nodeA <- c()
id.nodeA[1] = which.max(A[[1]][1, ])
id.nodeA[2] = which.max(A[[2]][1, ])
id.nodeA[3] = which.max(A[[3]][1, ])

# just to check the coordinates and compare to the plot above
data.frame(x = c(mesh$loc[id.nodeA[1], 1], mesh$loc[id.nodeA[2], 1], mesh$loc[id.nodeA[3], 1]),
           y = c(mesh$loc[id.nodeA[1], 2], mesh$loc[id.nodeA[2], 2], mesh$loc[id.nodeA[3], 2]))

A.y.vector <- c(mesh$loc[id.nodeA[[1]],][2],
                  mesh$loc[id.nodeA[[2]],][2],
                  mesh$loc[id.nodeA[[3]],][2])

A.tmp <- A[[which(A.y.vector > (y.up + max.edge.length/2))[1]]]
id.node <- id.nodeA[which(A.y.vector > (y.up + max.edge.length/2))[1]]
id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])
return.list.up <- list(A.tmp = A.tmp, id.coord = id.coord, id.node = id.node)

## lower point, i.e. point in barrier area
A <- list()
A[[1]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[2,1],y.up), nrow=1, ncol=2))
A[[2]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[2,1],(y.up - max.edge.length/2)), nrow=1, ncol=2))
A[[3]] <- inla.spde.make.A(mesh=mesh,
                     loc = matrix(c(location[2,1],(y.up - max.edge.length)), nrow=1, ncol=2))
id.nodeA <- c()
id.nodeA[1] = which.max(A[[1]][1, ])
id.nodeA[2] = which.max(A[[2]][1, ])
id.nodeA[3] = which.max(A[[3]][1, ])

A.y.vector <- c(mesh$loc[id.nodeA[[1]],][2],
                  mesh$loc[id.nodeA[[2]],][2],
                  mesh$loc[id.nodeA[[3]],][2])

A.tmp <- A[[which(A.y.vector < (y.up - max.edge.length/2))[1]]]
id.node <- id.nodeA[which(A.y.vector < (y.up - max.edge.length/2))[1]]
id.coord <- c(mesh$loc[id.node, 1], mesh$loc[id.node, 2])

return.list.low <- list(A.tmp = A.tmp, id.coord = id.coord, id.node = id.node)

return.list <- list(normal.point = return.list.up, barrier.point = return.list.low)

coord.df_norm <- return.list$normal.point$id.coord
coord.df_bar <- return.list$barrier.point$id.coord

points_nb <- rbind(coord.df_norm, coord.df_bar)
rownames(points_nb) <- NULL
colnames(points_nb) <- c("x", "y")
points_nb <- as.matrix(points_nb)
poly_nb <- Polygon(points_nb)
SpatialPoints(poly_nb@coords)

sp_points_nb <- SpatialPoints(poly_nb@coords)
sf_points_nb <- st_as_sf(sp_points_nb)

ggplot() + 
      inlabru::gg(mesh) + 
      geom_sf(data =sf_points_nb,
          col='purple',size=1.7,alpha=0.5) +
  geom_sf(data =poly.bar.orginal_sf,
          col='red', alpha=0) +
  geom_sf(data=coast_bbox, fill=NA, color="blue")

ggplot() + 
      inlabru::gg(mesh) + 
      geom_sf(data =sf_points_nb,
          col='purple',size=1.7,alpha=0.5) +
  geom_sf(data =poly.bar.orginal_sf,
          col='red', alpha=0) +
  geom_sf(data=coast_bbox, fill=NA, color="blue") +
  ylim(c(4,6.5)) +
  xlim(c(5,8))



return.list.right <- return.list
coord.df_norm.right <- coord.df_norm
coord.df_bar.right <- coord.df_bar
```
## corr.from.Q function for two (or more) rb's

I need to calculate correlation for two points now, so pass a vector to solve instead of one Inode

```{r}
id.node <- list()
id.coord <- list()
in.id.node <- list()

id.node[[1]] = return.list.left$normal.point$id.node
id.node[[2]] = return.list.right$normal.point$id.node
id.coord[[1]] = return.list.left$normal.point$id.coord
id.coord[[2]] = return.list.right$normal.point$id.coord
in.id.node[[1]] = return.list.left$barrier.point$id.node
in.id.node[[2]] = return.list.right$barrier.point$id.node
```

### optim

```{r}
nb.model <- function(rbs, #rbs number of r_b
                     id.node = id.node, 
                     in.id.node = in.id.node) { 
  
  nb.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range,
                             prior.sigma,
                             range.fraction = rep(1, rbs))
  
  Q.nb <- inla.rgeneric.q(nb.model, "Q", 
                          theta = c(log(prior.sigma[1]), log(prior.range[1])))
  
  corr.nb <- 
    corr.from.Q.alltogether(Q = Q.nb,
                            id.node = id.node,
                            in.id.node = in.id.node)
  
  return(list(nb.model = nb.model, Q = Q.nb, corr = corr.nb))
}


find.aimed.ratios_ <- function(x, 
                               aimed.ratio,
                               corr.nb) {
  
  barrier.model <- inla.barrier.pcmatern.plus(
    mesh = mesh,
    fem = fem,
    barrier.triangles = barrier.triangles,
    prior.range = prior.range,
    prior.sigma = prior.sigma,
    range.fraction = x)
  
  Q <- inla.rgeneric.q(
    barrier.model, 
    "Q",
    theta = c(log(prior.sigma[1]), 
              log(prior.range[1])))
  
  corr.bm <- corr.from.Q.alltogether(
    Q = Q, 
    id.node = id.node, 
    in.id.node = in.id.node)
  
  corr <- c()
  for (i in seq_along(corr.bm)) {
    corr[i] <- corr.bm[[i]]/corr.nb[[i]]
  }
  
  A <- diag(aimed.ratio, nrow = length(aimed.ratio))
  B <- diag(corr, nrow = length(corr))
  M <- A-B
  mini <- norm(M, "F")
  
  return(mini)
}

aim <- c(0.1, 0.1)
## with corr nb = 1
par = rep(0.5, length(aim))
optim(par = par, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = list(1,1),
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))

x <- c(0.14102605, 0.09286529) #result from optim
find.ratio.from.range(x = x,
                      corr.nb = list(1,1))
```

$par: [1] 0.14102605 0.09286529
$convergence: [1] 52

```{r}
## with corr nb = corr.ref
corr.ref <- nb.model(rbs = 2, id.node = id.node, in.id.node = in.id.node)$corr
optim(par = par, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = corr.ref,
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))

x <- c(0.11934492, 0.08144928) #result from optim
find.ratio.from.range(x = x,
                      corr.nb = corr.ref)

x <- c(0.11934492, 0.08144928) #result from optim
find.ratio.from.range(x = x,
                      corr.nb = corr.ref)
```

$par: [1] 0.11934492 0.08144928
$convergence: [1] 52

```{r}
aim <- c(0.7, 0.4)
## with corr nb = 1
par = rep(0.5, length(aim))
optim(par = par, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = list(1,1),
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))

x <- c(0.5722302, 0.1675146) #result from optim
find.ratio.from.range(x = x,
                      corr.nb = list(1,1))
```

$par: [1] 0.5722302 0.1675146
$value: [1] 1.123554e-05
$counts: function gradient 
      38       38 
$convergence: [1] 0
$message: [1] "CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"

```{r}
aim <- c(0.7, 0.4)
par = rep(0.5, length(aim))
optim(par = par, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = corr.ref,
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))

x <- c(0.1618411, 0.1028846) #result from optim
find.ratio.from.range(x = x,
                      corr.nb = corr.ref)
```

$par: [1] 0.1618411 0.1028846
$value: [1] 4.265957e-05
$counts: function gradient 
      40       40 
$convergence: [1] 0
$message: [1] "CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"

```{r}
aim <- c(0.5, 0.5)
## with corr nb = 1
par = rep(0.5, length(aim))
optim(par = par, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = list(1,1),
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))

x <- c(0.3280925, 0.2041614) #result from optim
find.ratio.from.range(x = x,
                      corr.nb = list(1,1))
```

$par: [1] 0.3280925 0.2041614
$value: [1] 8.861838e-06
$counts: function gradient 
      37       37 
$convergence: [1] 0
$message: [1] "CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"

```{r}
optim(par = par, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = corr.ref,
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))

x <- c(0.1466231, 0.1107695) #result from optim
find.ratio.from.range(x = x,
                      corr.nb = corr.ref)
```

$par: [1] 0.1466231 0.1107695
$value: [1] 3.811454e-05
$counts: function gradient 
      28       28 
$convergence: [1] 0
$message: [1] "CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"

### Discussion (until here)

As discussed on some of the other examples the choice of points to get the ratio is up to the user. Here, I have some examples where both (pair of points) aimed ratios are the same, e.g. `c(0.1, 0.1)`, however the range for each barrier can be different. If I want both to be the same, meaning find the $r_b$ that minimizes both pairs I can just added as a constraint inside the optim function.

It's also clear calculated $r_b$s when the borders are irregular vary more depending on the choice of points for which we get the ratio, -when we use the same aimed ratio the resulting $r_{b_1}$ and $r_{b_2}$ are not that close-. How to choose the points so the results make sense depends on the specific real life problem, some solutions could be: choosing points in the middle of the barrier(s) to build the ratio, this would also make sense if we have a barrier inside another barrier (Example 6); choosing points along the barrier and then getting the $r_$ that minimizes the function for all.

Be careful with what comes next because all these functions (`optim`, `find.ratio.from.range`, `find.aimed.ratios_`, `nb.model`, etc.)   have pre defined `prior.range` and `prior.sigma`. For the examples above I used `prior.range = c(1, 0.5)`, and `prior.sigma = c(1, 0.1)`.


## The mesh and weights 

SPDE book: "Because the mesh is larger than the study area, we need to compute the intersection between each polygon in the dual mesh and the study area"...

Should we consider the barrier as part of the study are or not?

### w 

Integration points inside the barrier different than 0, i.e. area inside the barrier is considered area of the study region too.

```{r}
#locations, loc.data from rLGCP
nv <- mesh$n
dmesh <- book.mesh.dual(mesh)

#domain.polys <- Polygons(list(Polygon(loc1)), '0')
#domainSP <- SpatialPolygons(list(domain.polys))

domainSP <- locp_sp
# with sf
domainSPsf <- locp_sf
dmesh_sf <- st_as_sf(dmesh) 

# with sapply
w <- sapply(1:length(dmesh), function(i) {
  if (length(st_intersects(dmesh_sf[i, ], domainSPsf)[[1]]) == 1)
    return(st_area(st_intersection(dmesh_sf[i, ], domainSPsf)))
  else {
    return(0)
  }
})

store_w <- w
w <- store_w
sum(w)
table(w>0); table(w==0)

pal <- wes_palette("Zissou1")
colr = rep(c(pal[2]), length = as.numeric(length(w)))
colr[w>0] = pal[5]
plot(dmesh, col = colr)

par(mar = c(2, 2, 1, 1), mgp = 2:0)
plot(mesh$loc, asp = 1, col = (w == 0) + 1, pch = 19, xlab = '', ylab = '') 
plot(dmesh, add = TRUE)
lines(loc1, col = 3)
```
### w2    

Alternatively, the mesh is built (as before) considering the barrier area, however when computing the intersection between each polygon in the dual mesh and  the study area, the latter will only comprehend the normal area.

```{r}
#domainSP <- poly.water
#domainSPsf <- poly.water_sf
#dmesh_sf <- st_as_sf(dmesh) 

w2 <- sapply(1:length(dmesh), function(i) {
  if (length(st_intersects(dmesh_sf[i, ], poly.water_sf)[[1]]) == 1)
    return(st_area(st_intersection(dmesh_sf[i, ], poly.water_sf)))
  else {
    return(0)
  }
})

store_w2 <- w2
w2 <- store_w2
sum(w2)
table(w2>0); table(w2==0)

pal <- wes_palette("Zissou1")
colr = rep(c(pal[2]), length = as.numeric(length(w2)))
colr[w2>0] = pal[5]
plot(dmesh, col = colr)

par(mar = c(2, 2, 1, 1), mgp = 2:0)
plot(mesh$loc, asp = 1, col = (w2 == 0) + 1, pch = 19, xlab = '', ylab = '') 
plot(dmesh, add = TRUE)
lines(loc1, col = 3)
```
### Discussion about weights w

I want to put weight where there can be potential observations. Transparent barriers can potentially have obs inside. Permanent/impermeable barriers ($r_b = 0.01$) can't.

## Projection matrices

```{r}
# for w
n <- nrow(xy)
y.pp <- rep(0:1, c(nv, n))
#The exposure vector can be defined as:
e.pp <- c(w, rep(0, n)) 
length(y.pp); length(e.pp)
# The projection matrix is defined in two steps. For the integration points this is just a diagonal matrix because these locations are just the mesh vertices:
imat <- Diagonal(nv, rep(1, nv))
# For the observed points, another projection matrix is defined:
lmat <- inla.spde.make.A(mesh, xy)
# The entire projection matrix is:
A.pp <- rbind(imat, lmat)
# We set up the data stack as follows:
stk.pp <- inla.stack(
  data = list(y = y.pp, e = e.pp), 
  A = list(1, A.pp),
  effects = list(list(b0 = rep(1, nv + n)), list(i = 1:nv)),
  tag = 'pp')
# Results hold
cat('Dimension of A: ', dim(A.pp), '\n')
cat('Dimension of projection matrix: ', dim(imat), '\n')
cat('Number of mesh points: ', mesh$n, '\n')
cat('Number of locations: ', dim(lmat)[1], '\n')
```

## Model Evaluation

### stationary SPDE

#### 3 sets of priors

First set of priors is what I used in the previous examples;

```{r}
# SPDE stationary model
prior.range = c(1, 0.5)
prior.sigma = c(1, 0.1)

spde <- inla.spde2.pcmatern(mesh = mesh,
  prior.range = prior.range,
  prior.sigma = prior.range) 

formula.st <- y ~ 0 + b0 + f(i, model = spde)
res.pp.st <- inla(formula.st, 
                  family = 'poisson', 
                  data = inla.stack.data(stk.pp), 
                  control.predictor = list(A = inla.stack.A(stk.pp)), 
                  E = inla.stack.data(stk.pp)$e)

# prior.range = c(1, 0.5); prior.sigma = c(1, 0.1)
res.pp.stP1 <- res.pp.st
```

second set of priors is from the SPDE book;

```{r}
# SPDE book priors
spde <- inla.spde2.pcmatern(mesh = mesh,
  # PC-prior on range: P(practic.range < 0.05) = 0.01
  prior.range = c(0.05, 0.01),
  # PC-prior on sigma: P(sigma > 1) = 0.01
  prior.sigma = c(1, 0.01)) 

formula.st <- y ~ 0 + b0 + f(i, model = spde)
res.pp.st <- inla(formula.st, 
                  family = 'poisson', 
                  data = inla.stack.data(stk.pp), 
                  control.predictor = list(A = inla.stack.A(stk.pp)), 
                  E = inla.stack.data(stk.pp)$e)

# prior.range = c(0.05, 0.01); prior.sigma = c(1, 0.01)
res.pp.stP2 <- res.pp.st
```

and third set from the Archipielago data example. 

The prior for the hyper-parameter $r$ is calibrated to have a median around half of the study area
and $\sigma_u$ is choosen in order to have probability 0.01 to have values greater than 1.

```{r}
## Prior for range uses half the study area, which is
## ... approximately 0.5*diff(range(lg.s$y)) = 2.95563

prior.range = c(3, .5)
prior.sigma = c(1, 0.01)

spde <- inla.spde2.pcmatern(mesh = mesh,
  prior.range = prior.range,
  prior.sigma = prior.range) 

formula.st <- y ~ 0 + b0 + f(i, model = spde)
res.pp.st <- inla(formula.st, 
                  family = 'poisson', 
                  data = inla.stack.data(stk.pp), 
                  control.predictor = list(A = inla.stack.A(stk.pp)), 
                  E = inla.stack.data(stk.pp)$e)

# prior.range = c(3, .5); prior.sigma = c(1, 0.01)
res.pp.stP3 <- res.pp.st
```

##### Comparing random effects

```{r}
res.pp.stP1$summary.hyperpar
res.pp.stP2$summary.hyperpar
res.pp.stP3$summary.hyperpar

# PLOTS
# set 1
par(mfrow = c(1, 3), mar = c(3, 3, 1, 0.3), mgp = c(2, 1, 0)) 

plot(res.pp.stP1$marginals.fixed[[1]], type = 'l', xlab = expression(beta[0]),
     ylab = 'Density')
abline(v = beta0, col = 2)

plot(res.pp.stP1$marginals.hyperpar[[2]], type = 'l', xlab = expression(sigma),
     ylab = 'Density', xlim = c(0,2))
abline(v = sqrt(sigma2x), col = 2)

plot(res.pp.stP1$marginals.hyperpar[[1]], type = 'l', xlab = 'Nominal range',
     ylab = 'Density', xlim = c(0, 8))
abline(v = range, col = 2)

# set 2
par(mfrow = c(1, 3), mar = c(3, 3, 1, 0.3), mgp = c(2, 1, 0)) 

plot(res.pp.stP2$marginals.fixed[[1]], type = 'l', xlab = expression(beta[0]),
     ylab = 'Density')
abline(v = beta0, col = 2)

plot(res.pp.stP2$marginals.hyperpar[[2]], type = 'l', xlab = expression(sigma),
     ylab = 'Density', xlim = c(0,2))
abline(v = sqrt(sigma2x), col = 2)

plot(res.pp.stP2$marginals.hyperpar[[1]], type = 'l', xlab = 'Nominal range',
     ylab = 'Density', xlim = c(0, 8))
abline(v = range, col = 2)

# set 3
par(mfrow = c(1, 3), mar = c(3, 3, 1, 0.3), mgp = c(2, 1, 0)) 

plot(res.pp.stP3$marginals.fixed[[1]], type = 'l', xlab = expression(beta[0]),
     ylab = 'Density')
abline(v = beta0, col = 2)

plot(res.pp.stP3$marginals.hyperpar[[2]], type = 'l', xlab = expression(sigma),
     ylab = 'Density', xlim = c(0,2))
abline(v = sqrt(sigma2x), col = 2)

plot(res.pp.stP3$marginals.hyperpar[[1]], type = 'l', xlab = 'Nominal range',
     ylab = 'Density', xlim = c(0, 8))
abline(v = range, col = 2)
```

### Transparent Barrier Model

I will use different range fractions using the results from the optim section with calculated reference correlation ($\neq 1$); + different sets of priors.

This section is organized as follows,

#### Set 1

+ prior.range = c(1, 0.5); prior.sigma = c(1, 0.1)

  + `c(0.1, 0.1)` aimed ratio
  line 765; aim = c(0.1, 0.1); x <- c(0.11934492, 0.08144928)
  *Note that the ratio here is 0.1 NOT the barrier range*
  
  + `c(0.7, 0.4)` aimed ratio  
  line 803; aim = c(0.7, 0.4); x <- c(0.1618411, 0.1028846)
  
  + `c(0.5, 0.5)` aimed ratio  
  line 847; aim = c(0.5, 0.5); x <- c(0.1466231, 0.1107695)

These results are the ones I got from the optim section. To run the model using the other two sets of priors I need to run `optim` and other functions again with the corresponding priors. 


#### Prior Set 2

+ prior.range = c(0.05, 0.01); prior.sigma = c(1, 0.01)

  + optim
  + aimed ratios
    + `c(0.1, 0.1)` aimed ratio
    + `c(0.7, 0.4)` aimed ratio  
    + `c(0.5, 0.5)` aimed ratio 
  
#### Prior Set 3

+ prior.range = c(3, .5); prior.sigma = c(1, 0.01)

  + optim
  + aimed ratios
    + `c(0.1, 0.1)` aimed ratio
    + `c(0.7, 0.4)` aimed ratio  
    + `c(0.5, 0.5)` aimed ratio 
    
#### Classic Barrier model
#### Comparing random effects

```{r}
for (i in 1:3) {
  opt[[i]] <- list()
  par[[i]] <- list()
  for (j in 1:3) {
    opt[[i]][[j]] <- list()
    par[[i]][[j]] <- list()
  }
}

for (i in 1:3) {
  res.pp.bm[[i]] <- list()
  for (j in 1:3) {
    res.pp.bm[[i]][[j]] <- list()
  }
}

opt[[1]][[1]] <- c(0.11934492, 0.08144928)
opt[[1]][[2]] <- c(0.1618411, 0.1028846)
opt[[1]][[3]] <- c(0.1466231, 0.1107695)
```

### Prior Set 1    

prior.range = c(1, 0.5)
prior.sigma = c(1, 0.1)

```{r}
# Prior: SPDE stationary model
prior.range = c(1, 0.5)
prior.sigma = c(1, 0.1)

#### `c(0.1, 0.1)` aimed ratio  

x <- c(0.11934492, 0.08144928)

barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range = prior.range,
                             prior.sigma = prior.sigma,
                             range.fraction = c(x[1],x[2]))

formula.bm <- y ~ 0 + b0 + f(i, model = barrier.model)
# f(i, model = ...) i instead of s

res.pp.bm <- list(list())

#res.pp.bm[[1]] first set of priors; [[1]][[1]] the first set of aimed ratios
## then, 
## [[1]] set 1: prior.range = c(1, 0.5); prior.sigma = c(1, 0.1)
## [[1]][[1]] set 1, aim c(0.1, 0.1)

res.pp.bm[[1]][[1]] <- inla(formula.bm,
                 data = inla.stack.data(stk.pp),
                 control.predictor = list(A = inla.stack.A(stk.pp)),
                 family = 'poisson', 
                 E = inla.stack.data(stk.pp)$e, 
                 control.inla = list(int.strategy = "eb"))


#### `c(0.7, 0.4)` aimed ratio  
x <- c(0.1618411, 0.1028846)
barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range = prior.range,
                             prior.sigma = prior.sigma,
                             range.fraction = c(x[1],x[2]))

formula.bm <- y ~ 0 + b0 + f(i, model = barrier.model)

## [[1]] set 1: prior.range = c(1, 0.5); prior.sigma = c(1, 0.1)
## [[1]][[2]] set 1, aim c(0.7, 0.4)

res.pp.bm[[1]][[2]] <- inla(formula.bm,
                 data = inla.stack.data(stk.pp),
                 control.predictor = list(A = inla.stack.A(stk.pp)),
                 family = 'poisson', 
                 E = inla.stack.data(stk.pp)$e, 
                 control.inla = list(int.strategy = "eb"))


#### `c(0.5, 0.5)` aimed ratio  
x <- c(0.1466231, 0.1107695)
barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range = prior.range,
                             prior.sigma = prior.sigma,
                             range.fraction = c(x[1],x[2]))

formula.bm <- y ~ 0 + b0 + f(i, model = barrier.model)

## [[1]] set 1: prior.range = c(1, 0.5); prior.sigma = c(1, 0.1)
## [[1]][[3]] set 1, aim c(0.5, 0.5)

res.pp.bm[[1]][[3]] <- inla(formula.bm,
                 data = inla.stack.data(stk.pp),
                 control.predictor = list(A = inla.stack.A(stk.pp)),
                 family = 'poisson', 
                 E = inla.stack.data(stk.pp)$e, 
                 control.inla = list(int.strategy = "eb"))
```

### Prior Set 2

prior.range = c(0.05, 0.01)
prior.sigma = c(1, 0.01)

#### optim

```{r}
prior.range = c(0.05, 0.01)
prior.sigma = c(1, 0.01)

nb.model <- function(rbs, #rbs number of r_b
                     id.node = id.node, 
                     in.id.node = in.id.node) { 
  
  nb.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range,
                             prior.sigma,
                             range.fraction = rep(1, rbs))
  
  Q.nb <- inla.rgeneric.q(nb.model, "Q", 
                          theta = c(log(prior.sigma[1]), log(prior.range[1])))
  
  corr.nb <- 
    corr.from.Q.alltogether(Q = Q.nb,
                            id.node = id.node,
                            in.id.node = in.id.node)
  
  return(list(nb.model = nb.model, Q = Q.nb, corr = corr.nb))
}


find.aimed.ratios_ <- function(x, 
                               aimed.ratio,
                               corr.nb) {
  
  barrier.model <- inla.barrier.pcmatern.plus(
    mesh = mesh,
    fem = fem,
    barrier.triangles = barrier.triangles,
    prior.range = prior.range,
    prior.sigma = prior.sigma,
    range.fraction = x)
  
  Q <- inla.rgeneric.q(
    barrier.model, 
    "Q",
    theta = c(log(prior.sigma[1]), 
              log(prior.range[1])))
  
  corr.bm <- corr.from.Q.alltogether(
    Q = Q, 
    id.node = id.node, 
    in.id.node = in.id.node)
  
  corr <- c()
  for (i in seq_along(corr.bm)) {
    corr[i] <- corr.bm[[i]]/corr.nb[[i]]
  }
  
  A <- diag(aimed.ratio, nrow = length(aimed.ratio))
  B <- diag(corr, nrow = length(corr))
  M <- A-B
  mini <- norm(M, "F")
  
  return(mini)
}
```

```{r}
aim <- c(0.1, 0.1)
par.i = rep(0.5, length(aim))

corr.ref <- nb.model(rbs = 2, id.node = id.node, in.id.node = in.id.node)$corr

## [[2]] set 2: prior.range = c(0.05, 0.01); prior.sigma = c(1, 0.01)
## [[2]][[1]] set 2, aim c(0.1, 0.1)

opt[[2]][[1]] <- optim(par = par.i, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = corr.ref,
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))
#par[[2]][[1]] <- opt[[2]][[1]]$par

#### `c(0.7, 0.4)` aimed ratio 
aim <- c(0.7, 0.4)

## [[2]][[2]] set 2, aim c(0.7, 0.4)

opt[[2]][[2]] <- optim(par = par.i, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = corr.ref,
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))


#### `c(0.5, 0.5)` aimed ratio 
aim <- c(0.5, 0.5)

## [[2]][[3]] set 2, aim c(0.5, 0.5)

opt[[2]][[3]] <- optim(par = par.i, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = corr.ref,
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))
```

#### aimed ratios

```{r}
res.pp.bm[[2]] <- list()
for (j in 1:3) {
  res.pp.bm[[2]][[j]] <- list()
}

#### `c(0.1, 0.1)` aimed ratio  
x <- opt[[2]][[1]]$par

barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range = prior.range,
                             prior.sigma = prior.sigma,
                             range.fraction = c(x[1],x[2]))

formula.bm <- y ~ 0 + b0 + f(i, model = barrier.model)

## [[2]][[1]] set 2, aim c(0.1, 0.1)

res.pp.bm[[2]][[1]] <- inla(formula.bm,
                 data = inla.stack.data(stk.pp),
                 control.predictor = list(A = inla.stack.A(stk.pp)),
                 family = 'poisson', 
                 E = inla.stack.data(stk.pp)$e, 
                 control.inla = list(int.strategy = "eb"))


#### `c(0.7, 0.4)` aimed ratio  
x <- opt[[2]][[2]]$par

barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range = prior.range,
                             prior.sigma = prior.sigma,
                             range.fraction = c(x[1],x[2]))

formula.bm <- y ~ 0 + b0 + f(i, model = barrier.model)

## [[2]][[2]] set 2, aim c(0.7, 0.4)

res.pp.bm[[2]][[2]] <- inla(formula.bm,
                 data = inla.stack.data(stk.pp),
                 control.predictor = list(A = inla.stack.A(stk.pp)),
                 family = 'poisson', 
                 E = inla.stack.data(stk.pp)$e, 
                 control.inla = list(int.strategy = "eb"))


#### `c(0.5, 0.5)` aimed ratio  
x <- opt[[2]][[3]]$par

barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range = prior.range,
                             prior.sigma = prior.sigma,
                             range.fraction = c(x[1],x[2]))

formula.bm <- y ~ 0 + b0 + f(i, model = barrier.model)

## [[2]][[3]] set 2, aim c(0.5, 0.5)

res.pp.bm[[2]][[3]] <- inla(formula.bm,
                 data = inla.stack.data(stk.pp),
                 control.predictor = list(A = inla.stack.A(stk.pp)),
                 family = 'poisson', 
                 E = inla.stack.data(stk.pp)$e, 
                 control.inla = list(int.strategy = "eb"))
```

### Prior Set 3

prior.range = c(3, .5)
prior.sigma = c(1, 0.01)

#### optim

```{r}
prior.range = c(3, .5)
prior.sigma = c(1, 0.01)

nb.model <- function(rbs, #rbs number of r_b
                     id.node = id.node, 
                     in.id.node = in.id.node) { 
  
  nb.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range,
                             prior.sigma,
                             range.fraction = rep(1, rbs))
  
  Q.nb <- inla.rgeneric.q(nb.model, "Q", 
                          theta = c(log(prior.sigma[1]), log(prior.range[1])))
  
  corr.nb <- 
    corr.from.Q.alltogether(Q = Q.nb,
                            id.node = id.node,
                            in.id.node = in.id.node)
  
  return(list(nb.model = nb.model, Q = Q.nb, corr = corr.nb))
}


find.aimed.ratios_ <- function(x, 
                               aimed.ratio,
                               corr.nb) {
  
  barrier.model <- inla.barrier.pcmatern.plus(
    mesh = mesh,
    fem = fem,
    barrier.triangles = barrier.triangles,
    prior.range = prior.range,
    prior.sigma = prior.sigma,
    range.fraction = x)
  
  Q <- inla.rgeneric.q(
    barrier.model, 
    "Q",
    theta = c(log(prior.sigma[1]), 
              log(prior.range[1])))
  
  corr.bm <- corr.from.Q.alltogether(
    Q = Q, 
    id.node = id.node, 
    in.id.node = in.id.node)
  
  corr <- c()
  for (i in seq_along(corr.bm)) {
    corr[i] <- corr.bm[[i]]/corr.nb[[i]]
  }
  
  A <- diag(aimed.ratio, nrow = length(aimed.ratio))
  B <- diag(corr, nrow = length(corr))
  M <- A-B
  mini <- norm(M, "F")
  
  return(mini)
}
```

```{r}
aim <- c(0.1, 0.1)
par.i = rep(0.5, length(aim))

corr.ref <- nb.model(rbs = 2, id.node = id.node, in.id.node = in.id.node)$corr

## [[3]] set 2: prior.range = c(3, .5); prior.sigma = c(1, 0.01)
## [[3]][[1]] set 2, aim c(0.1, 0.1)

opt[[3]][[1]] <- optim(par = par.i, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = corr.ref,
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))

#### `c(0.7, 0.4)` aimed ratio 
aim <- c(0.7, 0.4)

## [[3]][[2]] set 2, aim c(0.7, 0.4)

opt[[3]][[2]] <- optim(par = par.i, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = corr.ref,
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))


#### `c(0.5, 0.5)` aimed ratio 
aim <- c(0.5, 0.5)

## [[3]][[3]] set 2, aim c(0.5, 0.5)

opt[[3]][[3]] <- optim(par = par.i, find.aimed.ratios_, 
      aimed.ratio = aim, corr.nb = corr.ref,
      method="L-BFGS-B",
      lower = c(0.01, 0.01), 
      upper = c(1,1))
```

#### aimed ratios

```{r}
res.pp.bm[[3]] <- list()
for (j in 1:3) {
  res.pp.bm[[3]][[j]] <- list()
}

#### `c(0.1, 0.1)` aimed ratio  
x <- opt[[3]][[1]]$par

barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range = prior.range,
                             prior.sigma = prior.sigma,
                             range.fraction = c(x[1],x[2]))

formula.bm <- y ~ 0 + b0 + f(i, model = barrier.model)

## [[3]][[1]] set 2, aim c(0.1, 0.1)

res.pp.bm[[3]][[1]] <- inla(formula.bm,
                 data = inla.stack.data(stk.pp),
                 control.predictor = list(A = inla.stack.A(stk.pp)),
                 family = 'poisson', 
                 E = inla.stack.data(stk.pp)$e, 
                 control.inla = list(int.strategy = "eb"))

#### `c(0.7, 0.4)` aimed ratio  
x <- opt[[3]][[2]]$par

barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range = prior.range,
                             prior.sigma = prior.sigma,
                             range.fraction = c(x[1],x[2]))

formula.bm <- y ~ 0 + b0 + f(i, model = barrier.model)

## [[3]][[2]] set 2, aim c(0.7, 0.4)

res.pp.bm[[3]][[2]] <- inla(formula.bm,
                 data = inla.stack.data(stk.pp),
                 control.predictor = list(A = inla.stack.A(stk.pp)),
                 family = 'poisson', 
                 E = inla.stack.data(stk.pp)$e, 
                 control.inla = list(int.strategy = "eb"))


#### `c(0.5, 0.5)` aimed ratio  
x <- opt[[3]][[3]]$par

barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range = prior.range,
                             prior.sigma = prior.sigma,
                             range.fraction = c(x[1],x[2]))

formula.bm <- y ~ 0 + b0 + f(i, model = barrier.model)

## [[3]][[3]] set 2, aim c(0.5, 0.5)

res.pp.bm[[3]][[3]] <- inla(formula.bm,
                 data = inla.stack.data(stk.pp),
                 control.predictor = list(A = inla.stack.A(stk.pp)),
                 family = 'poisson', 
                 E = inla.stack.data(stk.pp)$e, 
                 control.inla = list(int.strategy = "eb"))
```

### Classic Barrier Model

```{r}
x <- c(0.01, 0.01)
for (i in 1:3) {
  res.pp.bm[[i]][[4]] <- list()
}

#### Set 1
prior.range = c(1, 0.5); prior.sigma = c(1, 0.1)
barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range = prior.range,
                             prior.sigma = prior.sigma,
                             range.fraction = c(x[1],x[2]))

formula.bm <- y ~ 0 + b0 + f(i, model = barrier.model)

res.pp.bm[[1]][[4]] <- inla(formula.bm,
                 data = inla.stack.data(stk.pp),
                 control.predictor = list(A = inla.stack.A(stk.pp)),
                 family = 'poisson', 
                 E = inla.stack.data(stk.pp)$e, 
                 control.inla = list(int.strategy = "eb"))

#### Set 2
prior.range = c(0.05, 0.01); prior.sigma = c(1, 0.01)
barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range = prior.range,
                             prior.sigma = prior.sigma,
                             range.fraction = c(x[1],x[2]))

formula.bm <- y ~ 0 + b0 + f(i, model = barrier.model)

res.pp.bm[[2]][[4]] <- inla(formula.bm,
                 data = inla.stack.data(stk.pp),
                 control.predictor = list(A = inla.stack.A(stk.pp)),
                 family = 'poisson', 
                 E = inla.stack.data(stk.pp)$e, 
                 control.inla = list(int.strategy = "eb"))

#### Set 3
prior.range = c(1, 0.5); prior.sigma = c(1, 0.1)
barrier.model <- inla.barrier.pcmatern.plus(mesh, 
                             fem, 
                             barrier.triangles, 
                             prior.range = prior.range,
                             prior.sigma = prior.sigma,
                             range.fraction = c(x[1],x[2]))

formula.bm <- y ~ 0 + b0 + f(i, model = barrier.model)

res.pp.bm[[3]][[4]] <- inla(formula.bm,
                 data = inla.stack.data(stk.pp),
                 control.predictor = list(A = inla.stack.A(stk.pp)),
                 family = 'poisson', 
                 E = inla.stack.data(stk.pp)$e, 
                 control.inla = list(int.strategy = "eb"))

```

### Comparing random effects

```{r}
#### summary range
df_set1 <- rbind(
  cbind(rep("st", nrow(inla.tmarginal(function(x) x, res.pp.stP1$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) x, res.pp.stP1$marginals.hyperpar[[1]])),
  
  cbind(rep("bm", nrow(inla.tmarginal(function(x) exp(x),
                                      res.pp.bm[[1]][[4]]$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[1]][[4]]$marginals.hyperpar[[2]])),
  
  cbind(rep("aim1", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[1]][[1]]$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[1]][[1]]$marginals.hyperpar[[2]])),
  
  cbind(rep("aim2", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[1]][[2]]$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[1]][[2]]$marginals.hyperpar[[2]])),
  
  cbind(rep("aim3", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[1]][[3]]$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[1]][[3]]$marginals.hyperpar[[2]]))
)

df_set2 <- rbind(
  cbind(rep("st", nrow(inla.tmarginal(function(x) x, 
                                      res.pp.stP2$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) x, res.pp.stP2$marginals.hyperpar[[1]])),
  
  cbind(rep("bm", nrow(inla.tmarginal(function(x) exp(x),
                                      res.pp.bm[[2]][[4]]$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[2]][[4]]$marginals.hyperpar[[2]])),
  
  cbind(rep("aim1", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[2]][[1]]$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[2]][[1]]$marginals.hyperpar[[2]])),
  
  cbind(rep("aim2", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[2]][[2]]$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[2]][[2]]$marginals.hyperpar[[2]])),
  
  cbind(rep("aim3", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[2]][[3]]$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[2]][[3]]$marginals.hyperpar[[2]]))
)


df_set3 <- rbind(
  cbind(rep("st", nrow(inla.tmarginal(function(x) x, 
                                      res.pp.stP3$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) x, res.pp.stP3$marginals.hyperpar[[1]])),
  
  cbind(rep("bm", nrow(inla.tmarginal(function(x) exp(x),
                                      res.pp.bm[[3]][[4]]$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[3]][[4]]$marginals.hyperpar[[2]])),
  
  cbind(rep("aim1", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[3]][[1]]$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[3]][[1]]$marginals.hyperpar[[2]])),
  
  cbind(rep("aim2", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[3]][[2]]$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[3]][[2]]$marginals.hyperpar[[2]])),
  
  cbind(rep("aim3", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[3]][[3]]$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[3]][[3]]$marginals.hyperpar[[2]]))
)

df_sets <- rbind(
           cbind(rep("set1", nrow(df_set1)), df_set1),
           cbind(rep("set2", nrow(df_set2)), df_set2),
           cbind(rep("set3", nrow(df_set3)), df_set3))

df_sets <- as.data.frame(df_sets)
colnames(df_sets)[1:2] <- c("set", "model")
df_sets  <- df_sets %>% 
  dplyr::mutate(range = as.numeric(x), density = as.numeric(y))

df_set1 <- 
  df_sets %>% 
  dplyr::filter(set == "set1")

df_set2 <- 
  df_sets %>% 
  dplyr::filter(set == "set2")

df_set3 <- 
  df_sets %>% 
  dplyr::filter(set == "set3")

ggS1 <-   
ggplot(data = df_set1, aes(x = range, y = density, color = model)) +
  geom_line() +
  ggsci::scale_color_ucscgb() +
  xlab("range") +
  ylab("density") +
  xlim(0,50) +
#  ggtitle("prior set 1", 
  labs(subtitle = "Set 1: prior.range = c(1, 0.5); prior.sigma = c(1, 0.1)") +
  labs(caption = "bm: range fraction = c(0.01, 0.01)
       aimed ratio 1 = c(0.1, 0.1); range fraction ~ c(0.12, 0.08) 
       aimed ratio 2 = c(0.7, 0.4); range fraction ~ c(0.16, 0.10) 
       aimed ratio 3 = c(0.5, 0.5); range fraction ~ c(0.15, 0.11)")

ggS2 <-  
ggplot(data = df_set2, aes(x = range, y = density, color = model)) +
  geom_line() +
  ggsci::scale_color_ucscgb() +
  xlab("range") +
  ylab("density") +
  xlim(0,50) +
#  ggtitle("prior set 2", 
  labs(subtitle = "Set 2: prior.range = c(0.05, 0.01); prior.sigma = c(1, 0.01)") +
  labs(caption = "bm: range fraction = c(0.01, 0.01)
       aimed ratio 1 = c(0.1, 0.1); range fraction ~ c(1, 1) 
       aimed ratio 2 = c(0.7, 0.4); range fraction ~ c(1, 1) 
       aimed ratio 3 = c(0.5, 0.5); range fraction ~ c(1, 1)")

ggS3 <-  
ggplot(data = df_set3, aes(x = range, y = density, color = model)) +
  geom_line() +
  ggsci::scale_color_ucscgb() +
  xlab("range") +
  ylab("density") +
  xlim(0,50) +
#  ggtitle("prior set 3", 
  labs(subtitle = "Set 3: prior.range = c(3, .5); prior.sigma = c(1, 0.01)") +
  labs(caption = "bm: range fraction = c(0.01, 0.01)
       aimed ratio 1 = c(0.1, 0.1); range fraction ~ c(0.14, 0.09) 
       aimed ratio 2 = c(0.7, 0.4); range fraction ~ c(0.41, 0.16) 
       aimed ratio 3 = c(0.5, 0.5); range fraction ~ c(0.27, 0.19)")

fpp <- file.path("plots", paste0("pp_posterior.range.png"))
#png(fpp)
gridExtra::grid.arrange(ggS1, ggS3, ggS2, nrow = 3, ncol = 1)
dev.off()

ggS1
ggS3
ggS2
```


```{r}
#### beta0
df_set1 <- rbind(
  cbind(rep("st", nrow(res.pp.stP1$marginals.fixed[[1]])),
        res.pp.stP1$marginals.fixed[[1]]),
  
  cbind(rep("bm", nrow(res.pp.bm[[1]][[4]]$marginals.fixed[[1]])),
        res.pp.bm[[1]][[4]]$marginals.fixed[[1]]),
  
  cbind(rep("aim1", nrow(res.pp.bm[[1]][[1]]$marginals.fixed[[1]])),
        res.pp.bm[[1]][[1]]$marginals.fixed[[1]]),
  cbind(rep("aim2", nrow(res.pp.bm[[1]][[2]]$marginals.fixed[[1]])),
        res.pp.bm[[1]][[2]]$marginals.fixed[[1]]),
  cbind(rep("aim3", nrow(res.pp.bm[[1]][[3]]$marginals.fixed[[1]])),
        res.pp.bm[[1]][[3]]$marginals.fixed[[1]])
)

df_set2 <- rbind(
  cbind(rep("st", nrow(res.pp.stP2$marginals.fixed[[1]])),
        res.pp.stP2$marginals.fixed[[1]]),
  
  cbind(rep("bm", nrow(res.pp.bm[[2]][[4]]$marginals.fixed[[1]])),
        res.pp.bm[[2]][[4]]$marginals.fixed[[1]]),
  
  cbind(rep("aim1", nrow(res.pp.bm[[2]][[1]]$marginals.fixed[[1]])),
        res.pp.bm[[2]][[1]]$marginals.fixed[[1]]),
  cbind(rep("aim2", nrow(res.pp.bm[[2]][[2]]$marginals.fixed[[1]])),
        res.pp.bm[[2]][[2]]$marginals.fixed[[1]]),
  cbind(rep("aim3", nrow(res.pp.bm[[2]][[3]]$marginals.fixed[[1]])),
        res.pp.bm[[2]][[3]]$marginals.fixed[[1]])
)


df_set3 <- rbind(
  cbind(rep("st", nrow(res.pp.stP3$marginals.fixed[[1]])),
        res.pp.stP3$marginals.fixed[[1]]),
  
  cbind(rep("bm", nrow(res.pp.bm[[3]][[4]]$marginals.fixed[[1]])),
        res.pp.bm[[3]][[4]]$marginals.fixed[[1]]),
  
  cbind(rep("aim1", nrow(res.pp.bm[[3]][[1]]$marginals.fixed[[1]])),
        res.pp.bm[[3]][[1]]$marginals.fixed[[1]]),
  cbind(rep("aim2", nrow(res.pp.bm[[3]][[2]]$marginals.fixed[[1]])),
        res.pp.bm[[3]][[2]]$marginals.fixed[[1]]),
  cbind(rep("aim3", nrow(res.pp.bm[[3]][[3]]$marginals.fixed[[1]])),
        res.pp.bm[[3]][[3]]$marginals.fixed[[1]])
)

df_sets <- rbind(
           cbind(rep("set1", nrow(df_set1)), df_set1),
           cbind(rep("set2", nrow(df_set2)), df_set2),
           cbind(rep("set3", nrow(df_set3)), df_set3))

df_sets <- as.data.frame(df_sets)
colnames(df_sets)[1:2] <- c("set", "model")
df_sets  <- df_sets %>% 
  dplyr::mutate(beta0 = as.numeric(x), density = as.numeric(y))

df_set1 <- 
  df_sets %>% 
  dplyr::filter(set == "set1")

df_set2 <- 
  df_sets %>% 
  dplyr::filter(set == "set2")

df_set3 <- 
  df_sets %>% 
  dplyr::filter(set == "set3")

ggS1_b <-   
ggplot(data = df_set1, aes(x = beta0, y = density, color = model)) +
  geom_line() +
  ggsci::scale_color_ucscgb() +
  xlab("beta0") +
  ylab("density") +
#  ggtitle("prior set 1", 
  labs(subtitle = "Set 1: prior.range = c(1, 0.5); prior.sigma = c(1, 0.1)") +
  labs(caption = "bm: range fraction = c(0.01, 0.01)
       aimed ratio 1 = c(0.1, 0.1); range fraction ~ c(0.12, 0.08) 
       aimed ratio 2 = c(0.7, 0.4); range fraction ~ c(0.16, 0.10) 
       aimed ratio 3 = c(0.5, 0.5); range fraction ~ c(0.15, 0.11)")

ggS2_b <-  
ggplot(data = df_set2, aes(x = beta0, y = density, color = model)) +
  geom_line() +
  ggsci::scale_color_ucscgb() +
  xlab("beta0") +
  ylab("density") +
#  ggtitle("prior set 2", 
  labs(subtitle = "Set 2: prior.range = c(0.05, 0.01); prior.sigma = c(1, 0.01)") +
  labs(caption = "bm: range fraction = c(0.01, 0.01)
       aimed ratio 1 = c(0.1, 0.1); range fraction ~ c(1, 1) 
       aimed ratio 2 = c(0.7, 0.4); range fraction ~ c(1, 1) 
       aimed ratio 3 = c(0.5, 0.5); range fraction ~ c(1, 1)")

ggS3_b <-  
ggplot(data = df_set3, aes(x = beta0, y = density, color = model)) +
  geom_line() +
  ggsci::scale_color_ucscgb() +
  xlab("beta0") +
  ylab("density") +
#  ggtitle("prior set 3", 
  labs(subtitle = "Set 3: prior.range = c(3, .5); prior.sigma = c(1, 0.01)") +
  labs(caption = "bm: range fraction = c(0.01, 0.01)
       aimed ratio 1 = c(0.1, 0.1); range fraction ~ c(0.14, 0.09) 
       aimed ratio 2 = c(0.7, 0.4); range fraction ~ c(0.41, 0.16) 
       aimed ratio 3 = c(0.5, 0.5); range fraction ~ c(0.27, 0.19)")

fpp <- file.path("plots", paste0("pp_posterior.b0.png"))
#png(fpp)
gridExtra::grid.arrange(ggS1_b, ggS3_b, ggS2_b, nrow = 3, ncol = 1)
dev.off()

ggS1_b; ggS3_b; ggS2_b
```

```{r}
#### summary sigma
df_set1 <- rbind(
  cbind(rep("st", nrow(inla.tmarginal(function(x) x, res.pp.stP1$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) x, res.pp.stP1$marginals.hyperpar[[2]])),
  
  cbind(rep("bm", nrow(inla.tmarginal(function(x) exp(x),
                                      res.pp.bm[[1]][[4]]$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[1]][[4]]$marginals.hyperpar[[1]])),
  
  cbind(rep("aim1", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[1]][[1]]$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[1]][[1]]$marginals.hyperpar[[1]])),
  
  cbind(rep("aim2", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[1]][[2]]$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[1]][[2]]$marginals.hyperpar[[1]])),
  
  cbind(rep("aim3", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[1]][[3]]$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[1]][[3]]$marginals.hyperpar[[1]]))
)

df_set2 <- rbind(
  cbind(rep("st", nrow(inla.tmarginal(function(x) x, 
                                      res.pp.stP2$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) x, res.pp.stP2$marginals.hyperpar[[2]])),
  
  cbind(rep("bm", nrow(inla.tmarginal(function(x) exp(x),
                                      res.pp.bm[[2]][[4]]$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[2]][[4]]$marginals.hyperpar[[1]])),
  
  cbind(rep("aim1", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[2]][[1]]$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[2]][[1]]$marginals.hyperpar[[1]])),
  
  cbind(rep("aim2", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[2]][[2]]$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[2]][[2]]$marginals.hyperpar[[1]])),
  
  cbind(rep("aim3", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[2]][[3]]$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[2]][[3]]$marginals.hyperpar[[1]]))
)


df_set3 <- rbind(
  cbind(rep("st", nrow(inla.tmarginal(function(x) x, 
                                      res.pp.stP3$marginals.hyperpar[[2]]))),
        inla.tmarginal(function(x) x, res.pp.stP3$marginals.hyperpar[[2]])),
  
  cbind(rep("bm", nrow(inla.tmarginal(function(x) exp(x),
                                      res.pp.bm[[3]][[4]]$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[3]][[4]]$marginals.hyperpar[[1]])),
  
  cbind(rep("aim1", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[3]][[1]]$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[3]][[1]]$marginals.hyperpar[[1]])),
  
  cbind(rep("aim2", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[3]][[2]]$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[3]][[2]]$marginals.hyperpar[[1]])),
  
  cbind(rep("aim3", nrow(inla.tmarginal(function(x) exp(x),
                                        res.pp.bm[[3]][[3]]$marginals.hyperpar[[1]]))),
        inla.tmarginal(function(x) exp(x), res.pp.bm[[3]][[3]]$marginals.hyperpar[[1]]))
)

df_sets <- rbind(
           cbind(rep("set1", nrow(df_set1)), df_set1),
           cbind(rep("set2", nrow(df_set2)), df_set2),
           cbind(rep("set3", nrow(df_set3)), df_set3))

df_sets <- as.data.frame(df_sets)
colnames(df_sets)[1:2] <- c("set", "model")
df_sets  <- df_sets %>% 
  dplyr::mutate(sigma = as.numeric(x), density = as.numeric(y))

df_set1 <- 
  df_sets %>% 
  dplyr::filter(set == "set1")

df_set2 <- 
  df_sets %>% 
  dplyr::filter(set == "set2")

df_set3 <- 
  df_sets %>% 
  dplyr::filter(set == "set3")

ggS1_o <-   
ggplot(data = df_set1, aes(x = sigma, y = density, color = model)) +
  geom_line() +
  ggsci::scale_color_ucscgb() +
  xlab("sigma") +
  ylab("density") +
#  ggtitle("prior set 1", 
  labs(subtitle = "Set 1: prior.range = c(1, 0.5); prior.sigma = c(1, 0.1)") +
  labs(caption = "bm: range fraction = c(0.01, 0.01)
       aimed ratio 1 = c(0.1, 0.1); range fraction ~ c(0.12, 0.08) 
       aimed ratio 2 = c(0.7, 0.4); range fraction ~ c(0.16, 0.10) 
       aimed ratio 3 = c(0.5, 0.5); range fraction ~ c(0.15, 0.11)")

ggS2_o <-  
ggplot(data = df_set2, aes(x = sigma, y = density, color = model)) +
  geom_line() +
  ggsci::scale_color_ucscgb() +
  xlab("sigma") +
  ylab("density") +
#  ggtitle("prior set 2", 
  labs(subtitle = "Set 2: prior.range = c(0.05, 0.01); prior.sigma = c(1, 0.01)") +
  labs(caption = "bm: range fraction = c(0.01, 0.01)
       aimed ratio 1 = c(0.1, 0.1); range fraction ~ c(1, 1) 
       aimed ratio 2 = c(0.7, 0.4); range fraction ~ c(1, 1) 
       aimed ratio 3 = c(0.5, 0.5); range fraction ~ c(1, 1)")

ggS3_o <-  
ggplot(data = df_set3, aes(x = sigma, y = density, color = model)) +
  geom_line() +
  ggsci::scale_color_ucscgb() +
  xlab("sigma") +
  ylab("density") +
#  ggtitle("prior set 3", 
  labs(subtitle = "Set 3: prior.range = c(3, .5); prior.sigma = c(1, 0.01)") +
  labs(caption = "bm: range fraction = c(0.01, 0.01)
       aimed ratio 1 = c(0.1, 0.1); range fraction ~ c(0.14, 0.09) 
       aimed ratio 2 = c(0.7, 0.4); range fraction ~ c(0.41, 0.16) 
       aimed ratio 3 = c(0.5, 0.5); range fraction ~ c(0.27, 0.19)")

fpp <- file.path("plots", paste0("pp_posterior.sigma.png"))
#png(fpp)
gridExtra::grid.arrange(ggS1_o, ggS3_o, ggS2_o, nrow = 3, ncol = 1)
dev.off()

ggS1_o; ggS3_o; ggS2_o
```

### Discussion

Set of priors 2 doesn't make sense when we're considering the range of the barriers to be a fraction of the prior of the normal area, and in this case the prior for the range in the normal area is $0.05$


## Discussion

The difference is in computing the intersection between each polygon in the dual mesh and the study area (w), and not in the mesh itself. If I include the barrier area as a boundary then the mesh won't cover the holes and I wouldn't be able to get the correlation between two mesh nodes.

**Does it make sense or not?**

How the mesh looks if I use the barriers as boundary too 

```{r}
#loc1 <- matrix(c(2,2, 8,2, 8,8, 2,8, 2,2), 5, 2, byrow = T)
#locp <- Polygon(loc1, hole = FALSE)
#cbind(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0))
#loc.d <- loc1

# mesh without using the locations as mesh nodes (SPDE book)
bound.outer = diff(range(lg.s$x))/3
mesh.ppSPDE <- inla.mesh.2d(boundary = pf$poly.water_sf,
                    max.edge = c(1,5)*max.edge.length,
                    cutoff = 0.05,
                    offset = c(max.edge.length, bound.outer))

# mesh using locations as mesh nodes (Archipielago example Haakon)

mesh.ppH <- inla.mesh.2d(boundary = pf$poly.water_sf, #or loc.domain = 
                        loc = xy,
                    max.edge = c(1,5)*max.edge.length,
                    cutoff = 0.05,
                    offset = c(max.edge.length, bound.outer))

ggplot() + 
      inlabru::gg(mesh.ppSPDE) + 
      geom_sf(data =loc.data_sf,
          col='purple',size=1.7,alpha=0.5) 

ggplot() + 
      inlabru::gg(mesh.ppH) + 
      geom_sf(data =loc.data_sf,
          col='purple',size=1.7,alpha=0.5) 

```





